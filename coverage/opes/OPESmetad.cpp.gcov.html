<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - plumed test coverage - opes/OPESmetad.cpp</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">opes</a> - OPESmetad.cpp<span style="font-size: 80%;"> (source / <a href="OPESmetad.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">plumed test coverage</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">795</td>
            <td class="headerCovTableEntry">831</td>
            <td class="headerCovTableEntryHi">95.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2024-10-18 14:29:08</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">33</td>
            <td class="headerCovTableEntry">34</td>
            <td class="headerCovTableEntryHi">97.1 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</a>
<a name="2"><span class="lineNum">       2 </span>            :    Copyright (c) 2020-2021 of Michele Invernizzi.</a>
<a name="3"><span class="lineNum">       3 </span>            : </a>
<a name="4"><span class="lineNum">       4 </span>            :    This file is part of the OPES plumed module.</a>
<a name="5"><span class="lineNum">       5 </span>            : </a>
<a name="6"><span class="lineNum">       6 </span>            :    The OPES plumed module is free software: you can redistribute it and/or modify</a>
<a name="7"><span class="lineNum">       7 </span>            :    it under the terms of the GNU Lesser General Public License as published by</a>
<a name="8"><span class="lineNum">       8 </span>            :    the Free Software Foundation, either version 3 of the License, or</a>
<a name="9"><span class="lineNum">       9 </span>            :    (at your option) any later version.</a>
<a name="10"><span class="lineNum">      10 </span>            : </a>
<a name="11"><span class="lineNum">      11 </span>            :    The OPES plumed module is distributed in the hope that it will be useful,</a>
<a name="12"><span class="lineNum">      12 </span>            :    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="13"><span class="lineNum">      13 </span>            :    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="14"><span class="lineNum">      14 </span>            :    GNU Lesser General Public License for more details.</a>
<a name="15"><span class="lineNum">      15 </span>            : </a>
<a name="16"><span class="lineNum">      16 </span>            :    You should have received a copy of the GNU Lesser General Public License</a>
<a name="17"><span class="lineNum">      17 </span>            :    along with plumed.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="18"><span class="lineNum">      18 </span>            : +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */</a>
<a name="19"><span class="lineNum">      19 </span>            : #include &quot;bias/Bias.h&quot;</a>
<a name="20"><span class="lineNum">      20 </span>            : #include &quot;core/PlumedMain.h&quot;</a>
<a name="21"><span class="lineNum">      21 </span>            : #include &quot;core/ActionRegister.h&quot;</a>
<a name="22"><span class="lineNum">      22 </span>            : #include &quot;core/Atoms.h&quot;</a>
<a name="23"><span class="lineNum">      23 </span>            : #include &quot;tools/Communicator.h&quot;</a>
<a name="24"><span class="lineNum">      24 </span>            : #include &quot;tools/File.h&quot;</a>
<a name="25"><span class="lineNum">      25 </span>            : #include &quot;tools/OpenMP.h&quot;</a>
<a name="26"><span class="lineNum">      26 </span>            : </a>
<a name="27"><span class="lineNum">      27 </span>            : namespace PLMD {</a>
<a name="28"><span class="lineNum">      28 </span>            : namespace opes {</a>
<a name="29"><span class="lineNum">      29 </span>            : </a>
<a name="30"><span class="lineNum">      30 </span>            : //+PLUMEDOC OPES_BIAS OPES_METAD</a>
<a name="31"><span class="lineNum">      31 </span>            : /*</a>
<a name="32"><span class="lineNum">      32 </span>            : On-the-fly probability enhanced sampling with metadynamics-like target distribution.</a>
<a name="33"><span class="lineNum">      33 </span>            : </a>
<a name="34"><span class="lineNum">      34 </span>            : This On-the-fly probability enhanced sampling (\ref OPES &quot;OPES&quot;) method with metadynamics-like target distribution is described in \cite Invernizzi2020rethinking.</a>
<a name="35"><span class="lineNum">      35 </span>            : </a>
<a name="36"><span class="lineNum">      36 </span>            : This \ref OPES_METAD action samples target distributions defined via their marginal \f$p^{\text{tg}}(\mathbf{s})\f$ over some collective variables (CVs), \f$\mathbf{s}=\mathbf{s}(\mathbf{x})\f$.</a>
<a name="37"><span class="lineNum">      37 </span>            : By default \ref OPES_METAD targets the well-tempered distribution, \f$p^{\text{WT}}(\mathbf{s})\propto [P(\mathbf{s})]^{1/\gamma}\f$, where \f$\gamma\f$ is known as BIASFACTOR.</a>
<a name="38"><span class="lineNum">      38 </span>            : Similarly to \ref METAD, \ref OPES_METAD optimizes the bias on-the-fly, with a given PACE.</a>
<a name="39"><span class="lineNum">      39 </span>            : It does so by reweighting via kernel density estimation the unbiased distribution in the CV space, \f$P(\mathbf{s})\f$.</a>
<a name="40"><span class="lineNum">      40 </span>            : A compression algorithm is used to prevent the number of kernels from growing linearly with the simulation time.</a>
<a name="41"><span class="lineNum">      41 </span>            : The bias at step \f$n\f$ is</a>
<a name="42"><span class="lineNum">      42 </span>            : \f[</a>
<a name="43"><span class="lineNum">      43 </span>            : V_n(\mathbf{s}) = (1-1/\gamma)\frac{1}{\beta}\log\left(\frac{P_n(\mathbf{s})}{Z_n}+\epsilon\right)\, .</a>
<a name="44"><span class="lineNum">      44 </span>            : \f]</a>
<a name="45"><span class="lineNum">      45 </span>            : See Ref.\cite Invernizzi2020rethinking for a complete description of the method.</a>
<a name="46"><span class="lineNum">      46 </span>            : </a>
<a name="47"><span class="lineNum">      47 </span>            : As an intuitive picture, rather than gradually filling the metastable basins, \ref OPES_METAD quickly tries to get a coarse idea of the full free energy surface (FES), and then slowly refines its details.</a>
<a name="48"><span class="lineNum">      48 </span>            : It has a fast initial exploration phase, and then becomes extremely conservative and does not significantly change the shape of the deposited bias any more, reaching a regime of quasi-static bias.</a>
<a name="49"><span class="lineNum">      49 </span>            : For this reason, it is possible to use standard umbrella sampling reweighting (see \ref REWEIGHT_BIAS) to analyse the trajectory.</a>
<a name="50"><span class="lineNum">      50 </span>            : At &lt;a href=&quot;https://github.com/invemichele/opes/tree/master/postprocessing&quot;&gt;this link&lt;/a&gt; you can find some python scripts that work in a similar way to \ref sum_hills, but the preferred way to obtain a FES with OPES is via reweighting (see \ref opes-metad).</a>
<a name="51"><span class="lineNum">      51 </span>            : The estimated \f$c(t)\f$ is printed for reference only, since it should converge to a fixed value as the bias converges.</a>
<a name="52"><span class="lineNum">      52 </span>            : This \f$c(t)\f$ should NOT be used for reweighting.</a>
<a name="53"><span class="lineNum">      53 </span>            : Similarly, the \f$Z_n\f$ factor is printed only for reference, and it should converge when no new region of the CV-space is explored.</a>
<a name="54"><span class="lineNum">      54 </span>            : </a>
<a name="55"><span class="lineNum">      55 </span>            : Notice that \ref OPES_METAD is more sensitive to degenerate CVs than \ref METAD.</a>
<a name="56"><span class="lineNum">      56 </span>            : If the employed CVs map different metastable basins onto the same CV-space region, then \ref OPES_METAD will remain stuck rather than completely reshaping the bias.</a>
<a name="57"><span class="lineNum">      57 </span>            : This can be useful to diagnose problems with your collective variable.</a>
<a name="58"><span class="lineNum">      58 </span>            : If it is not possible to improve the set of CVs and remove this degeneracy, then you might instead consider to use \ref OPES_METAD_EXPLORE or \ref METAD.</a>
<a name="59"><span class="lineNum">      59 </span>            : In this way you will be able to obtain an estimate of the FES, but be aware that you most likely will not reach convergence and thus this estimate will be subjected to systematic errors (see e.g. Fig.3 in \cite Pietrucci2017review).</a>
<a name="60"><span class="lineNum">      60 </span>            : On the contrary, if your CVs are not degenerate but only suboptimal, you should converge faster by using \ref OPES_METAD instead of \ref METAD \cite Invernizzi2020rethinking.</a>
<a name="61"><span class="lineNum">      61 </span>            : </a>
<a name="62"><span class="lineNum">      62 </span>            : The parameter BARRIER should be set to be at least equal to the highest free energy barrier you wish to overcome.</a>
<a name="63"><span class="lineNum">      63 </span>            : If it is much lower than that, you will not cross the barrier, if it is much higher, convergence might take a little longer.</a>
<a name="64"><span class="lineNum">      64 </span>            : If the system has a basin that is clearly more stable than the others, it is better to start the simulation from there.</a>
<a name="65"><span class="lineNum">      65 </span>            : </a>
<a name="66"><span class="lineNum">      66 </span>            : By default, the kernels SIGMA is adaptive, estimated from the fluctuations over ADAPTIVE_SIGMA_STRIDE simulation steps (similar to \ref METAD ADAPTIVE=DIFF, but contrary to that, no artifacts are introduced and the bias will converge to the correct one).</a>
<a name="67"><span class="lineNum">      67 </span>            : However, notice that depending on the system this might not be the optimal choice for SIGMA.</a>
<a name="68"><span class="lineNum">      68 </span>            : </a>
<a name="69"><span class="lineNum">      69 </span>            : You can target a uniform flat distribution by explicitly setting BIASFACTOR=inf.</a>
<a name="70"><span class="lineNum">      70 </span>            : However, this should be useful only in very specific cases.</a>
<a name="71"><span class="lineNum">      71 </span>            : </a>
<a name="72"><span class="lineNum">      72 </span>            : It is possible to take into account also of other bias potentials besides the one of \ref OPES_METAD during the internal reweighting for \f$P(\mathbf{s})\f$ estimation.</a>
<a name="73"><span class="lineNum">      73 </span>            : To do so, one has to add those biases with the EXTRA_BIAS keyword, as in the example below.</a>
<a name="74"><span class="lineNum">      74 </span>            : This allows one to define a custom target distribution by adding another bias potential equal to the desired target free energy and setting BIASFACTOR=inf (see example below).</a>
<a name="75"><span class="lineNum">      75 </span>            : Another possible usage of EXTRA_BIAS is to make sure that \ref OPES_METAD does not push against another fixed bias added to restrain the CVs range (e.g. \ref UPPER_WALLS).</a>
<a name="76"><span class="lineNum">      76 </span>            : </a>
<a name="77"><span class="lineNum">      77 </span>            : Through the EXCLUDED_REGION keywork, it is possible to specify a region of CV space where no kernels will be deposited.</a>
<a name="78"><span class="lineNum">      78 </span>            : This can be useful for example for making sure the bias does not modify the transition region, thus allowing for rate calculation.</a>
<a name="79"><span class="lineNum">      79 </span>            : See below for an example of how to use this keyword.</a>
<a name="80"><span class="lineNum">      80 </span>            : </a>
<a name="81"><span class="lineNum">      81 </span>            : Restart can be done from a KERNELS file, but it might be not perfect (due to limited precision when printing kernels to file, or if adaptive SIGMA is used).</a>
<a name="82"><span class="lineNum">      82 </span>            : For an exact restart you must use STATE_RFILE to read a checkpoint with all the needed info.</a>
<a name="83"><span class="lineNum">      83 </span>            : To save such checkpoints, define a STATE_WFILE and choose how often to print them with STATE_WSTRIDE.</a>
<a name="84"><span class="lineNum">      84 </span>            : By default this file is overwritten, but you can instead append to it using the flag STORE_STATES.</a>
<a name="85"><span class="lineNum">      85 </span>            : </a>
<a name="86"><span class="lineNum">      86 </span>            : Multiple walkers are supported only with MPI communication, via the keyword WALKERS_MPI.</a>
<a name="87"><span class="lineNum">      87 </span>            : </a>
<a name="88"><span class="lineNum">      88 </span>            : \par Examples</a>
<a name="89"><span class="lineNum">      89 </span>            : </a>
<a name="90"><span class="lineNum">      90 </span>            : Several examples can be found on the &lt;a href=&quot;https://www.plumed-nest.org/browse.html&quot;&gt;PLUMED-NEST website&lt;/a&gt;, by searching for the OPES keyword.</a>
<a name="91"><span class="lineNum">      91 </span>            : The \ref opes-metad can also be useful to get started with the method.</a>
<a name="92"><span class="lineNum">      92 </span>            : </a>
<a name="93"><span class="lineNum">      93 </span>            : The following is a minimal working example:</a>
<a name="94"><span class="lineNum">      94 </span>            : </a>
<a name="95"><span class="lineNum">      95 </span>            : \plumedfile</a>
<a name="96"><span class="lineNum">      96 </span>            : cv: DISTANCE ATOMS=1,2</a>
<a name="97"><span class="lineNum">      97 </span>            : opes: OPES_METAD ARG=cv PACE=200 BARRIER=40</a>
<a name="98"><span class="lineNum">      98 </span>            : PRINT STRIDE=200 FILE=COLVAR ARG=*</a>
<a name="99"><span class="lineNum">      99 </span>            : \endplumedfile</a>
<a name="100"><span class="lineNum">     100 </span>            : </a>
<a name="101"><span class="lineNum">     101 </span>            : Another more articulated one:</a>
<a name="102"><span class="lineNum">     102 </span>            : </a>
<a name="103"><span class="lineNum">     103 </span>            : \plumedfile</a>
<a name="104"><span class="lineNum">     104 </span>            : phi: TORSION ATOMS=5,7,9,15</a>
<a name="105"><span class="lineNum">     105 </span>            : psi: TORSION ATOMS=7,9,15,17</a>
<a name="106"><span class="lineNum">     106 </span>            : opes: OPES_METAD ...</a>
<a name="107"><span class="lineNum">     107 </span>            :   FILE=Kernels.data</a>
<a name="108"><span class="lineNum">     108 </span>            :   TEMP=300</a>
<a name="109"><span class="lineNum">     109 </span>            :   ARG=phi,psi</a>
<a name="110"><span class="lineNum">     110 </span>            :   PACE=500</a>
<a name="111"><span class="lineNum">     111 </span>            :   BARRIER=50</a>
<a name="112"><span class="lineNum">     112 </span>            :   SIGMA=0.15,0.15</a>
<a name="113"><span class="lineNum">     113 </span>            :   SIGMA_MIN=0.01,0.01</a>
<a name="114"><span class="lineNum">     114 </span>            :   STATE_RFILE=Restart.data</a>
<a name="115"><span class="lineNum">     115 </span>            :   STATE_WFILE=State.data</a>
<a name="116"><span class="lineNum">     116 </span>            :   STATE_WSTRIDE=500*100</a>
<a name="117"><span class="lineNum">     117 </span>            :   STORE_STATES</a>
<a name="118"><span class="lineNum">     118 </span>            :   WALKERS_MPI</a>
<a name="119"><span class="lineNum">     119 </span>            :   NLIST</a>
<a name="120"><span class="lineNum">     120 </span>            : ...</a>
<a name="121"><span class="lineNum">     121 </span>            : PRINT FMT=%g STRIDE=500 FILE=Colvar.data ARG=phi,psi,opes.*</a>
<a name="122"><span class="lineNum">     122 </span>            : \endplumedfile</a>
<a name="123"><span class="lineNum">     123 </span>            : </a>
<a name="124"><span class="lineNum">     124 </span>            : Next is an example of how to define a custom target distribution different from the well-tempered one.</a>
<a name="125"><span class="lineNum">     125 </span>            : Here we chose to focus more on the transition state, that is around \f$\phi=0\f$.</a>
<a name="126"><span class="lineNum">     126 </span>            : Our target distribution is a Gaussian centered there, thus the target free energy we want to sample is a parabola, \f$F^{\text{tg}}(\mathbf{s})=-\frac{1}{\beta} \log [p^{\text{tg}}(\mathbf{s})]\f$.</a>
<a name="127"><span class="lineNum">     127 </span>            : </a>
<a name="128"><span class="lineNum">     128 </span>            : \plumedfile</a>
<a name="129"><span class="lineNum">     129 </span>            : phi: TORSION ATOMS=5,7,9,15</a>
<a name="130"><span class="lineNum">     130 </span>            : FtgValue: CUSTOM ARG=phi PERIODIC=NO FUNC=(x/0.4)^2</a>
<a name="131"><span class="lineNum">     131 </span>            : Ftg: BIASVALUE ARG=FtgValue</a>
<a name="132"><span class="lineNum">     132 </span>            : opes: OPES_METAD ...</a>
<a name="133"><span class="lineNum">     133 </span>            :   ARG=phi</a>
<a name="134"><span class="lineNum">     134 </span>            :   PACE=500</a>
<a name="135"><span class="lineNum">     135 </span>            :   BARRIER=50</a>
<a name="136"><span class="lineNum">     136 </span>            :   SIGMA=0.2</a>
<a name="137"><span class="lineNum">     137 </span>            :   BIASFACTOR=inf</a>
<a name="138"><span class="lineNum">     138 </span>            :   EXTRA_BIAS=Ftg.bias</a>
<a name="139"><span class="lineNum">     139 </span>            : ...</a>
<a name="140"><span class="lineNum">     140 </span>            : PRINT FMT=%g STRIDE=500 FILE=COLVAR ARG=phi,Ftg.bias,opes.bias</a>
<a name="141"><span class="lineNum">     141 </span>            : \endplumedfile</a>
<a name="142"><span class="lineNum">     142 </span>            : </a>
<a name="143"><span class="lineNum">     143 </span>            : Notice that in order to reweight for the unbiased \f$P(\mathbf{s})\f$ during postprocessing, the total bias `Ftg.bias+opes.bias` must be used.</a>
<a name="144"><span class="lineNum">     144 </span>            : </a>
<a name="145"><span class="lineNum">     145 </span>            : Finally, an example of how to use the EXCLUDED_REGION keyword.</a>
<a name="146"><span class="lineNum">     146 </span>            : It expects a characteristic function that is different from zero in the region to be excluded.</a>
<a name="147"><span class="lineNum">     147 </span>            : You can use \ref CUSTOM and a combination of the step function to define it.</a>
<a name="148"><span class="lineNum">     148 </span>            : With the following input no kernel is deposited in the transition state region of alanine dipeptide, defined by the interval \f$\phi \in [-0.6, 0.7]\f$:</a>
<a name="149"><span class="lineNum">     149 </span>            : </a>
<a name="150"><span class="lineNum">     150 </span>            : \plumedfile</a>
<a name="151"><span class="lineNum">     151 </span>            : phi: TORSION ATOMS=5,7,9,15</a>
<a name="152"><span class="lineNum">     152 </span>            : psi: TORSION ATOMS=7,9,15,17</a>
<a name="153"><span class="lineNum">     153 </span>            : xx: CUSTOM PERIODIC=NO ARG=phi FUNC=step(x+0.6)-step(x-0.7)</a>
<a name="154"><span class="lineNum">     154 </span>            : opes: OPES_METAD ...</a>
<a name="155"><span class="lineNum">     155 </span>            :   ARG=phi,psi</a>
<a name="156"><span class="lineNum">     156 </span>            :   PACE=500</a>
<a name="157"><span class="lineNum">     157 </span>            :   BARRIER=30</a>
<a name="158"><span class="lineNum">     158 </span>            :   EXCLUDED_REGION=xx</a>
<a name="159"><span class="lineNum">     159 </span>            :   NLIST</a>
<a name="160"><span class="lineNum">     160 </span>            : ...</a>
<a name="161"><span class="lineNum">     161 </span>            : PRINT FMT=%g STRIDE=500 FILE=COLVAR ARG=phi,psi,xx,opes.*</a>
<a name="162"><span class="lineNum">     162 </span>            : \endplumedfile</a>
<a name="163"><span class="lineNum">     163 </span>            : </a>
<a name="164"><span class="lineNum">     164 </span>            : */</a>
<a name="165"><span class="lineNum">     165 </span>            : //+ENDPLUMEDOC</a>
<a name="166"><span class="lineNum">     166 </span>            : </a>
<a name="167"><span class="lineNum">     167 </span>            : template &lt;class mode&gt;</a>
<a name="168"><span class="lineNum">     168 </span>            : class OPESmetad : public bias::Bias {</a>
<a name="169"><span class="lineNum">     169 </span>            : </a>
<a name="170"><span class="lineNum">     170 </span>            : private:</a>
<a name="171"><span class="lineNum">     171 </span>            :   bool isFirstStep_;</a>
<a name="172"><span class="lineNum">     172 </span>            :   unsigned NumOMP_;</a>
<a name="173"><span class="lineNum">     173 </span>            :   unsigned NumParallel_;</a>
<a name="174"><span class="lineNum">     174 </span>            :   unsigned rank_;</a>
<a name="175"><span class="lineNum">     175 </span>            :   unsigned NumWalkers_;</a>
<a name="176"><span class="lineNum">     176 </span>            :   unsigned walker_rank_;</a>
<a name="177"><span class="lineNum">     177 </span>            :   unsigned long long counter_;</a>
<a name="178"><span class="lineNum">     178 </span>            :   std::size_t ncv_;</a>
<a name="179"><span class="lineNum">     179 </span>            : </a>
<a name="180"><span class="lineNum">     180 </span>            :   double kbt_;</a>
<a name="181"><span class="lineNum">     181 </span>            :   double biasfactor_;</a>
<a name="182"><span class="lineNum">     182 </span>            :   double bias_prefactor_;</a>
<a name="183"><span class="lineNum">     183 </span>            :   unsigned stride_;</a>
<a name="184"><span class="lineNum">     184 </span>            :   std::vector&lt;double&gt; sigma0_;</a>
<a name="185"><span class="lineNum">     185 </span>            :   std::vector&lt;double&gt; sigma_min_;</a>
<a name="186"><span class="lineNum">     186 </span>            :   unsigned adaptive_sigma_stride_;</a>
<a name="187"><span class="lineNum">     187 </span>            :   unsigned long long adaptive_counter_;</a>
<a name="188"><span class="lineNum">     188 </span>            :   std::vector&lt;double&gt; av_cv_;</a>
<a name="189"><span class="lineNum">     189 </span>            :   std::vector&lt;double&gt; av_M2_;</a>
<a name="190"><span class="lineNum">     190 </span>            :   bool fixed_sigma_;</a>
<a name="191"><span class="lineNum">     191 </span>            :   bool adaptive_sigma_;</a>
<a name="192"><span class="lineNum">     192 </span>            :   double epsilon_;</a>
<a name="193"><span class="lineNum">     193 </span>            :   double sum_weights_;</a>
<a name="194"><span class="lineNum">     194 </span>            :   double sum_weights2_;</a>
<a name="195"><span class="lineNum">     195 </span>            : </a>
<a name="196"><span class="lineNum">     196 </span>            :   bool no_Zed_;</a>
<a name="197"><span class="lineNum">     197 </span>            :   double Zed_;</a>
<a name="198"><span class="lineNum">     198 </span>            :   double KDEnorm_;</a>
<a name="199"><span class="lineNum">     199 </span>            : </a>
<a name="200"><span class="lineNum">     200 </span>            :   double threshold2_;</a>
<a name="201"><span class="lineNum">     201 </span>            :   bool recursive_merge_;</a>
<a name="202"><span class="lineNum">     202 </span>            : //kernels are truncated diagonal Gaussians</a>
<a name="203"><span class="lineNum">     203 </span><span class="lineCov">       1050 :   struct kernel</span></a>
<a name="204"><span class="lineNum">     204 </span>            :   {</a>
<a name="205"><span class="lineNum">     205 </span>            :     double height;</a>
<a name="206"><span class="lineNum">     206 </span>            :     std::vector&lt;double&gt; center;</a>
<a name="207"><span class="lineNum">     207 </span>            :     std::vector&lt;double&gt; sigma;</a>
<a name="208"><span class="lineNum">     208 </span><span class="lineCov">       1050 :     kernel(double h, const std::vector&lt;double&gt;&amp; c,const std::vector&lt;double&gt;&amp; s):</span></a>
<a name="209"><span class="lineNum">     209 </span><span class="lineCov">       1050 :       height(h),center(c),sigma(s) {}</span></a>
<a name="210"><span class="lineNum">     210 </span>            :   };</a>
<a name="211"><span class="lineNum">     211 </span>            :   double cutoff2_;</a>
<a name="212"><span class="lineNum">     212 </span>            :   double val_at_cutoff_;</a>
<a name="213"><span class="lineNum">     213 </span>            :   void mergeKernels(kernel&amp;,const kernel&amp;); //merge the second one into the first one</a>
<a name="214"><span class="lineNum">     214 </span>            :   double evaluateKernel(const kernel&amp;,const std::vector&lt;double&gt;&amp;) const;</a>
<a name="215"><span class="lineNum">     215 </span>            :   double evaluateKernel(const kernel&amp;,const std::vector&lt;double&gt;&amp;,std::vector&lt;double&gt;&amp;,std::vector&lt;double&gt;&amp;);</a>
<a name="216"><span class="lineNum">     216 </span>            :   std::vector&lt;kernel&gt; kernels_; //all compressed kernels</a>
<a name="217"><span class="lineNum">     217 </span>            :   OFile kernelsOfile_;</a>
<a name="218"><span class="lineNum">     218 </span>            : //neighbour list stuff</a>
<a name="219"><span class="lineNum">     219 </span>            :   bool nlist_;</a>
<a name="220"><span class="lineNum">     220 </span>            :   double nlist_param_[2];</a>
<a name="221"><span class="lineNum">     221 </span>            :   std::vector&lt;unsigned&gt; nlist_index_;</a>
<a name="222"><span class="lineNum">     222 </span>            :   std::vector&lt;double&gt; nlist_center_;</a>
<a name="223"><span class="lineNum">     223 </span>            :   std::vector&lt;double&gt; nlist_dev2_;</a>
<a name="224"><span class="lineNum">     224 </span>            :   unsigned nlist_steps_;</a>
<a name="225"><span class="lineNum">     225 </span>            :   bool nlist_update_;</a>
<a name="226"><span class="lineNum">     226 </span>            :   bool nlist_pace_reset_;</a>
<a name="227"><span class="lineNum">     227 </span>            : </a>
<a name="228"><span class="lineNum">     228 </span>            :   bool calc_work_;</a>
<a name="229"><span class="lineNum">     229 </span>            :   double work_;</a>
<a name="230"><span class="lineNum">     230 </span>            :   double old_KDEnorm_;</a>
<a name="231"><span class="lineNum">     231 </span>            :   std::vector&lt;kernel&gt; delta_kernels_;</a>
<a name="232"><span class="lineNum">     232 </span>            : </a>
<a name="233"><span class="lineNum">     233 </span>            :   Value* excluded_region_;</a>
<a name="234"><span class="lineNum">     234 </span>            :   std::vector&lt;Value*&gt; extra_biases_;</a>
<a name="235"><span class="lineNum">     235 </span>            : </a>
<a name="236"><span class="lineNum">     236 </span>            :   OFile stateOfile_;</a>
<a name="237"><span class="lineNum">     237 </span>            :   int wStateStride_;</a>
<a name="238"><span class="lineNum">     238 </span>            :   bool storeOldStates_;</a>
<a name="239"><span class="lineNum">     239 </span>            : </a>
<a name="240"><span class="lineNum">     240 </span>            :   double getProbAndDerivatives(const std::vector&lt;double&gt;&amp;,std::vector&lt;double&gt;&amp;);</a>
<a name="241"><span class="lineNum">     241 </span>            :   void addKernel(const double,const std::vector&lt;double&gt;&amp;,const std::vector&lt;double&gt;&amp;);</a>
<a name="242"><span class="lineNum">     242 </span>            :   void addKernel(const double,const std::vector&lt;double&gt;&amp;,const std::vector&lt;double&gt;&amp;,const double); //also print to file</a>
<a name="243"><span class="lineNum">     243 </span>            :   unsigned getMergeableKernel(const std::vector&lt;double&gt;&amp;,const unsigned);</a>
<a name="244"><span class="lineNum">     244 </span>            :   void updateNlist(const std::vector&lt;double&gt;&amp;);</a>
<a name="245"><span class="lineNum">     245 </span>            :   void dumpStateToFile();</a>
<a name="246"><span class="lineNum">     246 </span>            : </a>
<a name="247"><span class="lineNum">     247 </span>            : public:</a>
<a name="248"><span class="lineNum">     248 </span>            :   explicit OPESmetad(const ActionOptions&amp;);</a>
<a name="249"><span class="lineNum">     249 </span>            :   void calculate() override;</a>
<a name="250"><span class="lineNum">     250 </span>            :   void update() override;</a>
<a name="251"><span class="lineNum">     251 </span>            :   static void registerKeywords(Keywords&amp; keys);</a>
<a name="252"><span class="lineNum">     252 </span>            : };</a>
<a name="253"><span class="lineNum">     253 </span>            : </a>
<a name="254"><span class="lineNum">     254 </span>            : struct convergence { static const bool explore=false; };</a>
<a name="255"><span class="lineNum">     255 </span>            : typedef OPESmetad&lt;convergence&gt; OPESmetad_c;</a>
<a name="256"><span class="lineNum">     256 </span><span class="lineCov">      12637 : PLUMED_REGISTER_ACTION(OPESmetad_c,&quot;OPES_METAD&quot;)</span></a>
<a name="257"><span class="lineNum">     257 </span>            : </a>
<a name="258"><span class="lineNum">     258 </span>            : //OPES_METAD_EXPLORE is very similar from the point of view of the code,</a>
<a name="259"><span class="lineNum">     259 </span>            : //but conceptually it is better to make it a separate BIAS action</a>
<a name="260"><span class="lineNum">     260 </span>            : </a>
<a name="261"><span class="lineNum">     261 </span>            : //+PLUMEDOC OPES_BIAS OPES_METAD_EXPLORE</a>
<a name="262"><span class="lineNum">     262 </span>            : /*</a>
<a name="263"><span class="lineNum">     263 </span>            : On-the-fly probability enhanced sampling with well-tempered target distribution in exploreation mode.</a>
<a name="264"><span class="lineNum">     264 </span>            : </a>
<a name="265"><span class="lineNum">     265 </span>            : On-the-fly probability enhanced sampling with well-tempered target distribution (\ref OPES &quot;OPES&quot;) with well-tempered target distribution, exploration mode \cite Invernizzi2022explore .</a>
<a name="266"><span class="lineNum">     266 </span>            : </a>
<a name="267"><span class="lineNum">     267 </span>            : This \ref OPES_METAD_EXPLORE action samples the well-tempered target distribution, that is defined via its marginal \f$p^{\text{WT}}(\mathbf{s})\propto [P(\mathbf{s})]^{1/\gamma}\f$ over some collective variables (CVs), \f$\mathbf{s}=\mathbf{s}(\mathbf{x})\f$.</a>
<a name="268"><span class="lineNum">     268 </span>            : While \ref OPES_METAD does so by estimating the unbiased distribution \f$P(\mathbf{s})\f$, \ref OPES_METAD_EXPLORE instead estimates on-the-fly the target \f$p^{\text{WT}}(\mathbf{s})\f$ and uses it to define the bias.</a>
<a name="269"><span class="lineNum">     269 </span>            : The bias at step \f$n\f$ is</a>
<a name="270"><span class="lineNum">     270 </span>            : \f[</a>
<a name="271"><span class="lineNum">     271 </span>            : V_n(\mathbf{s}) = (\gamma-1)\frac{1}{\beta}\log\left(\frac{p^{\text{WT}}_n(\mathbf{s})}{Z_n}+\epsilon\right)\, .</a>
<a name="272"><span class="lineNum">     272 </span>            : \f]</a>
<a name="273"><span class="lineNum">     273 </span>            : See Ref.\cite Invernizzi2022explore for a complete description of the method.</a>
<a name="274"><span class="lineNum">     274 </span>            : </a>
<a name="275"><span class="lineNum">     275 </span>            : Intuitively, while \ref OPES_METAD aims at quickly converging the reweighted free energy, \ref OPES_METAD_EXPLORE aims at quickly sampling the target well-tempered distribution.</a>
<a name="276"><span class="lineNum">     276 </span>            : Given enough simulation time, both will converge to the same bias potential but they do so in a qualitatively different way.</a>
<a name="277"><span class="lineNum">     277 </span>            : Compared to \ref OPES_METAD, \ref OPES_METAD_EXPLORE is more similar to \ref METAD, because it allows the bias to vary significantly, thus enhancing exploration.</a>
<a name="278"><span class="lineNum">     278 </span>            : This goes at the expenses of a typically slower convergence of the reweight estimate.</a>
<a name="279"><span class="lineNum">     279 </span>            : \ref OPES_METAD_EXPLORE can be useful e.g.~for simulating a new system with an unknown BARRIER, or for quickly testing the effectiveness of a new CV that might be degenerate.</a>
<a name="280"><span class="lineNum">     280 </span>            : </a>
<a name="281"><span class="lineNum">     281 </span>            : Similarly to \ref OPES_METAD, also \ref OPES_METAD_EXPLORE uses a kernel density estimation with the same on-the-fly compression algorithm.</a>
<a name="282"><span class="lineNum">     282 </span>            : The only difference is that the kernels are not weighted, since it estimates the sampled distribution and not the reweighted unbiased one.</a>
<a name="283"><span class="lineNum">     283 </span>            : </a>
<a name="284"><span class="lineNum">     284 </span>            : All the options of \ref OPES_METAD are also available in \ref OPES_METAD_EXPLORE, except for those that modify the target distribution, since only a well-tempered target is allowed in this case.</a>
<a name="285"><span class="lineNum">     285 </span>            : </a>
<a name="286"><span class="lineNum">     286 </span>            : \par Examples</a>
<a name="287"><span class="lineNum">     287 </span>            : </a>
<a name="288"><span class="lineNum">     288 </span>            : The following is a minimal working example:</a>
<a name="289"><span class="lineNum">     289 </span>            : </a>
<a name="290"><span class="lineNum">     290 </span>            : \plumedfile</a>
<a name="291"><span class="lineNum">     291 </span>            : cv: DISTANCE ATOMS=1,2</a>
<a name="292"><span class="lineNum">     292 </span>            : opes: OPES_METAD_EXPLORE ARG=cv PACE=500 BARRIER=40</a>
<a name="293"><span class="lineNum">     293 </span>            : PRINT STRIDE=100 FILE=COLVAR ARG=cv,opes.*</a>
<a name="294"><span class="lineNum">     294 </span>            : \endplumedfile</a>
<a name="295"><span class="lineNum">     295 </span>            : */</a>
<a name="296"><span class="lineNum">     296 </span>            : //+ENDPLUMEDOC</a>
<a name="297"><span class="lineNum">     297 </span>            : </a>
<a name="298"><span class="lineNum">     298 </span>            : struct exploration { static const bool explore=true; };</a>
<a name="299"><span class="lineNum">     299 </span>            : typedef OPESmetad&lt;exploration&gt; OPESmetad_e;</a>
<a name="300"><span class="lineNum">     300 </span><span class="lineCov">      12623 : PLUMED_REGISTER_ACTION(OPESmetad_e,&quot;OPES_METAD_EXPLORE&quot;)</span></a>
<a name="301"><span class="lineNum">     301 </span>            : </a>
<a name="302"><span class="lineNum">     302 </span>            : template &lt;class mode&gt;</a>
<a name="303"><span class="lineNum">     303 </span><span class="lineCov">         25 : void OPESmetad&lt;mode&gt;::registerKeywords(Keywords&amp; keys)</span></a>
<a name="304"><span class="lineNum">     304 </span>            : {</a>
<a name="305"><span class="lineNum">     305 </span><span class="lineCov">         25 :   Bias::registerKeywords(keys);</span></a>
<a name="306"><span class="lineNum">     306 </span><span class="lineCov">         25 :   keys.use(&quot;ARG&quot;);</span></a>
<a name="307"><span class="lineNum">     307 </span><span class="lineCov">         50 :   keys.add(&quot;compulsory&quot;,&quot;TEMP&quot;,&quot;-1&quot;,&quot;temperature. If not set, it is taken from MD engine, but not all MD codes provide it&quot;);</span></a>
<a name="308"><span class="lineNum">     308 </span><span class="lineCov">         50 :   keys.add(&quot;compulsory&quot;,&quot;PACE&quot;,&quot;the frequency for kernel deposition&quot;);</span></a>
<a name="309"><span class="lineNum">     309 </span><span class="lineCov">         25 :   std::string info_sigma(&quot;the initial widths of the kernels&quot;);</span></a>
<a name="310"><span class="lineNum">     310 </span>            :   if(mode::explore)</a>
<a name="311"><span class="lineNum">     311 </span>            :     info_sigma+=&quot;, divided by the square root of gamma&quot;;</a>
<a name="312"><span class="lineNum">     312 </span>            :   info_sigma+=&quot;. If not set, an adaptive sigma will be used with the given ADAPTIVE_SIGMA_STRIDE&quot;;</a>
<a name="313"><span class="lineNum">     313 </span><span class="lineCov">         50 :   keys.add(&quot;compulsory&quot;,&quot;SIGMA&quot;,&quot;ADAPTIVE&quot;,info_sigma);</span></a>
<a name="314"><span class="lineNum">     314 </span><span class="lineCov">         50 :   keys.add(&quot;compulsory&quot;,&quot;BARRIER&quot;,&quot;the free energy barrier to be overcome. It is used to set BIASFACTOR, EPSILON, and KERNEL_CUTOFF to reasonable values&quot;);</span></a>
<a name="315"><span class="lineNum">     315 </span><span class="lineCov">         50 :   keys.add(&quot;compulsory&quot;,&quot;COMPRESSION_THRESHOLD&quot;,&quot;1&quot;,&quot;merge kernels if closer than this threshold, in units of sigma&quot;);</span></a>
<a name="316"><span class="lineNum">     316 </span>            : //extra options</a>
<a name="317"><span class="lineNum">     317 </span><span class="lineCov">         50 :   keys.add(&quot;optional&quot;,&quot;ADAPTIVE_SIGMA_STRIDE&quot;,&quot;number of steps for measuring adaptive sigma. Default is 10xPACE&quot;);</span></a>
<a name="318"><span class="lineNum">     318 </span><span class="lineCov">         50 :   keys.add(&quot;optional&quot;,&quot;SIGMA_MIN&quot;,&quot;never reduce SIGMA below this value&quot;);</span></a>
<a name="319"><span class="lineNum">     319 </span><span class="lineCov">         25 :   std::string info_biasfactor(&quot;the gamma bias factor used for the well-tempered target distribution. &quot;);</span></a>
<a name="320"><span class="lineNum">     320 </span>            :   if(mode::explore)</a>
<a name="321"><span class="lineNum">     321 </span>            :     info_biasfactor+=&quot;Cannot be 'inf'&quot;;</a>
<a name="322"><span class="lineNum">     322 </span>            :   else</a>
<a name="323"><span class="lineNum">     323 </span>            :     info_biasfactor+=&quot;Set to 'inf' for uniform flat target&quot;;</a>
<a name="324"><span class="lineNum">     324 </span><span class="lineCov">         50 :   keys.add(&quot;optional&quot;,&quot;BIASFACTOR&quot;,info_biasfactor);</span></a>
<a name="325"><span class="lineNum">     325 </span><span class="lineCov">         50 :   keys.add(&quot;optional&quot;,&quot;EPSILON&quot;,&quot;the value of the regularization constant for the probability&quot;);</span></a>
<a name="326"><span class="lineNum">     326 </span><span class="lineCov">         50 :   keys.add(&quot;optional&quot;,&quot;KERNEL_CUTOFF&quot;,&quot;truncate kernels at this distance, in units of sigma&quot;);</span></a>
<a name="327"><span class="lineNum">     327 </span><span class="lineCov">         50 :   keys.add(&quot;optional&quot;,&quot;NLIST_PARAMETERS&quot;,&quot;( default=3.0,0.5 ) the two cutoff parameters for the kernels neighbor list&quot;);</span></a>
<a name="328"><span class="lineNum">     328 </span><span class="lineCov">         50 :   keys.addFlag(&quot;NLIST&quot;,false,&quot;use neighbor list for kernels summation, faster but experimental&quot;);</span></a>
<a name="329"><span class="lineNum">     329 </span><span class="lineCov">         50 :   keys.addFlag(&quot;NLIST_PACE_RESET&quot;,false,&quot;force the reset of the neighbor list at each PACE. Can be useful with WALKERS_MPI&quot;);</span></a>
<a name="330"><span class="lineNum">     330 </span><span class="lineCov">         50 :   keys.addFlag(&quot;FIXED_SIGMA&quot;,false,&quot;do not decrease sigma as the simulation proceeds. Can be added in a RESTART, to keep in check the number of compressed kernels&quot;);</span></a>
<a name="331"><span class="lineNum">     331 </span><span class="lineCov">         50 :   keys.addFlag(&quot;RECURSIVE_MERGE_OFF&quot;,false,&quot;do not recursively attempt kernel merging when a new one is added&quot;);</span></a>
<a name="332"><span class="lineNum">     332 </span><span class="lineCov">         50 :   keys.addFlag(&quot;NO_ZED&quot;,false,&quot;do not normalize over the explored CV space, Z_n=1&quot;);</span></a>
<a name="333"><span class="lineNum">     333 </span>            : //kernels and state files</a>
<a name="334"><span class="lineNum">     334 </span><span class="lineCov">         50 :   keys.add(&quot;compulsory&quot;,&quot;FILE&quot;,&quot;KERNELS&quot;,&quot;a file in which the list of all deposited kernels is stored&quot;);</span></a>
<a name="335"><span class="lineNum">     335 </span><span class="lineCov">         50 :   keys.add(&quot;optional&quot;,&quot;FMT&quot;,&quot;specify format for KERNELS file&quot;);</span></a>
<a name="336"><span class="lineNum">     336 </span><span class="lineCov">         50 :   keys.add(&quot;optional&quot;,&quot;STATE_RFILE&quot;,&quot;read from this file the compressed kernels and all the info needed to RESTART the simulation&quot;);</span></a>
<a name="337"><span class="lineNum">     337 </span><span class="lineCov">         50 :   keys.add(&quot;optional&quot;,&quot;STATE_WFILE&quot;,&quot;write to this file the compressed kernels and all the info needed to RESTART the simulation&quot;);</span></a>
<a name="338"><span class="lineNum">     338 </span><span class="lineCov">         50 :   keys.add(&quot;optional&quot;,&quot;STATE_WSTRIDE&quot;,&quot;number of MD steps between writing the STATE_WFILE. Default is only on CPT events (but not all MD codes set them)&quot;);</span></a>
<a name="339"><span class="lineNum">     339 </span><span class="lineCov">         50 :   keys.addFlag(&quot;STORE_STATES&quot;,false,&quot;append to STATE_WFILE instead of ovewriting it each time&quot;);</span></a>
<a name="340"><span class="lineNum">     340 </span>            : //miscellaneous</a>
<a name="341"><span class="lineNum">     341 </span><span class="lineCov">         50 :   keys.add(&quot;optional&quot;,&quot;EXCLUDED_REGION&quot;,&quot;kernels are not deposited when the action provided here has a nonzero value, see example above&quot;);</span></a>
<a name="342"><span class="lineNum">     342 </span>            :   if(!mode::explore)</a>
<a name="343"><span class="lineNum">     343 </span><span class="lineCov">         32 :     keys.add(&quot;optional&quot;,&quot;EXTRA_BIAS&quot;,&quot;consider also these other bias potentials for the internal reweighting. This can be used e.g. for sampling a custom target distribution (see example above)&quot;);</span></a>
<a name="344"><span class="lineNum">     344 </span><span class="lineCov">         50 :   keys.addFlag(&quot;CALC_WORK&quot;,false,&quot;calculate the total accumulated work done by the bias since last restart&quot;);</span></a>
<a name="345"><span class="lineNum">     345 </span><span class="lineCov">         50 :   keys.addFlag(&quot;WALKERS_MPI&quot;,false,&quot;switch on MPI version of multiple walkers&quot;);</span></a>
<a name="346"><span class="lineNum">     346 </span><span class="lineCov">         50 :   keys.addFlag(&quot;SERIAL&quot;,false,&quot;perform calculations in serial&quot;);</span></a>
<a name="347"><span class="lineNum">     347 </span><span class="lineCov">         25 :   keys.use(&quot;RESTART&quot;);</span></a>
<a name="348"><span class="lineNum">     348 </span><span class="lineCov">         25 :   keys.use(&quot;UPDATE_FROM&quot;);</span></a>
<a name="349"><span class="lineNum">     349 </span><span class="lineCov">         25 :   keys.use(&quot;UPDATE_UNTIL&quot;);</span></a>
<a name="350"><span class="lineNum">     350 </span>            : </a>
<a name="351"><span class="lineNum">     351 </span>            : //output components</a>
<a name="352"><span class="lineNum">     352 </span><span class="lineCov">         50 :   keys.addOutputComponent(&quot;rct&quot;,&quot;default&quot;,&quot;estimate of c(t). \\f$\\frac{1}{\\beta}\\log \\langle e^{\\beta V} \\rangle\\f$, should become flat as the simulation converges. Do NOT use for reweighting&quot;);</span></a>
<a name="353"><span class="lineNum">     353 </span><span class="lineCov">         50 :   keys.addOutputComponent(&quot;zed&quot;,&quot;default&quot;,&quot;estimate of Z_n. should become flat once no new CV-space region is explored&quot;);</span></a>
<a name="354"><span class="lineNum">     354 </span><span class="lineCov">         50 :   keys.addOutputComponent(&quot;neff&quot;,&quot;default&quot;,&quot;effective sample size&quot;);</span></a>
<a name="355"><span class="lineNum">     355 </span><span class="lineCov">         50 :   keys.addOutputComponent(&quot;nker&quot;,&quot;default&quot;,&quot;total number of compressed kernels used to represent the bias&quot;);</span></a>
<a name="356"><span class="lineNum">     356 </span><span class="lineCov">         50 :   keys.addOutputComponent(&quot;work&quot;,&quot;CALC_WORK&quot;,&quot;total accumulated work done by the bias&quot;);</span></a>
<a name="357"><span class="lineNum">     357 </span><span class="lineCov">         50 :   keys.addOutputComponent(&quot;nlker&quot;,&quot;NLIST&quot;,&quot;number of kernels in the neighbor list&quot;);</span></a>
<a name="358"><span class="lineNum">     358 </span><span class="lineCov">         50 :   keys.addOutputComponent(&quot;nlsteps&quot;,&quot;NLIST&quot;,&quot;number of steps from last neighbor list update&quot;);</span></a>
<a name="359"><span class="lineNum">     359 </span><span class="lineCov">         25 : }</span></a>
<a name="360"><span class="lineNum">     360 </span>            : </a>
<a name="361"><span class="lineNum">     361 </span>            : template &lt;class mode&gt;</a>
<a name="362"><span class="lineNum">     362 </span><span class="lineCov">         21 : OPESmetad&lt;mode&gt;::OPESmetad(const ActionOptions&amp; ao)</span></a>
<a name="363"><span class="lineNum">     363 </span>            :   : PLUMED_BIAS_INIT(ao)</a>
<a name="364"><span class="lineNum">     364 </span><span class="lineCov">         21 :   , isFirstStep_(true)</span></a>
<a name="365"><span class="lineNum">     365 </span><span class="lineCov">         21 :   , counter_(1)</span></a>
<a name="366"><span class="lineNum">     366 </span><span class="lineCov">         21 :   , ncv_(getNumberOfArguments())</span></a>
<a name="367"><span class="lineNum">     367 </span><span class="lineCov">         21 :   , Zed_(1)</span></a>
<a name="368"><span class="lineNum">     368 </span><span class="lineCov">         21 :   , work_(0)</span></a>
<a name="369"><span class="lineNum">     369 </span><span class="lineCov">         21 :   , excluded_region_(NULL)</span></a>
<a name="370"><span class="lineNum">     370 </span>            : {</a>
<a name="371"><span class="lineNum">     371 </span><span class="lineCov">         42 :   std::string error_in_input1(&quot;Error in input in action &quot;+getName()+&quot; with label &quot;+getLabel()+&quot;: the keyword &quot;);</span></a>
<a name="372"><span class="lineNum">     372 </span><span class="lineCov">         21 :   std::string error_in_input2(&quot; could not be read correctly&quot;);</span></a>
<a name="373"><span class="lineNum">     373 </span>            : </a>
<a name="374"><span class="lineNum">     374 </span>            : //set kbt_</a>
<a name="375"><span class="lineNum">     375 </span><span class="lineCov">         21 :   const double kB=plumed.getAtoms().getKBoltzmann();</span></a>
<a name="376"><span class="lineNum">     376 </span><span class="lineCov">         21 :   kbt_=plumed.getAtoms().getKbT();</span></a>
<a name="377"><span class="lineNum">     377 </span><span class="lineCov">         21 :   double temp=-1;</span></a>
<a name="378"><span class="lineNum">     378 </span><span class="lineCov">         21 :   parse(&quot;TEMP&quot;,temp);</span></a>
<a name="379"><span class="lineNum">     379 </span><span class="lineCov">         21 :   if(temp&gt;0)</span></a>
<a name="380"><span class="lineNum">     380 </span>            :   {</a>
<a name="381"><span class="lineNum">     381 </span><span class="lineCov">         21 :     if(kbt_&gt;0 &amp;&amp; std::abs(kbt_-kB*temp)&gt;1e-4)</span></a>
<a name="382"><span class="lineNum">     382 </span><span class="lineNoCov">          0 :       log.printf(&quot; +++ WARNING +++ using TEMP=%g while MD engine uses %g\n&quot;,temp,kbt_/kB);</span></a>
<a name="383"><span class="lineNum">     383 </span><span class="lineCov">         21 :     kbt_=kB*temp;</span></a>
<a name="384"><span class="lineNum">     384 </span>            :   }</a>
<a name="385"><span class="lineNum">     385 </span><span class="lineCov">         21 :   plumed_massert(kbt_&gt;0,&quot;your MD engine does not pass the temperature to plumed, you must specify it using TEMP&quot;);</span></a>
<a name="386"><span class="lineNum">     386 </span>            : </a>
<a name="387"><span class="lineNum">     387 </span>            : //other compulsory input</a>
<a name="388"><span class="lineNum">     388 </span><span class="lineCov">         21 :   parse(&quot;PACE&quot;,stride_);</span></a>
<a name="389"><span class="lineNum">     389 </span>            : </a>
<a name="390"><span class="lineNum">     390 </span><span class="lineCov">         21 :   double barrier=0;</span></a>
<a name="391"><span class="lineNum">     391 </span><span class="lineCov">         21 :   parse(&quot;BARRIER&quot;,barrier);</span></a>
<a name="392"><span class="lineNum">     392 </span><span class="lineCov">         21 :   plumed_massert(barrier&gt;=0,&quot;the BARRIER should be greater than zero&quot;);</span></a>
<a name="393"><span class="lineNum">     393 </span>            : </a>
<a name="394"><span class="lineNum">     394 </span><span class="lineCov">         21 :   biasfactor_=barrier/kbt_;</span></a>
<a name="395"><span class="lineNum">     395 </span>            :   std::string biasfactor_str;</a>
<a name="396"><span class="lineNum">     396 </span><span class="lineCov">         42 :   parse(&quot;BIASFACTOR&quot;,biasfactor_str);</span></a>
<a name="397"><span class="lineNum">     397 </span><span class="lineCov">         38 :   if(biasfactor_str==&quot;inf&quot; || biasfactor_str==&quot;INF&quot;)</span></a>
<a name="398"><span class="lineNum">     398 </span>            :   {</a>
<a name="399"><span class="lineNum">     399 </span><span class="lineCov">          4 :     biasfactor_=std::numeric_limits&lt;double&gt;::infinity();</span></a>
<a name="400"><span class="lineNum">     400 </span><span class="lineCov">          4 :     bias_prefactor_=1;</span></a>
<a name="401"><span class="lineNum">     401 </span>            :   }</a>
<a name="402"><span class="lineNum">     402 </span>            :   else</a>
<a name="403"><span class="lineNum">     403 </span>            :   {</a>
<a name="404"><span class="lineNum">     404 </span><span class="lineCov">         17 :     if(biasfactor_str.length()&gt;0)</span></a>
<a name="405"><span class="lineNum">     405 </span><span class="lineCov">          3 :       plumed_massert(Tools::convertNoexcept(biasfactor_str,biasfactor_),error_in_input1+&quot;BIASFACTOR&quot;+error_in_input2);</span></a>
<a name="406"><span class="lineNum">     406 </span><span class="lineCov">         17 :     plumed_massert(biasfactor_&gt;1,&quot;BIASFACTOR must be greater than one (use 'inf' for uniform target)&quot;);</span></a>
<a name="407"><span class="lineNum">     407 </span><span class="lineCov">         17 :     bias_prefactor_=1-1./biasfactor_;</span></a>
<a name="408"><span class="lineNum">     408 </span>            :   }</a>
<a name="409"><span class="lineNum">     409 </span>            :   if(mode::explore)</a>
<a name="410"><span class="lineNum">     410 </span>            :   {</a>
<a name="411"><span class="lineNum">     411 </span><span class="lineCov">          7 :     plumed_massert(!std::isinf(biasfactor_),&quot;BIASFACTOR=inf is not compatible with EXPLORE mode&quot;);</span></a>
<a name="412"><span class="lineNum">     412 </span><span class="lineCov">          7 :     bias_prefactor_=biasfactor_-1;</span></a>
<a name="413"><span class="lineNum">     413 </span>            :   }</a>
<a name="414"><span class="lineNum">     414 </span>            : </a>
<a name="415"><span class="lineNum">     415 </span><span class="lineCov">         21 :   adaptive_sigma_=false;</span></a>
<a name="416"><span class="lineNum">     416 </span><span class="lineCov">         21 :   adaptive_sigma_stride_=0;</span></a>
<a name="417"><span class="lineNum">     417 </span><span class="lineCov">         42 :   parse(&quot;ADAPTIVE_SIGMA_STRIDE&quot;,adaptive_sigma_stride_);</span></a>
<a name="418"><span class="lineNum">     418 </span>            :   std::vector&lt;std::string&gt; sigma_str;</a>
<a name="419"><span class="lineNum">     419 </span><span class="lineCov">         21 :   parseVector(&quot;SIGMA&quot;,sigma_str);</span></a>
<a name="420"><span class="lineNum">     420 </span><span class="lineCov">         21 :   sigma0_.resize(ncv_);</span></a>
<a name="421"><span class="lineNum">     421 </span>            :   double dummy;</a>
<a name="422"><span class="lineNum">     422 </span><span class="lineCov">         21 :   if(sigma_str.size()==1 &amp;&amp; !Tools::convertNoexcept(sigma_str[0],dummy))</span></a>
<a name="423"><span class="lineNum">     423 </span>            :   {</a>
<a name="424"><span class="lineNum">     424 </span><span class="lineCov">         11 :     plumed_massert(sigma_str[0]==&quot;ADAPTIVE&quot; || sigma_str[0]==&quot;adaptive&quot;,error_in_input1+&quot;SIGMA&quot;+error_in_input2);</span></a>
<a name="425"><span class="lineNum">     425 </span><span class="lineCov">         11 :     plumed_massert(!std::isinf(biasfactor_),&quot;cannot use BIASFACTOR=inf with adaptive SIGMA&quot;);</span></a>
<a name="426"><span class="lineNum">     426 </span><span class="lineCov">         11 :     adaptive_counter_=0;</span></a>
<a name="427"><span class="lineNum">     427 </span><span class="lineCov">         11 :     if(adaptive_sigma_stride_==0)</span></a>
<a name="428"><span class="lineNum">     428 </span><span class="lineCov">          2 :       adaptive_sigma_stride_=10*stride_; //NB: this is arbitrary, chosen from few tests</span></a>
<a name="429"><span class="lineNum">     429 </span><span class="lineCov">         11 :     av_cv_.resize(ncv_,0);</span></a>
<a name="430"><span class="lineNum">     430 </span><span class="lineCov">         11 :     av_M2_.resize(ncv_,0);</span></a>
<a name="431"><span class="lineNum">     431 </span><span class="lineCov">         11 :     plumed_massert(adaptive_sigma_stride_&gt;=stride_,&quot;better to chose ADAPTIVE_SIGMA_STRIDE &gt; PACE&quot;);</span></a>
<a name="432"><span class="lineNum">     432 </span><span class="lineCov">         11 :     adaptive_sigma_=true;</span></a>
<a name="433"><span class="lineNum">     433 </span>            :   }</a>
<a name="434"><span class="lineNum">     434 </span>            :   else</a>
<a name="435"><span class="lineNum">     435 </span>            :   {</a>
<a name="436"><span class="lineNum">     436 </span><span class="lineCov">         10 :     plumed_massert(sigma_str.size()==ncv_,&quot;number of SIGMA parameters does not match number of arguments&quot;);</span></a>
<a name="437"><span class="lineNum">     437 </span><span class="lineCov">         10 :     plumed_massert(adaptive_sigma_stride_==0,&quot;if SIGMA is not ADAPTIVE you cannot set an ADAPTIVE_SIGMA_STRIDE&quot;);</span></a>
<a name="438"><span class="lineNum">     438 </span><span class="lineCov">         29 :     for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="439"><span class="lineNum">     439 </span>            :     {</a>
<a name="440"><span class="lineNum">     440 </span><span class="lineCov">         19 :       plumed_massert(Tools::convertNoexcept(sigma_str[i],sigma0_[i]),error_in_input1+&quot;SIGMA&quot;+error_in_input2);</span></a>
<a name="441"><span class="lineNum">     441 </span>            :       if(mode::explore)</a>
<a name="442"><span class="lineNum">     442 </span><span class="lineCov">          6 :         sigma0_[i]*=std::sqrt(biasfactor_); //the sigma of the target is broader Ftg(s)=1/gamma*F(s)</span></a>
<a name="443"><span class="lineNum">     443 </span>            :     }</a>
<a name="444"><span class="lineNum">     444 </span>            :   }</a>
<a name="445"><span class="lineNum">     445 </span><span class="lineCov">         42 :   parseVector(&quot;SIGMA_MIN&quot;,sigma_min_);</span></a>
<a name="446"><span class="lineNum">     446 </span><span class="lineCov">         21 :   plumed_massert(sigma_min_.size()==0 || sigma_min_.size()==ncv_,&quot;number of SIGMA_MIN does not match number of arguments&quot;);</span></a>
<a name="447"><span class="lineNum">     447 </span><span class="lineCov">         21 :   if(sigma_min_.size()&gt;0 &amp;&amp; !adaptive_sigma_)</span></a>
<a name="448"><span class="lineNum">     448 </span>            :   {</a>
<a name="449"><span class="lineNum">     449 </span><span class="lineCov">          3 :     for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="450"><span class="lineNum">     450 </span><span class="lineCov">          2 :       plumed_massert(sigma_min_[i]&lt;=sigma0_[i],&quot;SIGMA_MIN should be smaller than SIGMA&quot;);</span></a>
<a name="451"><span class="lineNum">     451 </span>            :   }</a>
<a name="452"><span class="lineNum">     452 </span>            : </a>
<a name="453"><span class="lineNum">     453 </span><span class="lineCov">         21 :   epsilon_=std::exp(-barrier/bias_prefactor_/kbt_);</span></a>
<a name="454"><span class="lineNum">     454 </span><span class="lineCov">         21 :   parse(&quot;EPSILON&quot;,epsilon_);</span></a>
<a name="455"><span class="lineNum">     455 </span><span class="lineCov">         21 :   plumed_massert(epsilon_&gt;0,&quot;you must choose a value for EPSILON greater than zero. Is your BARRIER too high?&quot;);</span></a>
<a name="456"><span class="lineNum">     456 </span><span class="lineCov">         21 :   sum_weights_=std::pow(epsilon_,bias_prefactor_); //to avoid NANs we start with counter_=1 and w0=exp(beta*V0)</span></a>
<a name="457"><span class="lineNum">     457 </span><span class="lineCov">         21 :   sum_weights2_=sum_weights_*sum_weights_;</span></a>
<a name="458"><span class="lineNum">     458 </span>            : </a>
<a name="459"><span class="lineNum">     459 </span><span class="lineCov">         21 :   double cutoff=sqrt(2.*barrier/bias_prefactor_/kbt_);</span></a>
<a name="460"><span class="lineNum">     460 </span>            :   if(mode::explore)</a>
<a name="461"><span class="lineNum">     461 </span><span class="lineCov">          7 :     cutoff=sqrt(2.*barrier/kbt_); //otherwise it is too small</span></a>
<a name="462"><span class="lineNum">     462 </span><span class="lineCov">         21 :   parse(&quot;KERNEL_CUTOFF&quot;,cutoff);</span></a>
<a name="463"><span class="lineNum">     463 </span><span class="lineCov">         21 :   plumed_massert(cutoff&gt;0,&quot;you must choose a value for KERNEL_CUTOFF greater than zero&quot;);</span></a>
<a name="464"><span class="lineNum">     464 </span><span class="lineCov">         21 :   cutoff2_=cutoff*cutoff;</span></a>
<a name="465"><span class="lineNum">     465 </span><span class="lineCov">         21 :   val_at_cutoff_=std::exp(-0.5*cutoff2_);</span></a>
<a name="466"><span class="lineNum">     466 </span>            : </a>
<a name="467"><span class="lineNum">     467 </span><span class="lineCov">         21 :   threshold2_=1;</span></a>
<a name="468"><span class="lineNum">     468 </span><span class="lineCov">         21 :   parse(&quot;COMPRESSION_THRESHOLD&quot;,threshold2_);</span></a>
<a name="469"><span class="lineNum">     469 </span><span class="lineCov">         21 :   threshold2_*=threshold2_;</span></a>
<a name="470"><span class="lineNum">     470 </span><span class="lineCov">         21 :   if(threshold2_!=0)</span></a>
<a name="471"><span class="lineNum">     471 </span><span class="lineCov">         21 :     plumed_massert(threshold2_&gt;0 &amp;&amp; threshold2_&lt;cutoff2_,&quot;COMPRESSION_THRESHOLD cannot be bigger than the KERNEL_CUTOFF&quot;);</span></a>
<a name="472"><span class="lineNum">     472 </span>            : </a>
<a name="473"><span class="lineNum">     473 </span>            : //setup neighbor list</a>
<a name="474"><span class="lineNum">     474 </span><span class="lineCov">         21 :   nlist_=false;</span></a>
<a name="475"><span class="lineNum">     475 </span><span class="lineCov">         21 :   parseFlag(&quot;NLIST&quot;,nlist_);</span></a>
<a name="476"><span class="lineNum">     476 </span><span class="lineCov">         21 :   nlist_pace_reset_=false;</span></a>
<a name="477"><span class="lineNum">     477 </span><span class="lineCov">         21 :   parseFlag(&quot;NLIST_PACE_RESET&quot;,nlist_pace_reset_);</span></a>
<a name="478"><span class="lineNum">     478 </span><span class="lineCov">         21 :   if(nlist_pace_reset_)</span></a>
<a name="479"><span class="lineNum">     479 </span><span class="lineCov">          2 :     nlist_=true;</span></a>
<a name="480"><span class="lineNum">     480 </span>            :   std::vector&lt;double&gt; nlist_param;</a>
<a name="481"><span class="lineNum">     481 </span><span class="lineCov">         42 :   parseVector(&quot;NLIST_PARAMETERS&quot;,nlist_param);</span></a>
<a name="482"><span class="lineNum">     482 </span><span class="lineCov">         21 :   if(nlist_param.size()==0)</span></a>
<a name="483"><span class="lineNum">     483 </span>            :   {</a>
<a name="484"><span class="lineNum">     484 </span><span class="lineCov">         17 :     nlist_param_[0]=3.0;//*cutoff2_ -&gt; max distance of neighbors</span></a>
<a name="485"><span class="lineNum">     485 </span><span class="lineCov">         17 :     nlist_param_[1]=0.5;//*nlist_dev2_[i] -&gt; condition for rebuilding</span></a>
<a name="486"><span class="lineNum">     486 </span>            :   }</a>
<a name="487"><span class="lineNum">     487 </span>            :   else</a>
<a name="488"><span class="lineNum">     488 </span>            :   {</a>
<a name="489"><span class="lineNum">     489 </span><span class="lineCov">          4 :     nlist_=true;</span></a>
<a name="490"><span class="lineNum">     490 </span><span class="lineCov">          4 :     plumed_massert(nlist_param.size()==2,&quot;two cutoff parameters are needed for the neighbor list&quot;);</span></a>
<a name="491"><span class="lineNum">     491 </span><span class="lineCov">          4 :     plumed_massert(nlist_param[0]&gt;1.0,&quot;the first of NLIST_PARAMETERS must be greater than 1. The smaller the first, the smaller should be the second as well&quot;);</span></a>
<a name="492"><span class="lineNum">     492 </span><span class="lineCov">          4 :     const double min_PARAM_1=(1.-1./std::sqrt(nlist_param[0]))+0.16;</span></a>
<a name="493"><span class="lineNum">     493 </span><span class="lineCov">          4 :     plumed_massert(nlist_param[1]&gt;0,&quot;the second of NLIST_PARAMETERS must be greater than 0&quot;);</span></a>
<a name="494"><span class="lineNum">     494 </span><span class="lineCov">          4 :     plumed_massert(nlist_param[1]&lt;=min_PARAM_1,&quot;the second of NLIST_PARAMETERS must be smaller to avoid systematic errors. Largest suggested value is: 1.16-1/sqrt(PARAM_0) = &quot;+std::to_string(min_PARAM_1));</span></a>
<a name="495"><span class="lineNum">     495 </span><span class="lineCov">          4 :     nlist_param_[0]=nlist_param[0];</span></a>
<a name="496"><span class="lineNum">     496 </span><span class="lineCov">          4 :     nlist_param_[1]=nlist_param[1];</span></a>
<a name="497"><span class="lineNum">     497 </span>            :   }</a>
<a name="498"><span class="lineNum">     498 </span><span class="lineCov">         21 :   nlist_center_.resize(ncv_);</span></a>
<a name="499"><span class="lineNum">     499 </span><span class="lineCov">         21 :   nlist_dev2_.resize(ncv_,0.);</span></a>
<a name="500"><span class="lineNum">     500 </span><span class="lineCov">         21 :   nlist_steps_=0;</span></a>
<a name="501"><span class="lineNum">     501 </span><span class="lineCov">         21 :   nlist_update_=true;</span></a>
<a name="502"><span class="lineNum">     502 </span>            : </a>
<a name="503"><span class="lineNum">     503 </span>            : //optional stuff</a>
<a name="504"><span class="lineNum">     504 </span><span class="lineCov">         21 :   no_Zed_=false;</span></a>
<a name="505"><span class="lineNum">     505 </span><span class="lineCov">         21 :   parseFlag(&quot;NO_ZED&quot;,no_Zed_);</span></a>
<a name="506"><span class="lineNum">     506 </span><span class="lineCov">         21 :   if(no_Zed_)</span></a>
<a name="507"><span class="lineNum">     507 </span>            :   { //this makes it more gentle in the initial phase</a>
<a name="508"><span class="lineNum">     508 </span><span class="lineCov">          6 :     sum_weights_=1;</span></a>
<a name="509"><span class="lineNum">     509 </span><span class="lineCov">          6 :     sum_weights2_=1;</span></a>
<a name="510"><span class="lineNum">     510 </span>            :   }</a>
<a name="511"><span class="lineNum">     511 </span><span class="lineCov">         21 :   fixed_sigma_=false;</span></a>
<a name="512"><span class="lineNum">     512 </span><span class="lineCov">         21 :   parseFlag(&quot;FIXED_SIGMA&quot;,fixed_sigma_);</span></a>
<a name="513"><span class="lineNum">     513 </span><span class="lineCov">         21 :   bool recursive_merge_off=false;</span></a>
<a name="514"><span class="lineNum">     514 </span><span class="lineCov">         21 :   parseFlag(&quot;RECURSIVE_MERGE_OFF&quot;,recursive_merge_off);</span></a>
<a name="515"><span class="lineNum">     515 </span><span class="lineCov">         21 :   recursive_merge_=!recursive_merge_off;</span></a>
<a name="516"><span class="lineNum">     516 </span><span class="lineCov">         42 :   parseFlag(&quot;CALC_WORK&quot;,calc_work_);</span></a>
<a name="517"><span class="lineNum">     517 </span>            : </a>
<a name="518"><span class="lineNum">     518 </span>            : //options involving extra arguments</a>
<a name="519"><span class="lineNum">     519 </span>            :   std::vector&lt;Value*&gt; args;</a>
<a name="520"><span class="lineNum">     520 </span><span class="lineCov">         42 :   parseArgumentList(&quot;EXCLUDED_REGION&quot;,args);</span></a>
<a name="521"><span class="lineNum">     521 </span><span class="lineCov">         21 :   if(args.size()&gt;0)</span></a>
<a name="522"><span class="lineNum">     522 </span>            :   {</a>
<a name="523"><span class="lineNum">     523 </span><span class="lineCov">          2 :     plumed_massert(args.size()==1,&quot;only one characteristic function should define the region to be excluded&quot;);</span></a>
<a name="524"><span class="lineNum">     524 </span><span class="lineCov">          2 :     requestExtraDependencies(args);</span></a>
<a name="525"><span class="lineNum">     525 </span><span class="lineCov">          2 :     excluded_region_=args[0];</span></a>
<a name="526"><span class="lineNum">     526 </span>            :   }</a>
<a name="527"><span class="lineNum">     527 </span>            :   if(!mode::explore)</a>
<a name="528"><span class="lineNum">     528 </span>            :   {</a>
<a name="529"><span class="lineNum">     529 </span><span class="lineCov">         28 :     parseArgumentList(&quot;EXTRA_BIAS&quot;,extra_biases_);</span></a>
<a name="530"><span class="lineNum">     530 </span><span class="lineCov">         14 :     if(extra_biases_.size()&gt;0)</span></a>
<a name="531"><span class="lineNum">     531 </span><span class="lineCov">          2 :       requestExtraDependencies(extra_biases_);</span></a>
<a name="532"><span class="lineNum">     532 </span>            :   }</a>
<a name="533"><span class="lineNum">     533 </span>            : </a>
<a name="534"><span class="lineNum">     534 </span>            : //kernels file</a>
<a name="535"><span class="lineNum">     535 </span>            :   std::string kernelsFileName;</a>
<a name="536"><span class="lineNum">     536 </span><span class="lineCov">         42 :   parse(&quot;FILE&quot;,kernelsFileName);</span></a>
<a name="537"><span class="lineNum">     537 </span>            :   std::string fmt;</a>
<a name="538"><span class="lineNum">     538 </span><span class="lineCov">         42 :   parse(&quot;FMT&quot;,fmt);</span></a>
<a name="539"><span class="lineNum">     539 </span>            : </a>
<a name="540"><span class="lineNum">     540 </span>            : //output checkpoint of current state</a>
<a name="541"><span class="lineNum">     541 </span>            :   std::string restartFileName;</a>
<a name="542"><span class="lineNum">     542 </span><span class="lineCov">         42 :   parse(&quot;STATE_RFILE&quot;,restartFileName);</span></a>
<a name="543"><span class="lineNum">     543 </span>            :   std::string stateFileName;</a>
<a name="544"><span class="lineNum">     544 </span><span class="lineCov">         21 :   parse(&quot;STATE_WFILE&quot;,stateFileName);</span></a>
<a name="545"><span class="lineNum">     545 </span><span class="lineCov">         21 :   wStateStride_=0;</span></a>
<a name="546"><span class="lineNum">     546 </span><span class="lineCov">         21 :   parse(&quot;STATE_WSTRIDE&quot;,wStateStride_);</span></a>
<a name="547"><span class="lineNum">     547 </span><span class="lineCov">         21 :   storeOldStates_=false;</span></a>
<a name="548"><span class="lineNum">     548 </span><span class="lineCov">         21 :   parseFlag(&quot;STORE_STATES&quot;,storeOldStates_);</span></a>
<a name="549"><span class="lineNum">     549 </span><span class="lineCov">         21 :   if(wStateStride_!=0 || storeOldStates_)</span></a>
<a name="550"><span class="lineNum">     550 </span><span class="lineCov">         10 :     plumed_massert(stateFileName.length()&gt;0,&quot;filename for storing simulation status not specified, use STATE_WFILE&quot;);</span></a>
<a name="551"><span class="lineNum">     551 </span><span class="lineCov">         21 :   if(wStateStride_&gt;0)</span></a>
<a name="552"><span class="lineNum">     552 </span><span class="lineCov">         10 :     plumed_massert(wStateStride_&gt;=(int)stride_,&quot;STATE_WSTRIDE is in units of MD steps, thus it is suggested to use a multiple of PACE&quot;);</span></a>
<a name="553"><span class="lineNum">     553 </span><span class="lineCov">         21 :   if(stateFileName.length()&gt;0 &amp;&amp; wStateStride_==0)</span></a>
<a name="554"><span class="lineNum">     554 </span><span class="lineCov">          1 :     wStateStride_=-1;//will print only on CPT events (checkpoints set by some MD engines, like gromacs)</span></a>
<a name="555"><span class="lineNum">     555 </span>            : </a>
<a name="556"><span class="lineNum">     556 </span>            : //multiple walkers //TODO implement also external mw for cp2k</a>
<a name="557"><span class="lineNum">     557 </span><span class="lineCov">         21 :   bool walkers_mpi=false;</span></a>
<a name="558"><span class="lineNum">     558 </span><span class="lineCov">         21 :   parseFlag(&quot;WALKERS_MPI&quot;,walkers_mpi);</span></a>
<a name="559"><span class="lineNum">     559 </span><span class="lineCov">         21 :   if(walkers_mpi)</span></a>
<a name="560"><span class="lineNum">     560 </span>            :   {</a>
<a name="561"><span class="lineNum">     561 </span>            :     //If this Action is not compiled with MPI the user is informed and we exit gracefully</a>
<a name="562"><span class="lineNum">     562 </span><span class="lineCov">         10 :     plumed_massert(Communicator::plumedHasMPI(),&quot;Invalid walkers configuration: WALKERS_MPI flag requires MPI compilation&quot;);</span></a>
<a name="563"><span class="lineNum">     563 </span><span class="lineCov">         10 :     plumed_massert(Communicator::initialized(),&quot;Invalid walkers configuration: WALKERS_MPI needs the communicator correctly initialized.&quot;);</span></a>
<a name="564"><span class="lineNum">     564 </span>            : </a>
<a name="565"><span class="lineNum">     565 </span><span class="lineCov">         10 :     if(comm.Get_rank()==0)//multi_sim_comm works on first rank only</span></a>
<a name="566"><span class="lineNum">     566 </span>            :     {</a>
<a name="567"><span class="lineNum">     567 </span><span class="lineCov">         10 :       NumWalkers_=multi_sim_comm.Get_size();</span></a>
<a name="568"><span class="lineNum">     568 </span><span class="lineCov">         10 :       walker_rank_=multi_sim_comm.Get_rank();</span></a>
<a name="569"><span class="lineNum">     569 </span>            :     }</a>
<a name="570"><span class="lineNum">     570 </span><span class="lineCov">         10 :     comm.Bcast(NumWalkers_,0); //if each walker has more than one processor update them all</span></a>
<a name="571"><span class="lineNum">     571 </span><span class="lineCov">         10 :     comm.Bcast(walker_rank_,0);</span></a>
<a name="572"><span class="lineNum">     572 </span>            :   }</a>
<a name="573"><span class="lineNum">     573 </span>            :   else</a>
<a name="574"><span class="lineNum">     574 </span>            :   {</a>
<a name="575"><span class="lineNum">     575 </span><span class="lineCov">         11 :     NumWalkers_=1;</span></a>
<a name="576"><span class="lineNum">     576 </span><span class="lineCov">         11 :     walker_rank_=0;</span></a>
<a name="577"><span class="lineNum">     577 </span>            :   }</a>
<a name="578"><span class="lineNum">     578 </span>            : </a>
<a name="579"><span class="lineNum">     579 </span>            : //parallelization stuff</a>
<a name="580"><span class="lineNum">     580 </span><span class="lineCov">         21 :   NumOMP_=OpenMP::getNumThreads();</span></a>
<a name="581"><span class="lineNum">     581 </span><span class="lineCov">         21 :   NumParallel_=comm.Get_size();</span></a>
<a name="582"><span class="lineNum">     582 </span><span class="lineCov">         21 :   rank_=comm.Get_rank();</span></a>
<a name="583"><span class="lineNum">     583 </span><span class="lineCov">         21 :   bool serial=false;</span></a>
<a name="584"><span class="lineNum">     584 </span><span class="lineCov">         21 :   parseFlag(&quot;SERIAL&quot;,serial);</span></a>
<a name="585"><span class="lineNum">     585 </span><span class="lineCov">         21 :   if(serial)</span></a>
<a name="586"><span class="lineNum">     586 </span>            :   {</a>
<a name="587"><span class="lineNum">     587 </span><span class="lineCov">          4 :     NumOMP_=1;</span></a>
<a name="588"><span class="lineNum">     588 </span><span class="lineCov">          4 :     NumParallel_=1;</span></a>
<a name="589"><span class="lineNum">     589 </span><span class="lineCov">          4 :     rank_=0;</span></a>
<a name="590"><span class="lineNum">     590 </span>            :   }</a>
<a name="591"><span class="lineNum">     591 </span>            : </a>
<a name="592"><span class="lineNum">     592 </span><span class="lineCov">         21 :   checkRead();</span></a>
<a name="593"><span class="lineNum">     593 </span>            : </a>
<a name="594"><span class="lineNum">     594 </span>            : //restart if needed</a>
<a name="595"><span class="lineNum">     595 </span>            :   bool convertKernelsToState=false;</a>
<a name="596"><span class="lineNum">     596 </span><span class="lineCov">         21 :   if(getRestart())</span></a>
<a name="597"><span class="lineNum">     597 </span>            :   {</a>
<a name="598"><span class="lineNum">     598 </span>            :     bool stateRestart=true;</a>
<a name="599"><span class="lineNum">     599 </span><span class="lineCov">         11 :     if(restartFileName.length()==0)</span></a>
<a name="600"><span class="lineNum">     600 </span>            :     {</a>
<a name="601"><span class="lineNum">     601 </span>            :       stateRestart=false;</a>
<a name="602"><span class="lineNum">     602 </span>            :       restartFileName=kernelsFileName;</a>
<a name="603"><span class="lineNum">     603 </span>            :     }</a>
<a name="604"><span class="lineNum">     604 </span><span class="lineCov">         11 :     IFile ifile;</span></a>
<a name="605"><span class="lineNum">     605 </span><span class="lineCov">         11 :     ifile.link(*this);</span></a>
<a name="606"><span class="lineNum">     606 </span><span class="lineCov">         11 :     if(ifile.FileExist(restartFileName))</span></a>
<a name="607"><span class="lineNum">     607 </span>            :     {</a>
<a name="608"><span class="lineNum">     608 </span><span class="lineCov">         11 :       bool tmp_nlist=nlist_;</span></a>
<a name="609"><span class="lineNum">     609 </span><span class="lineCov">         11 :       nlist_=false; // NLIST is not needed while restarting</span></a>
<a name="610"><span class="lineNum">     610 </span><span class="lineCov">         11 :       ifile.open(restartFileName);</span></a>
<a name="611"><span class="lineNum">     611 </span><span class="lineCov">         11 :       log.printf(&quot;  RESTART - make sure all used options are compatible\n&quot;);</span></a>
<a name="612"><span class="lineNum">     612 </span><span class="lineCov">         11 :       log.printf(&quot;    restarting from: %s\n&quot;,restartFileName.c_str());</span></a>
<a name="613"><span class="lineNum">     613 </span><span class="lineCov">         11 :       std::string action_name=getName();</span></a>
<a name="614"><span class="lineNum">     614 </span><span class="lineCov">         11 :       if(stateRestart)</span></a>
<a name="615"><span class="lineNum">     615 </span>            :       {</a>
<a name="616"><span class="lineNum">     616 </span><span class="lineCov">          6 :         log.printf(&quot;    it should be a STATE file (not a KERNELS file)\n&quot;);</span></a>
<a name="617"><span class="lineNum">     617 </span>            :         action_name+=&quot;_state&quot;;</a>
<a name="618"><span class="lineNum">     618 </span>            :       }</a>
<a name="619"><span class="lineNum">     619 </span>            :       else</a>
<a name="620"><span class="lineNum">     620 </span>            :       {</a>
<a name="621"><span class="lineNum">     621 </span><span class="lineCov">          5 :         log.printf(&quot; +++ WARNING +++ RESTART from KERNELS might be approximate, use STATE_WFILE and STATE_RFILE to restart from the exact state\n&quot;);</span></a>
<a name="622"><span class="lineNum">     622 </span>            :         action_name+=&quot;_kernels&quot;;</a>
<a name="623"><span class="lineNum">     623 </span>            :       }</a>
<a name="624"><span class="lineNum">     624 </span>            :       std::string old_action_name;</a>
<a name="625"><span class="lineNum">     625 </span><span class="lineCov">         11 :       ifile.scanField(&quot;action&quot;,old_action_name);</span></a>
<a name="626"><span class="lineNum">     626 </span><span class="lineCov">         11 :       plumed_massert(action_name==old_action_name,&quot;RESTART - mismatch between old and new action name. Expected '&quot;+action_name+&quot;', but found '&quot;+old_action_name+&quot;'&quot;);</span></a>
<a name="627"><span class="lineNum">     627 </span>            :       std::string old_biasfactor_str;</a>
<a name="628"><span class="lineNum">     628 </span><span class="lineCov">         22 :       ifile.scanField(&quot;biasfactor&quot;,old_biasfactor_str);</span></a>
<a name="629"><span class="lineNum">     629 </span><span class="lineCov">         21 :       if(old_biasfactor_str==&quot;inf&quot; || old_biasfactor_str==&quot;INF&quot;)</span></a>
<a name="630"><span class="lineNum">     630 </span>            :       {</a>
<a name="631"><span class="lineNum">     631 </span><span class="lineCov">          1 :         if(!std::isinf(biasfactor_))</span></a>
<a name="632"><span class="lineNum">     632 </span><span class="lineNoCov">          0 :           log.printf(&quot; +++ WARNING +++ previous bias factor was inf while now it is %g\n&quot;,biasfactor_);</span></a>
<a name="633"><span class="lineNum">     633 </span>            :       }</a>
<a name="634"><span class="lineNum">     634 </span>            :       else</a>
<a name="635"><span class="lineNum">     635 </span>            :       {</a>
<a name="636"><span class="lineNum">     636 </span>            :         double old_biasfactor;</a>
<a name="637"><span class="lineNum">     637 </span><span class="lineCov">         10 :         ifile.scanField(&quot;biasfactor&quot;,old_biasfactor);</span></a>
<a name="638"><span class="lineNum">     638 </span><span class="lineCov">         10 :         if(std::abs(biasfactor_-old_biasfactor)&gt;1e-6*biasfactor_)</span></a>
<a name="639"><span class="lineNum">     639 </span><span class="lineNoCov">          0 :           log.printf(&quot; +++ WARNING +++ previous bias factor was %g while now it is %g. diff = %g\n&quot;,old_biasfactor,biasfactor_,biasfactor_-old_biasfactor);</span></a>
<a name="640"><span class="lineNum">     640 </span>            :       }</a>
<a name="641"><span class="lineNum">     641 </span>            :       double old_epsilon;</a>
<a name="642"><span class="lineNum">     642 </span><span class="lineCov">         11 :       ifile.scanField(&quot;epsilon&quot;,old_epsilon);</span></a>
<a name="643"><span class="lineNum">     643 </span><span class="lineCov">         11 :       if(std::abs(epsilon_-old_epsilon)&gt;1e-6*epsilon_)</span></a>
<a name="644"><span class="lineNum">     644 </span><span class="lineCov">          8 :         log.printf(&quot; +++ WARNING +++ previous epsilon was %g while now it is %g. diff = %g\n&quot;,old_epsilon,epsilon_,epsilon_-old_epsilon);</span></a>
<a name="645"><span class="lineNum">     645 </span>            :       double old_cutoff;</a>
<a name="646"><span class="lineNum">     646 </span><span class="lineCov">         11 :       ifile.scanField(&quot;kernel_cutoff&quot;,old_cutoff);</span></a>
<a name="647"><span class="lineNum">     647 </span><span class="lineCov">         11 :       if(std::abs(cutoff-old_cutoff)&gt;1e-6*cutoff)</span></a>
<a name="648"><span class="lineNum">     648 </span><span class="lineNoCov">          0 :         log.printf(&quot; +++ WARNING +++ previous kernel_cutoff was %g while now it is %g. diff = %g\n&quot;,old_cutoff,cutoff,cutoff-old_cutoff);</span></a>
<a name="649"><span class="lineNum">     649 </span>            :       double old_threshold;</a>
<a name="650"><span class="lineNum">     650 </span><span class="lineCov">         11 :       const double threshold=sqrt(threshold2_);</span></a>
<a name="651"><span class="lineNum">     651 </span><span class="lineCov">         11 :       ifile.scanField(&quot;compression_threshold&quot;,old_threshold);</span></a>
<a name="652"><span class="lineNum">     652 </span><span class="lineCov">         11 :       if(std::abs(threshold-old_threshold)&gt;1e-6*threshold)</span></a>
<a name="653"><span class="lineNum">     653 </span><span class="lineNoCov">          0 :         log.printf(&quot; +++ WARNING +++ previous compression_threshold was %g while now it is %g. diff = %g\n&quot;,old_threshold,threshold,threshold-old_threshold);</span></a>
<a name="654"><span class="lineNum">     654 </span><span class="lineCov">         11 :       if(stateRestart)</span></a>
<a name="655"><span class="lineNum">     655 </span>            :       {</a>
<a name="656"><span class="lineNum">     656 </span><span class="lineCov">          6 :         ifile.scanField(&quot;zed&quot;,Zed_);</span></a>
<a name="657"><span class="lineNum">     657 </span><span class="lineCov">          6 :         ifile.scanField(&quot;sum_weights&quot;,sum_weights_);</span></a>
<a name="658"><span class="lineNum">     658 </span><span class="lineCov">          6 :         ifile.scanField(&quot;sum_weights2&quot;,sum_weights2_);</span></a>
<a name="659"><span class="lineNum">     659 </span><span class="lineCov">          6 :         ifile.scanField(&quot;counter&quot;,counter_);</span></a>
<a name="660"><span class="lineNum">     660 </span><span class="lineCov">          6 :         if(adaptive_sigma_)</span></a>
<a name="661"><span class="lineNum">     661 </span>            :         {</a>
<a name="662"><span class="lineNum">     662 </span><span class="lineCov">          6 :           ifile.scanField(&quot;adaptive_counter&quot;,adaptive_counter_);</span></a>
<a name="663"><span class="lineNum">     663 </span><span class="lineCov">          6 :           if(NumWalkers_==1)</span></a>
<a name="664"><span class="lineNum">     664 </span>            :           {</a>
<a name="665"><span class="lineNum">     665 </span><span class="lineCov">          6 :             for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="666"><span class="lineNum">     666 </span>            :             {</a>
<a name="667"><span class="lineNum">     667 </span><span class="lineCov">          8 :               ifile.scanField(&quot;sigma0_&quot;+getPntrToArgument(i)-&gt;getName(),sigma0_[i]);</span></a>
<a name="668"><span class="lineNum">     668 </span><span class="lineCov">          8 :               ifile.scanField(&quot;av_cv_&quot;+getPntrToArgument(i)-&gt;getName(),av_cv_[i]);</span></a>
<a name="669"><span class="lineNum">     669 </span><span class="lineCov">          8 :               ifile.scanField(&quot;av_M2_&quot;+getPntrToArgument(i)-&gt;getName(),av_M2_[i]);</span></a>
<a name="670"><span class="lineNum">     670 </span>            :             }</a>
<a name="671"><span class="lineNum">     671 </span>            :           }</a>
<a name="672"><span class="lineNum">     672 </span>            :           else</a>
<a name="673"><span class="lineNum">     673 </span>            :           {</a>
<a name="674"><span class="lineNum">     674 </span><span class="lineCov">         12 :             for(unsigned w=0; w&lt;NumWalkers_; w++)</span></a>
<a name="675"><span class="lineNum">     675 </span><span class="lineCov">         24 :               for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="676"><span class="lineNum">     676 </span>            :               {</a>
<a name="677"><span class="lineNum">     677 </span>            :                 double tmp0,tmp1,tmp2;</a>
<a name="678"><span class="lineNum">     678 </span><span class="lineCov">         32 :                 const std::string arg_iw=getPntrToArgument(i)-&gt;getName()+&quot;_&quot;+std::to_string(w);</span></a>
<a name="679"><span class="lineNum">     679 </span><span class="lineCov">         16 :                 ifile.scanField(&quot;sigma0_&quot;+arg_iw,tmp0);</span></a>
<a name="680"><span class="lineNum">     680 </span><span class="lineCov">         16 :                 ifile.scanField(&quot;av_cv_&quot;+arg_iw,tmp1);</span></a>
<a name="681"><span class="lineNum">     681 </span><span class="lineCov">         16 :                 ifile.scanField(&quot;av_M2_&quot;+arg_iw,tmp2);</span></a>
<a name="682"><span class="lineNum">     682 </span><span class="lineCov">         16 :                 if(w==walker_rank_)</span></a>
<a name="683"><span class="lineNum">     683 </span>            :                 {</a>
<a name="684"><span class="lineNum">     684 </span><span class="lineCov">          8 :                   sigma0_[i]=tmp0;</span></a>
<a name="685"><span class="lineNum">     685 </span><span class="lineCov">          8 :                   av_cv_[i]=tmp1;</span></a>
<a name="686"><span class="lineNum">     686 </span><span class="lineCov">          8 :                   av_M2_[i]=tmp2;</span></a>
<a name="687"><span class="lineNum">     687 </span>            :                 }</a>
<a name="688"><span class="lineNum">     688 </span>            :               }</a>
<a name="689"><span class="lineNum">     689 </span>            :           }</a>
<a name="690"><span class="lineNum">     690 </span>            :         }</a>
<a name="691"><span class="lineNum">     691 </span>            :       }</a>
<a name="692"><span class="lineNum">     692 </span><span class="lineCov">         33 :       for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="693"><span class="lineNum">     693 </span>            :       {</a>
<a name="694"><span class="lineNum">     694 </span><span class="lineCov">         22 :         if(getPntrToArgument(i)-&gt;isPeriodic())</span></a>
<a name="695"><span class="lineNum">     695 </span>            :         {</a>
<a name="696"><span class="lineNum">     696 </span>            :           std::string arg_min,arg_max;</a>
<a name="697"><span class="lineNum">     697 </span><span class="lineCov">         22 :           getPntrToArgument(i)-&gt;getDomain(arg_min,arg_max);</span></a>
<a name="698"><span class="lineNum">     698 </span>            :           std::string file_min,file_max;</a>
<a name="699"><span class="lineNum">     699 </span><span class="lineCov">         44 :           ifile.scanField(&quot;min_&quot;+getPntrToArgument(i)-&gt;getName(),file_min);</span></a>
<a name="700"><span class="lineNum">     700 </span><span class="lineCov">         22 :           ifile.scanField(&quot;max_&quot;+getPntrToArgument(i)-&gt;getName(),file_max);</span></a>
<a name="701"><span class="lineNum">     701 </span><span class="lineCov">         22 :           plumed_massert(file_min==arg_min,&quot;RESTART - mismatch between old and new ARG periodicity&quot;);</span></a>
<a name="702"><span class="lineNum">     702 </span><span class="lineCov">         22 :           plumed_massert(file_max==arg_max,&quot;RESTART - mismatch between old and new ARG periodicity&quot;);</span></a>
<a name="703"><span class="lineNum">     703 </span>            :         }</a>
<a name="704"><span class="lineNum">     704 </span>            :       }</a>
<a name="705"><span class="lineNum">     705 </span><span class="lineCov">         11 :       if(stateRestart)</span></a>
<a name="706"><span class="lineNum">     706 </span>            :       {</a>
<a name="707"><span class="lineNum">     707 </span>            :         double time;</a>
<a name="708"><span class="lineNum">     708 </span><span class="lineCov">         60 :         while(ifile.scanField(&quot;time&quot;,time))</span></a>
<a name="709"><span class="lineNum">     709 </span>            :         {</a>
<a name="710"><span class="lineNum">     710 </span><span class="lineCov">         24 :           std::vector&lt;double&gt; center(ncv_);</span></a>
<a name="711"><span class="lineNum">     711 </span><span class="lineCov">         24 :           std::vector&lt;double&gt; sigma(ncv_);</span></a>
<a name="712"><span class="lineNum">     712 </span>            :           double height;</a>
<a name="713"><span class="lineNum">     713 </span><span class="lineCov">         72 :           for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="714"><span class="lineNum">     714 </span><span class="lineCov">         48 :             ifile.scanField(getPntrToArgument(i)-&gt;getName(),center[i]);</span></a>
<a name="715"><span class="lineNum">     715 </span><span class="lineCov">         72 :           for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="716"><span class="lineNum">     716 </span><span class="lineCov">         96 :             ifile.scanField(&quot;sigma_&quot;+getPntrToArgument(i)-&gt;getName(),sigma[i]);</span></a>
<a name="717"><span class="lineNum">     717 </span><span class="lineCov">         24 :           ifile.scanField(&quot;height&quot;,height);</span></a>
<a name="718"><span class="lineNum">     718 </span><span class="lineCov">         24 :           ifile.scanField();</span></a>
<a name="719"><span class="lineNum">     719 </span><span class="lineCov">         24 :           kernels_.emplace_back(height,center,sigma);</span></a>
<a name="720"><span class="lineNum">     720 </span>            :         }</a>
<a name="721"><span class="lineNum">     721 </span><span class="lineCov">          6 :         log.printf(&quot;    a total of %lu kernels where read\n&quot;,kernels_.size());</span></a>
<a name="722"><span class="lineNum">     722 </span>            :       }</a>
<a name="723"><span class="lineNum">     723 </span>            :       else</a>
<a name="724"><span class="lineNum">     724 </span>            :       {</a>
<a name="725"><span class="lineNum">     725 </span><span class="lineCov">          5 :         ifile.allowIgnoredFields(); //this allows for multiple restart, but without checking for consistency between them!</span></a>
<a name="726"><span class="lineNum">     726 </span>            :         double time;</a>
<a name="727"><span class="lineNum">     727 </span><span class="lineCov">        270 :         while(ifile.scanField(&quot;time&quot;,time))</span></a>
<a name="728"><span class="lineNum">     728 </span>            :         {</a>
<a name="729"><span class="lineNum">     729 </span><span class="lineCov">        130 :           std::vector&lt;double&gt; center(ncv_);</span></a>
<a name="730"><span class="lineNum">     730 </span><span class="lineCov">        130 :           std::vector&lt;double&gt; sigma(ncv_);</span></a>
<a name="731"><span class="lineNum">     731 </span>            :           double height;</a>
<a name="732"><span class="lineNum">     732 </span>            :           double logweight;</a>
<a name="733"><span class="lineNum">     733 </span><span class="lineCov">        390 :           for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="734"><span class="lineNum">     734 </span><span class="lineCov">        260 :             ifile.scanField(getPntrToArgument(i)-&gt;getName(),center[i]);</span></a>
<a name="735"><span class="lineNum">     735 </span><span class="lineCov">        390 :           for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="736"><span class="lineNum">     736 </span><span class="lineCov">        520 :             ifile.scanField(&quot;sigma_&quot;+getPntrToArgument(i)-&gt;getName(),sigma[i]);</span></a>
<a name="737"><span class="lineNum">     737 </span><span class="lineCov">        130 :           if(counter_==(1+walker_rank_) &amp;&amp; adaptive_sigma_)</span></a>
<a name="738"><span class="lineNum">     738 </span><span class="lineNoCov">          0 :             sigma0_=sigma;</span></a>
<a name="739"><span class="lineNum">     739 </span><span class="lineCov">        130 :           ifile.scanField(&quot;height&quot;,height);</span></a>
<a name="740"><span class="lineNum">     740 </span><span class="lineCov">        130 :           ifile.scanField(&quot;logweight&quot;,logweight);</span></a>
<a name="741"><span class="lineNum">     741 </span><span class="lineCov">        130 :           ifile.scanField();</span></a>
<a name="742"><span class="lineNum">     742 </span><span class="lineCov">        130 :           addKernel(height,center,sigma);</span></a>
<a name="743"><span class="lineNum">     743 </span><span class="lineCov">        130 :           const double weight=std::exp(logweight);</span></a>
<a name="744"><span class="lineNum">     744 </span><span class="lineCov">        130 :           sum_weights_+=weight; //this sum is slightly inaccurate, because when printing some precision is lost</span></a>
<a name="745"><span class="lineNum">     745 </span><span class="lineCov">        130 :           sum_weights2_+=weight*weight;</span></a>
<a name="746"><span class="lineNum">     746 </span><span class="lineCov">        130 :           counter_++;</span></a>
<a name="747"><span class="lineNum">     747 </span>            :         }</a>
<a name="748"><span class="lineNum">     748 </span><span class="lineCov">          5 :         KDEnorm_=mode::explore?counter_:sum_weights_;</span></a>
<a name="749"><span class="lineNum">     749 </span><span class="lineCov">          5 :         if(!no_Zed_)</span></a>
<a name="750"><span class="lineNum">     750 </span>            :         {</a>
<a name="751"><span class="lineNum">     751 </span><span class="lineCov">          2 :           double sum_uprob=0;</span></a>
<a name="752"><span class="lineNum">     752 </span><span class="lineCov">         48 :           for(unsigned k=rank_; k&lt;kernels_.size(); k+=NumParallel_)</span></a>
<a name="753"><span class="lineNum">     753 </span><span class="lineCov">       1104 :             for(unsigned kk=0; kk&lt;kernels_.size(); kk++)</span></a>
<a name="754"><span class="lineNum">     754 </span><span class="lineCov">       1058 :               sum_uprob+=evaluateKernel(kernels_[kk],kernels_[k].center);</span></a>
<a name="755"><span class="lineNum">     755 </span><span class="lineCov">          2 :           if(NumParallel_&gt;1)</span></a>
<a name="756"><span class="lineNum">     756 </span><span class="lineNoCov">          0 :             comm.Sum(sum_uprob);</span></a>
<a name="757"><span class="lineNum">     757 </span><span class="lineCov">          2 :           Zed_=sum_uprob/KDEnorm_/kernels_.size();</span></a>
<a name="758"><span class="lineNum">     758 </span>            :         }</a>
<a name="759"><span class="lineNum">     759 </span><span class="lineCov">          5 :         log.printf(&quot;    a total of %llu kernels where read, and compressed to %lu\n&quot;,counter_-1,kernels_.size());</span></a>
<a name="760"><span class="lineNum">     760 </span>            :         convertKernelsToState=true;</a>
<a name="761"><span class="lineNum">     761 </span>            :       }</a>
<a name="762"><span class="lineNum">     762 </span><span class="lineCov">         11 :       ifile.reset(false);</span></a>
<a name="763"><span class="lineNum">     763 </span><span class="lineCov">         11 :       ifile.close();</span></a>
<a name="764"><span class="lineNum">     764 </span><span class="lineCov">         11 :       nlist_=tmp_nlist;</span></a>
<a name="765"><span class="lineNum">     765 </span>            :     }</a>
<a name="766"><span class="lineNum">     766 </span>            :     else //same behaviour as METAD</a>
<a name="767"><span class="lineNum">     767 </span><span class="lineNoCov">          0 :       plumed_merror(&quot;RESTART requested, but file '&quot;+restartFileName+&quot;' was not found!\n  Set RESTART=NO or provide a restart file&quot;);</span></a>
<a name="768"><span class="lineNum">     768 </span><span class="lineCov">         11 :     if(NumWalkers_&gt;1) //make sure that all walkers are doing the same thing</span></a>
<a name="769"><span class="lineNum">     769 </span>            :     {</a>
<a name="770"><span class="lineNum">     770 </span><span class="lineCov">          6 :       const unsigned kernels_size=kernels_.size();</span></a>
<a name="771"><span class="lineNum">     771 </span><span class="lineCov">          6 :       std::vector&lt;unsigned&gt; all_kernels_size(NumWalkers_);</span></a>
<a name="772"><span class="lineNum">     772 </span><span class="lineCov">          6 :       if(comm.Get_rank()==0)</span></a>
<a name="773"><span class="lineNum">     773 </span><span class="lineCov">          6 :         multi_sim_comm.Allgather(kernels_size,all_kernels_size);</span></a>
<a name="774"><span class="lineNum">     774 </span><span class="lineCov">          6 :       comm.Bcast(all_kernels_size,0);</span></a>
<a name="775"><span class="lineNum">     775 </span>            :       bool same_number_of_kernels=true;</a>
<a name="776"><span class="lineNum">     776 </span><span class="lineCov">         12 :       for(unsigned w=1; w&lt;NumWalkers_; w++)</span></a>
<a name="777"><span class="lineNum">     777 </span><span class="lineCov">          6 :         if(all_kernels_size[0]!=all_kernels_size[w])</span></a>
<a name="778"><span class="lineNum">     778 </span>            :           same_number_of_kernels=false;</a>
<a name="779"><span class="lineNum">     779 </span><span class="lineCov">          6 :       plumed_massert(same_number_of_kernels,&quot;RESTART - not all walkers are reading the same file!&quot;);</span></a>
<a name="780"><span class="lineNum">     780 </span>            :     }</a>
<a name="781"><span class="lineNum">     781 </span><span class="lineCov">         11 :   }</span></a>
<a name="782"><span class="lineNum">     782 </span><span class="lineCov">         10 :   else if(restartFileName.length()&gt;0)</span></a>
<a name="783"><span class="lineNum">     783 </span><span class="lineCov">          4 :     log.printf(&quot; +++ WARNING +++ the provided STATE_RFILE will be ignored, since RESTART was not requested\n&quot;);</span></a>
<a name="784"><span class="lineNum">     784 </span>            : </a>
<a name="785"><span class="lineNum">     785 </span>            : //sync all walkers to avoid opening files before reading is over (see also METAD)</a>
<a name="786"><span class="lineNum">     786 </span><span class="lineCov">         21 :   comm.Barrier();</span></a>
<a name="787"><span class="lineNum">     787 </span><span class="lineCov">         21 :   if(comm.Get_rank()==0 &amp;&amp; walkers_mpi)</span></a>
<a name="788"><span class="lineNum">     788 </span><span class="lineCov">         10 :     multi_sim_comm.Barrier();</span></a>
<a name="789"><span class="lineNum">     789 </span>            : </a>
<a name="790"><span class="lineNum">     790 </span>            : //setup output kernels file</a>
<a name="791"><span class="lineNum">     791 </span><span class="lineCov">         21 :   kernelsOfile_.link(*this);</span></a>
<a name="792"><span class="lineNum">     792 </span><span class="lineCov">         21 :   if(NumWalkers_&gt;1)</span></a>
<a name="793"><span class="lineNum">     793 </span>            :   {</a>
<a name="794"><span class="lineNum">     794 </span><span class="lineCov">         10 :     if(walker_rank_&gt;0)</span></a>
<a name="795"><span class="lineNum">     795 </span>            :       kernelsFileName=&quot;/dev/null&quot;; //only first walker writes on file</a>
<a name="796"><span class="lineNum">     796 </span><span class="lineCov">         20 :     kernelsOfile_.enforceSuffix(&quot;&quot;);</span></a>
<a name="797"><span class="lineNum">     797 </span>            :   }</a>
<a name="798"><span class="lineNum">     798 </span><span class="lineCov">         21 :   kernelsOfile_.open(kernelsFileName);</span></a>
<a name="799"><span class="lineNum">     799 </span><span class="lineCov">         21 :   if(fmt.length()&gt;0)</span></a>
<a name="800"><span class="lineNum">     800 </span><span class="lineCov">         42 :     kernelsOfile_.fmtField(&quot; &quot;+fmt);</span></a>
<a name="801"><span class="lineNum">     801 </span>            :   kernelsOfile_.setHeavyFlush(); //do I need it?</a>
<a name="802"><span class="lineNum">     802 </span>            :   //define and set const fields</a>
<a name="803"><span class="lineNum">     803 </span><span class="lineCov">         21 :   kernelsOfile_.addConstantField(&quot;action&quot;);</span></a>
<a name="804"><span class="lineNum">     804 </span><span class="lineCov">         21 :   kernelsOfile_.addConstantField(&quot;biasfactor&quot;);</span></a>
<a name="805"><span class="lineNum">     805 </span><span class="lineCov">         21 :   kernelsOfile_.addConstantField(&quot;epsilon&quot;);</span></a>
<a name="806"><span class="lineNum">     806 </span><span class="lineCov">         21 :   kernelsOfile_.addConstantField(&quot;kernel_cutoff&quot;);</span></a>
<a name="807"><span class="lineNum">     807 </span><span class="lineCov">         21 :   kernelsOfile_.addConstantField(&quot;compression_threshold&quot;);</span></a>
<a name="808"><span class="lineNum">     808 </span><span class="lineCov">         61 :   for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="809"><span class="lineNum">     809 </span><span class="lineCov">         40 :     kernelsOfile_.setupPrintValue(getPntrToArgument(i));</span></a>
<a name="810"><span class="lineNum">     810 </span><span class="lineCov">         42 :   kernelsOfile_.printField(&quot;action&quot;,getName()+&quot;_kernels&quot;);</span></a>
<a name="811"><span class="lineNum">     811 </span><span class="lineCov">         21 :   kernelsOfile_.printField(&quot;biasfactor&quot;,biasfactor_);</span></a>
<a name="812"><span class="lineNum">     812 </span><span class="lineCov">         21 :   kernelsOfile_.printField(&quot;epsilon&quot;,epsilon_);</span></a>
<a name="813"><span class="lineNum">     813 </span><span class="lineCov">         21 :   kernelsOfile_.printField(&quot;kernel_cutoff&quot;,sqrt(cutoff2_));</span></a>
<a name="814"><span class="lineNum">     814 </span><span class="lineCov">         21 :   kernelsOfile_.printField(&quot;compression_threshold&quot;,sqrt(threshold2_));</span></a>
<a name="815"><span class="lineNum">     815 </span>            : </a>
<a name="816"><span class="lineNum">     816 </span>            : //open file for storing state</a>
<a name="817"><span class="lineNum">     817 </span><span class="lineCov">         21 :   if(wStateStride_!=0)</span></a>
<a name="818"><span class="lineNum">     818 </span>            :   {</a>
<a name="819"><span class="lineNum">     819 </span><span class="lineCov">         11 :     stateOfile_.link(*this);</span></a>
<a name="820"><span class="lineNum">     820 </span><span class="lineCov">         11 :     if(NumWalkers_&gt;1)</span></a>
<a name="821"><span class="lineNum">     821 </span>            :     {</a>
<a name="822"><span class="lineNum">     822 </span><span class="lineCov">          8 :       if(walker_rank_&gt;0)</span></a>
<a name="823"><span class="lineNum">     823 </span>            :         stateFileName=&quot;/dev/null&quot;; //only first walker writes on file</a>
<a name="824"><span class="lineNum">     824 </span><span class="lineCov">         16 :       stateOfile_.enforceSuffix(&quot;&quot;);</span></a>
<a name="825"><span class="lineNum">     825 </span>            :     }</a>
<a name="826"><span class="lineNum">     826 </span><span class="lineCov">         11 :     stateOfile_.open(stateFileName);</span></a>
<a name="827"><span class="lineNum">     827 </span><span class="lineCov">         11 :     if(fmt.length()&gt;0)</span></a>
<a name="828"><span class="lineNum">     828 </span><span class="lineCov">         22 :       stateOfile_.fmtField(&quot; &quot;+fmt);</span></a>
<a name="829"><span class="lineNum">     829 </span><span class="lineCov">         11 :     if(convertKernelsToState)</span></a>
<a name="830"><span class="lineNum">     830 </span><span class="lineNoCov">          0 :       dumpStateToFile();</span></a>
<a name="831"><span class="lineNum">     831 </span>            :   }</a>
<a name="832"><span class="lineNum">     832 </span>            : </a>
<a name="833"><span class="lineNum">     833 </span>            : //set initial old values</a>
<a name="834"><span class="lineNum">     834 </span><span class="lineCov">         21 :   KDEnorm_=mode::explore?counter_:sum_weights_;</span></a>
<a name="835"><span class="lineNum">     835 </span><span class="lineCov">         21 :   old_KDEnorm_=KDEnorm_;</span></a>
<a name="836"><span class="lineNum">     836 </span>            : </a>
<a name="837"><span class="lineNum">     837 </span>            : //add and set output components</a>
<a name="838"><span class="lineNum">     838 </span><span class="lineCov">         21 :   addComponent(&quot;rct&quot;);</span></a>
<a name="839"><span class="lineNum">     839 </span><span class="lineCov">         21 :   componentIsNotPeriodic(&quot;rct&quot;);</span></a>
<a name="840"><span class="lineNum">     840 </span><span class="lineCov">         21 :   getPntrToComponent(&quot;rct&quot;)-&gt;set(kbt_*std::log(sum_weights_/counter_));</span></a>
<a name="841"><span class="lineNum">     841 </span><span class="lineCov">         21 :   addComponent(&quot;zed&quot;);</span></a>
<a name="842"><span class="lineNum">     842 </span><span class="lineCov">         21 :   componentIsNotPeriodic(&quot;zed&quot;);</span></a>
<a name="843"><span class="lineNum">     843 </span><span class="lineCov">         21 :   getPntrToComponent(&quot;zed&quot;)-&gt;set(Zed_);</span></a>
<a name="844"><span class="lineNum">     844 </span><span class="lineCov">         21 :   addComponent(&quot;neff&quot;);</span></a>
<a name="845"><span class="lineNum">     845 </span><span class="lineCov">         21 :   componentIsNotPeriodic(&quot;neff&quot;);</span></a>
<a name="846"><span class="lineNum">     846 </span><span class="lineCov">         21 :   getPntrToComponent(&quot;neff&quot;)-&gt;set(std::pow(1+sum_weights_,2)/(1+sum_weights2_));</span></a>
<a name="847"><span class="lineNum">     847 </span><span class="lineCov">         21 :   addComponent(&quot;nker&quot;);</span></a>
<a name="848"><span class="lineNum">     848 </span><span class="lineCov">         21 :   componentIsNotPeriodic(&quot;nker&quot;);</span></a>
<a name="849"><span class="lineNum">     849 </span><span class="lineCov">         21 :   getPntrToComponent(&quot;nker&quot;)-&gt;set(kernels_.size());</span></a>
<a name="850"><span class="lineNum">     850 </span><span class="lineCov">         21 :   if(calc_work_)</span></a>
<a name="851"><span class="lineNum">     851 </span>            :   {</a>
<a name="852"><span class="lineNum">     852 </span><span class="lineCov">          7 :     addComponent(&quot;work&quot;);</span></a>
<a name="853"><span class="lineNum">     853 </span><span class="lineCov">         14 :     componentIsNotPeriodic(&quot;work&quot;);</span></a>
<a name="854"><span class="lineNum">     854 </span>            :   }</a>
<a name="855"><span class="lineNum">     855 </span><span class="lineCov">         21 :   if(nlist_)</span></a>
<a name="856"><span class="lineNum">     856 </span>            :   {</a>
<a name="857"><span class="lineNum">     857 </span><span class="lineCov">          5 :     addComponent(&quot;nlker&quot;);</span></a>
<a name="858"><span class="lineNum">     858 </span><span class="lineCov">          5 :     componentIsNotPeriodic(&quot;nlker&quot;);</span></a>
<a name="859"><span class="lineNum">     859 </span><span class="lineCov">          5 :     addComponent(&quot;nlsteps&quot;);</span></a>
<a name="860"><span class="lineNum">     860 </span><span class="lineCov">         10 :     componentIsNotPeriodic(&quot;nlsteps&quot;);</span></a>
<a name="861"><span class="lineNum">     861 </span>            :   }</a>
<a name="862"><span class="lineNum">     862 </span>            : </a>
<a name="863"><span class="lineNum">     863 </span>            : //printing some info</a>
<a name="864"><span class="lineNum">     864 </span><span class="lineCov">         21 :   log.printf(&quot;  temperature = %g\n&quot;,kbt_/kB);</span></a>
<a name="865"><span class="lineNum">     865 </span><span class="lineCov">         21 :   log.printf(&quot;  beta = %g\n&quot;,1./kbt_);</span></a>
<a name="866"><span class="lineNum">     866 </span><span class="lineCov">         21 :   log.printf(&quot;  depositing new kernels with PACE = %u\n&quot;,stride_);</span></a>
<a name="867"><span class="lineNum">     867 </span><span class="lineCov">         21 :   log.printf(&quot;  expected BARRIER is %g\n&quot;,barrier);</span></a>
<a name="868"><span class="lineNum">     868 </span><span class="lineCov">         21 :   log.printf(&quot;  using target distribution with BIASFACTOR gamma = %g\n&quot;,biasfactor_);</span></a>
<a name="869"><span class="lineNum">     869 </span><span class="lineCov">         21 :   if(std::isinf(biasfactor_))</span></a>
<a name="870"><span class="lineNum">     870 </span><span class="lineCov">          4 :     log.printf(&quot;    (thus a uniform flat target distribution, no well-tempering)\n&quot;);</span></a>
<a name="871"><span class="lineNum">     871 </span><span class="lineCov">         21 :   if(excluded_region_!=NULL)</span></a>
<a name="872"><span class="lineNum">     872 </span><span class="lineCov">          2 :     log.printf(&quot; -- EXCLUDED_REGION: kernels will be deposited only when '%s' is equal to zero\n&quot;,excluded_region_-&gt;getName().c_str());</span></a>
<a name="873"><span class="lineNum">     873 </span><span class="lineCov">         21 :   if(extra_biases_.size()&gt;0)</span></a>
<a name="874"><span class="lineNum">     874 </span>            :   {</a>
<a name="875"><span class="lineNum">     875 </span><span class="lineCov">          2 :     log.printf(&quot; -- EXTRA_BIAS: &quot;);</span></a>
<a name="876"><span class="lineNum">     876 </span><span class="lineCov">          5 :     for(unsigned e=0; e&lt;extra_biases_.size(); e++)</span></a>
<a name="877"><span class="lineNum">     877 </span><span class="lineCov">          3 :       log.printf(&quot;%s &quot;,extra_biases_[e]-&gt;getName().c_str());</span></a>
<a name="878"><span class="lineNum">     878 </span><span class="lineCov">          2 :     log.printf(&quot;will be reweighted\n&quot;);</span></a>
<a name="879"><span class="lineNum">     879 </span>            :   }</a>
<a name="880"><span class="lineNum">     880 </span><span class="lineCov">         21 :   if(adaptive_sigma_)</span></a>
<a name="881"><span class="lineNum">     881 </span>            :   {</a>
<a name="882"><span class="lineNum">     882 </span><span class="lineCov">         11 :     log.printf(&quot;  adaptive SIGMA will be used, with ADAPTIVE_SIGMA_STRIDE = %u\n&quot;,adaptive_sigma_stride_);</span></a>
<a name="883"><span class="lineNum">     883 </span><span class="lineCov">         11 :     unsigned x=std::ceil(adaptive_sigma_stride_/stride_);</span></a>
<a name="884"><span class="lineNum">     884 </span><span class="lineCov">         11 :     log.printf(&quot;    thus the first x kernel depositions will be skipped, x = ADAPTIVE_SIGMA_STRIDE/PACE = %u\n&quot;,x);</span></a>
<a name="885"><span class="lineNum">     885 </span>            :   }</a>
<a name="886"><span class="lineNum">     886 </span>            :   else</a>
<a name="887"><span class="lineNum">     887 </span>            :   {</a>
<a name="888"><span class="lineNum">     888 </span><span class="lineCov">         10 :     log.printf(&quot;  kernels have initial SIGMA = &quot;);</span></a>
<a name="889"><span class="lineNum">     889 </span><span class="lineCov">         29 :     for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="890"><span class="lineNum">     890 </span><span class="lineCov">         19 :       log.printf(&quot; %g&quot;,sigma0_[i]);</span></a>
<a name="891"><span class="lineNum">     891 </span><span class="lineCov">         10 :     log.printf(&quot;\n&quot;);</span></a>
<a name="892"><span class="lineNum">     892 </span>            :   }</a>
<a name="893"><span class="lineNum">     893 </span><span class="lineCov">         21 :   if(sigma_min_.size()&gt;0)</span></a>
<a name="894"><span class="lineNum">     894 </span>            :   {</a>
<a name="895"><span class="lineNum">     895 </span><span class="lineCov">          3 :     log.printf(&quot;  kernels have a SIGMA_MIN = &quot;);</span></a>
<a name="896"><span class="lineNum">     896 </span><span class="lineCov">          9 :     for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="897"><span class="lineNum">     897 </span><span class="lineCov">          6 :       log.printf(&quot; %g&quot;,sigma_min_[i]);</span></a>
<a name="898"><span class="lineNum">     898 </span><span class="lineCov">          3 :     log.printf(&quot;\n&quot;);</span></a>
<a name="899"><span class="lineNum">     899 </span>            :   }</a>
<a name="900"><span class="lineNum">     900 </span><span class="lineCov">         21 :   if(fixed_sigma_)</span></a>
<a name="901"><span class="lineNum">     901 </span><span class="lineCov">          6 :     log.printf(&quot; -- FIXED_SIGMA: sigma will not decrease as the simulation proceeds\n&quot;);</span></a>
<a name="902"><span class="lineNum">     902 </span><span class="lineCov">         21 :   log.printf(&quot;  kernels are truncated with KERNELS_CUTOFF = %g\n&quot;,cutoff);</span></a>
<a name="903"><span class="lineNum">     903 </span><span class="lineCov">         21 :   if(cutoff&lt;3.5)</span></a>
<a name="904"><span class="lineNum">     904 </span><span class="lineNoCov">          0 :     log.printf(&quot; +++ WARNING +++ probably kernels are truncated too much\n&quot;);</span></a>
<a name="905"><span class="lineNum">     905 </span><span class="lineCov">         21 :   log.printf(&quot;  the value at cutoff is = %g\n&quot;,val_at_cutoff_);</span></a>
<a name="906"><span class="lineNum">     906 </span><span class="lineCov">         21 :   log.printf(&quot;  regularization EPSILON = %g\n&quot;,epsilon_);</span></a>
<a name="907"><span class="lineNum">     907 </span><span class="lineCov">         21 :   if(val_at_cutoff_&gt;epsilon_*(1+1e-6))</span></a>
<a name="908"><span class="lineNum">     908 </span><span class="lineNoCov">          0 :     log.printf(&quot; +++ WARNING +++ the KERNEL_CUTOFF might be too small for the given EPSILON\n&quot;);</span></a>
<a name="909"><span class="lineNum">     909 </span><span class="lineCov">         21 :   log.printf(&quot;  kernels will be compressed when closer than COMPRESSION_THRESHOLD = %g\n&quot;,sqrt(threshold2_));</span></a>
<a name="910"><span class="lineNum">     910 </span><span class="lineCov">         21 :   if(threshold2_==0)</span></a>
<a name="911"><span class="lineNum">     911 </span><span class="lineNoCov">          0 :     log.printf(&quot; +++ WARNING +++ kernels will never merge, expect slowdowns\n&quot;);</span></a>
<a name="912"><span class="lineNum">     912 </span><span class="lineCov">         21 :   if(!recursive_merge_)</span></a>
<a name="913"><span class="lineNum">     913 </span><span class="lineCov">          6 :     log.printf(&quot; -- RECURSIVE_MERGE_OFF: only one merge for each new kernel will be attempted. This is faster only if total number of kernels does not grow too much\n&quot;);</span></a>
<a name="914"><span class="lineNum">     914 </span><span class="lineCov">         21 :   if(nlist_)</span></a>
<a name="915"><span class="lineNum">     915 </span><span class="lineCov">          5 :     log.printf(&quot; -- NLIST: using neighbor list for kernels, with parameters: %g,%g\n&quot;,nlist_param_[0],nlist_param_[1]);</span></a>
<a name="916"><span class="lineNum">     916 </span><span class="lineCov">         21 :   if(nlist_pace_reset_)</span></a>
<a name="917"><span class="lineNum">     917 </span><span class="lineCov">          2 :     log.printf(&quot; -- NLIST_PACE_RESET: forcing the neighbor list to update every PACE\n&quot;);</span></a>
<a name="918"><span class="lineNum">     918 </span><span class="lineCov">         21 :   if(no_Zed_)</span></a>
<a name="919"><span class="lineNum">     919 </span><span class="lineCov">          6 :     log.printf(&quot; -- NO_ZED: using fixed normalization factor = %g\n&quot;,Zed_);</span></a>
<a name="920"><span class="lineNum">     920 </span><span class="lineCov">         21 :   if(wStateStride_&gt;0)</span></a>
<a name="921"><span class="lineNum">     921 </span><span class="lineCov">         10 :     log.printf(&quot;  state checkpoints are written on file %s every %d MD steps\n&quot;,stateFileName.c_str(),wStateStride_);</span></a>
<a name="922"><span class="lineNum">     922 </span><span class="lineCov">         21 :   if(wStateStride_==-1)</span></a>
<a name="923"><span class="lineNum">     923 </span><span class="lineCov">          1 :     log.printf(&quot;  state checkpoints are written on file %s only on CPT events (or never if MD code does define them!)\n&quot;,stateFileName.c_str());</span></a>
<a name="924"><span class="lineNum">     924 </span><span class="lineCov">         21 :   if(walkers_mpi)</span></a>
<a name="925"><span class="lineNum">     925 </span><span class="lineCov">         10 :     log.printf(&quot; -- WALKERS_MPI: if multiple replicas are present, they will share the same bias via MPI\n&quot;);</span></a>
<a name="926"><span class="lineNum">     926 </span><span class="lineCov">         21 :   if(NumWalkers_&gt;1)</span></a>
<a name="927"><span class="lineNum">     927 </span>            :   {</a>
<a name="928"><span class="lineNum">     928 </span><span class="lineCov">         10 :     log.printf(&quot;  using multiple walkers\n&quot;);</span></a>
<a name="929"><span class="lineNum">     929 </span><span class="lineCov">         10 :     log.printf(&quot;    number of walkers: %u\n&quot;,NumWalkers_);</span></a>
<a name="930"><span class="lineNum">     930 </span><span class="lineCov">         10 :     log.printf(&quot;    walker rank: %u\n&quot;,walker_rank_);</span></a>
<a name="931"><span class="lineNum">     931 </span>            :   }</a>
<a name="932"><span class="lineNum">     932 </span><span class="lineCov">         21 :   int mw_warning=0;</span></a>
<a name="933"><span class="lineNum">     933 </span><span class="lineCov">         21 :   if(!walkers_mpi &amp;&amp; comm.Get_rank()==0 &amp;&amp; multi_sim_comm.Get_size()&gt;(int)NumWalkers_)</span></a>
<a name="934"><span class="lineNum">     934 </span><span class="lineNoCov">          0 :     mw_warning=1;</span></a>
<a name="935"><span class="lineNum">     935 </span><span class="lineCov">         21 :   comm.Bcast(mw_warning,0);</span></a>
<a name="936"><span class="lineNum">     936 </span><span class="lineCov">         21 :   if(mw_warning) //log.printf messes up with comm, so never use it without Bcast!</span></a>
<a name="937"><span class="lineNum">     937 </span><span class="lineNoCov">          0 :     log.printf(&quot; +++ WARNING +++ multiple replicas will NOT communicate unless the flag WALKERS_MPI is used\n&quot;);</span></a>
<a name="938"><span class="lineNum">     938 </span><span class="lineCov">         21 :   if(NumParallel_&gt;1)</span></a>
<a name="939"><span class="lineNum">     939 </span><span class="lineCov">          4 :     log.printf(&quot;  using multiple MPI processes per simulation: %u\n&quot;,NumParallel_);</span></a>
<a name="940"><span class="lineNum">     940 </span><span class="lineCov">         21 :   if(NumOMP_&gt;1)</span></a>
<a name="941"><span class="lineNum">     941 </span><span class="lineCov">         17 :     log.printf(&quot;  using multiple OpenMP threads per simulation: %u\n&quot;,NumOMP_);</span></a>
<a name="942"><span class="lineNum">     942 </span><span class="lineCov">         21 :   if(serial)</span></a>
<a name="943"><span class="lineNum">     943 </span><span class="lineCov">          4 :     log.printf(&quot; -- SERIAL: no loop parallelization, despite %d MPI processes and %u OpenMP threads available\n&quot;,comm.Get_size(),OpenMP::getNumThreads());</span></a>
<a name="944"><span class="lineNum">     944 </span><span class="lineCov">         21 :   log.printf(&quot;  Bibliography: &quot;);</span></a>
<a name="945"><span class="lineNum">     945 </span><span class="lineCov">         42 :   log&lt;&lt;plumed.cite(&quot;M. Invernizzi and M. Parrinello, J. Phys. Chem. Lett. 11, 2731-2736 (2020)&quot;);</span></a>
<a name="946"><span class="lineNum">     946 </span><span class="lineCov">         14 :   if(mode::explore || adaptive_sigma_)</span></a>
<a name="947"><span class="lineNum">     947 </span><span class="lineCov">         28 :     log&lt;&lt;plumed.cite(&quot;M. Invernizzi and M. Parrinello, J. Chem. Theory Comput. 18, 3988-3996 (2022)&quot;);</span></a>
<a name="948"><span class="lineNum">     948 </span><span class="lineCov">         21 :   log.printf(&quot;\n&quot;);</span></a>
<a name="949"><span class="lineNum">     949 </span><span class="lineCov">         42 : }</span></a>
<a name="950"><span class="lineNum">     950 </span>            : </a>
<a name="951"><span class="lineNum">     951 </span>            : template &lt;class mode&gt;</a>
<a name="952"><span class="lineNum">     952 </span><span class="lineCov">       1071 : void OPESmetad&lt;mode&gt;::calculate()</span></a>
<a name="953"><span class="lineNum">     953 </span>            : {</a>
<a name="954"><span class="lineNum">     954 </span>            : //get cv</a>
<a name="955"><span class="lineNum">     955 </span><span class="lineCov">       1071 :   std::vector&lt;double&gt; cv(ncv_);</span></a>
<a name="956"><span class="lineNum">     956 </span><span class="lineCov">       3111 :   for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="957"><span class="lineNum">     957 </span><span class="lineCov">       2040 :     cv[i]=getArgument(i);</span></a>
<a name="958"><span class="lineNum">     958 </span>            : </a>
<a name="959"><span class="lineNum">     959 </span>            : //check neighbor list</a>
<a name="960"><span class="lineNum">     960 </span><span class="lineCov">       1071 :   if(nlist_)</span></a>
<a name="961"><span class="lineNum">     961 </span>            :   {</a>
<a name="962"><span class="lineNum">     962 </span><span class="lineCov">        255 :     nlist_steps_++;</span></a>
<a name="963"><span class="lineNum">     963 </span><span class="lineCov">        255 :     if(getExchangeStep())</span></a>
<a name="964"><span class="lineNum">     964 </span><span class="lineNoCov">          0 :       nlist_update_=true;</span></a>
<a name="965"><span class="lineNum">     965 </span>            :     else</a>
<a name="966"><span class="lineNum">     966 </span>            :     {</a>
<a name="967"><span class="lineNum">     967 </span><span class="lineCov">        275 :       for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="968"><span class="lineNum">     968 </span>            :       {</a>
<a name="969"><span class="lineNum">     969 </span><span class="lineCov">        270 :         const double diff_i=difference(i,cv[i],nlist_center_[i]);</span></a>
<a name="970"><span class="lineNum">     970 </span><span class="lineCov">        270 :         if(diff_i*diff_i&gt;nlist_param_[1]*nlist_dev2_[i])</span></a>
<a name="971"><span class="lineNum">     971 </span>            :         {</a>
<a name="972"><span class="lineNum">     972 </span><span class="lineCov">        250 :           nlist_update_=true;</span></a>
<a name="973"><span class="lineNum">     973 </span><span class="lineCov">        250 :           break;</span></a>
<a name="974"><span class="lineNum">     974 </span>            :         }</a>
<a name="975"><span class="lineNum">     975 </span>            :       }</a>
<a name="976"><span class="lineNum">     976 </span>            :     }</a>
<a name="977"><span class="lineNum">     977 </span><span class="lineCov">        255 :     if(nlist_update_)</span></a>
<a name="978"><span class="lineNum">     978 </span><span class="lineCov">        250 :       updateNlist(cv);</span></a>
<a name="979"><span class="lineNum">     979 </span>            :   }</a>
<a name="980"><span class="lineNum">     980 </span>            : </a>
<a name="981"><span class="lineNum">     981 </span>            : //set bias and forces</a>
<a name="982"><span class="lineNum">     982 </span><span class="lineCov">       1071 :   std::vector&lt;double&gt; der_prob(ncv_,0);</span></a>
<a name="983"><span class="lineNum">     983 </span><span class="lineCov">       1071 :   const double prob=getProbAndDerivatives(cv,der_prob);</span></a>
<a name="984"><span class="lineNum">     984 </span><span class="lineCov">       1071 :   const double bias=kbt_*bias_prefactor_*std::log(prob/Zed_+epsilon_);</span></a>
<a name="985"><span class="lineNum">     985 </span>            :   setBias(bias);</a>
<a name="986"><span class="lineNum">     986 </span><span class="lineCov">       3111 :   for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="987"><span class="lineNum">     987 </span><span class="lineCov">       2040 :     setOutputForce(i,-kbt_*bias_prefactor_/(prob/Zed_+epsilon_)*der_prob[i]/Zed_);</span></a>
<a name="988"><span class="lineNum">     988 </span><span class="lineCov">       1071 : }</span></a>
<a name="989"><span class="lineNum">     989 </span>            : </a>
<a name="990"><span class="lineNum">     990 </span>            : template &lt;class mode&gt;</a>
<a name="991"><span class="lineNum">     991 </span><span class="lineCov">       1071 : void OPESmetad&lt;mode&gt;::update()</span></a>
<a name="992"><span class="lineNum">     992 </span>            : {</a>
<a name="993"><span class="lineNum">     993 </span><span class="lineCov">       1071 :   if(isFirstStep_)//same in MetaD, useful for restarts?</span></a>
<a name="994"><span class="lineNum">     994 </span>            :   {</a>
<a name="995"><span class="lineNum">     995 </span><span class="lineCov">         21 :     isFirstStep_=false;</span></a>
<a name="996"><span class="lineNum">     996 </span><span class="lineCov">         21 :     return;</span></a>
<a name="997"><span class="lineNum">     997 </span>            :   }</a>
<a name="998"><span class="lineNum">     998 </span>            : </a>
<a name="999"><span class="lineNum">     999 </span>            : //update variance if adaptive sigma</a>
<a name="1000"><span class="lineNum">    1000 </span><span class="lineCov">       1050 :   if(adaptive_sigma_)</span></a>
<a name="1001"><span class="lineNum">    1001 </span>            :   {</a>
<a name="1002"><span class="lineNum">    1002 </span><span class="lineCov">        550 :     adaptive_counter_++;</span></a>
<a name="1003"><span class="lineNum">    1003 </span><span class="lineCov">        550 :     unsigned tau=adaptive_sigma_stride_;</span></a>
<a name="1004"><span class="lineNum">    1004 </span><span class="lineCov">        550 :     if(adaptive_counter_&lt;adaptive_sigma_stride_)</span></a>
<a name="1005"><span class="lineNum">    1005 </span><span class="lineCov">         45 :       tau=adaptive_counter_;</span></a>
<a name="1006"><span class="lineNum">    1006 </span><span class="lineCov">       1600 :     for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1007"><span class="lineNum">    1007 </span>            :     { //Welford's online algorithm for standard deviation</a>
<a name="1008"><span class="lineNum">    1008 </span>            :       const double cv_i=getArgument(i);</a>
<a name="1009"><span class="lineNum">    1009 </span><span class="lineCov">       1050 :       const double diff_i=difference(i,av_cv_[i],cv_i);</span></a>
<a name="1010"><span class="lineNum">    1010 </span><span class="lineCov">       1050 :       av_cv_[i]+=diff_i/tau; //exponentially decaying average</span></a>
<a name="1011"><span class="lineNum">    1011 </span><span class="lineCov">       1050 :       av_M2_[i]+=diff_i*difference(i,av_cv_[i],cv_i);</span></a>
<a name="1012"><span class="lineNum">    1012 </span>            :     }</a>
<a name="1013"><span class="lineNum">    1013 </span><span class="lineCov">        550 :     if(adaptive_counter_&lt;adaptive_sigma_stride_ &amp;&amp; counter_==1) //counter_&gt;1 if restarting</span></a>
<a name="1014"><span class="lineNum">    1014 </span>            :       return; //do not apply bias before having measured sigma</a>
<a name="1015"><span class="lineNum">    1015 </span>            :   }</a>
<a name="1016"><span class="lineNum">    1016 </span>            : </a>
<a name="1017"><span class="lineNum">    1017 </span>            : //do update</a>
<a name="1018"><span class="lineNum">    1018 </span><span class="lineCov">       1005 :   if(getStep()%stride_==0 &amp;&amp; (excluded_region_==NULL || excluded_region_-&gt;get()==0))</span></a>
<a name="1019"><span class="lineNum">    1019 </span>            :   {</a>
<a name="1020"><span class="lineNum">    1020 </span><span class="lineCov">        257 :     old_KDEnorm_=KDEnorm_;</span></a>
<a name="1021"><span class="lineNum">    1021 </span><span class="lineCov">        257 :     delta_kernels_.clear();</span></a>
<a name="1022"><span class="lineNum">    1022 </span><span class="lineCov">        257 :     unsigned old_nker=kernels_.size();</span></a>
<a name="1023"><span class="lineNum">    1023 </span>            : </a>
<a name="1024"><span class="lineNum">    1024 </span>            :     //get new kernel height</a>
<a name="1025"><span class="lineNum">    1025 </span><span class="lineCov">        257 :     double log_weight=getOutputQuantity(0)/kbt_; //first value is always the current bias</span></a>
<a name="1026"><span class="lineNum">    1026 </span><span class="lineCov">        277 :     for(unsigned e=0; e&lt;extra_biases_.size(); e++)</span></a>
<a name="1027"><span class="lineNum">    1027 </span><span class="lineCov">         20 :       log_weight+=extra_biases_[e]-&gt;get()/kbt_; //extra biases contribute to the weight</span></a>
<a name="1028"><span class="lineNum">    1028 </span><span class="lineCov">        257 :     double height=std::exp(log_weight);</span></a>
<a name="1029"><span class="lineNum">    1029 </span>            : </a>
<a name="1030"><span class="lineNum">    1030 </span>            :     //update sum_weights_ and neff</a>
<a name="1031"><span class="lineNum">    1031 </span><span class="lineCov">        257 :     double sum_heights=height;</span></a>
<a name="1032"><span class="lineNum">    1032 </span><span class="lineCov">        257 :     double sum_heights2=height*height;</span></a>
<a name="1033"><span class="lineNum">    1033 </span><span class="lineCov">        257 :     if(NumWalkers_&gt;1)</span></a>
<a name="1034"><span class="lineNum">    1034 </span>            :     {</a>
<a name="1035"><span class="lineNum">    1035 </span><span class="lineCov">        126 :       if(comm.Get_rank()==0)</span></a>
<a name="1036"><span class="lineNum">    1036 </span>            :       {</a>
<a name="1037"><span class="lineNum">    1037 </span><span class="lineCov">        126 :         multi_sim_comm.Sum(sum_heights);</span></a>
<a name="1038"><span class="lineNum">    1038 </span><span class="lineCov">        126 :         multi_sim_comm.Sum(sum_heights2);</span></a>
<a name="1039"><span class="lineNum">    1039 </span>            :       }</a>
<a name="1040"><span class="lineNum">    1040 </span><span class="lineCov">        126 :       comm.Bcast(sum_heights,0);</span></a>
<a name="1041"><span class="lineNum">    1041 </span><span class="lineCov">        126 :       comm.Bcast(sum_heights2,0);</span></a>
<a name="1042"><span class="lineNum">    1042 </span>            :     }</a>
<a name="1043"><span class="lineNum">    1043 </span><span class="lineCov">        257 :     counter_+=NumWalkers_;</span></a>
<a name="1044"><span class="lineNum">    1044 </span><span class="lineCov">        257 :     sum_weights_+=sum_heights;</span></a>
<a name="1045"><span class="lineNum">    1045 </span><span class="lineCov">        257 :     sum_weights2_+=sum_heights2;</span></a>
<a name="1046"><span class="lineNum">    1046 </span><span class="lineCov">        257 :     const double neff=std::pow(1+sum_weights_,2)/(1+sum_weights2_); //adding 1 makes it more robust at the start</span></a>
<a name="1047"><span class="lineNum">    1047 </span><span class="lineCov">        257 :     getPntrToComponent(&quot;rct&quot;)-&gt;set(kbt_*std::log(sum_weights_/counter_));</span></a>
<a name="1048"><span class="lineNum">    1048 </span><span class="lineCov">        257 :     getPntrToComponent(&quot;neff&quot;)-&gt;set(neff);</span></a>
<a name="1049"><span class="lineNum">    1049 </span>            :     if(mode::explore)</a>
<a name="1050"><span class="lineNum">    1050 </span>            :     {</a>
<a name="1051"><span class="lineNum">    1051 </span><span class="lineCov">         68 :       KDEnorm_=counter_;</span></a>
<a name="1052"><span class="lineNum">    1052 </span><span class="lineCov">         68 :       height=1; //plain KDE, bias reweight does not enter here</span></a>
<a name="1053"><span class="lineNum">    1053 </span>            :     }</a>
<a name="1054"><span class="lineNum">    1054 </span>            :     else</a>
<a name="1055"><span class="lineNum">    1055 </span><span class="lineCov">        189 :       KDEnorm_=sum_weights_;</span></a>
<a name="1056"><span class="lineNum">    1056 </span>            : </a>
<a name="1057"><span class="lineNum">    1057 </span>            :     //if needed, rescale sigma and height</a>
<a name="1058"><span class="lineNum">    1058 </span><span class="lineCov">        257 :     std::vector&lt;double&gt; sigma=sigma0_;</span></a>
<a name="1059"><span class="lineNum">    1059 </span><span class="lineCov">        257 :     if(adaptive_sigma_)</span></a>
<a name="1060"><span class="lineNum">    1060 </span>            :     {</a>
<a name="1061"><span class="lineNum">    1061 </span><span class="lineCov">         93 :       const double factor=mode::explore?1:biasfactor_;</span></a>
<a name="1062"><span class="lineNum">    1062 </span><span class="lineCov">        131 :       if(counter_==1+NumWalkers_) //first time only</span></a>
<a name="1063"><span class="lineNum">    1063 </span>            :       {</a>
<a name="1064"><span class="lineNum">    1064 </span><span class="lineCov">         14 :         for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1065"><span class="lineNum">    1065 </span><span class="lineCov">          9 :           av_M2_[i]*=biasfactor_; //from unbiased, thus must be adjusted</span></a>
<a name="1066"><span class="lineNum">    1066 </span><span class="lineCov">         14 :         for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1067"><span class="lineNum">    1067 </span><span class="lineCov">          9 :           sigma0_[i]=std::sqrt(av_M2_[i]/adaptive_counter_/factor);</span></a>
<a name="1068"><span class="lineNum">    1068 </span><span class="lineCov">          5 :         if(sigma_min_.size()==0)</span></a>
<a name="1069"><span class="lineNum">    1069 </span>            :         {</a>
<a name="1070"><span class="lineNum">    1070 </span><span class="lineCov">         14 :           for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1071"><span class="lineNum">    1071 </span><span class="lineCov">          9 :             plumed_massert(sigma0_[i]&gt;1e-6,&quot;ADAPTIVE SIGMA is suspiciously small for CV i=&quot;+std::to_string(i)+&quot;\nManually provide SIGMA or set a safe SIGMA_MIN to avoid possible issues&quot;);</span></a>
<a name="1072"><span class="lineNum">    1072 </span>            :         }</a>
<a name="1073"><span class="lineNum">    1073 </span>            :         else</a>
<a name="1074"><span class="lineNum">    1074 </span>            :         {</a>
<a name="1075"><span class="lineNum">    1075 </span><span class="lineNoCov">          0 :           for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1076"><span class="lineNum">    1076 </span><span class="lineNoCov">          0 :             sigma0_[i]=std::max(sigma0_[i],sigma_min_[i]);</span></a>
<a name="1077"><span class="lineNum">    1077 </span>            :         }</a>
<a name="1078"><span class="lineNum">    1078 </span>            :       }</a>
<a name="1079"><span class="lineNum">    1079 </span><span class="lineCov">        388 :       for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1080"><span class="lineNum">    1080 </span><span class="lineCov">        257 :         sigma[i]=std::sqrt(av_M2_[i]/adaptive_counter_/factor);</span></a>
<a name="1081"><span class="lineNum">    1081 </span><span class="lineCov">        131 :       if(sigma_min_.size()==0)</span></a>
<a name="1082"><span class="lineNum">    1082 </span>            :       {</a>
<a name="1083"><span class="lineNum">    1083 </span><span class="lineCov">        238 :         for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1084"><span class="lineNum">    1084 </span>            :         {</a>
<a name="1085"><span class="lineNum">    1085 </span><span class="lineCov">        157 :           if(sigma[i]&lt;1e-6)</span></a>
<a name="1086"><span class="lineNum">    1086 </span>            :           {</a>
<a name="1087"><span class="lineNum">    1087 </span><span class="lineNoCov">          0 :             log.printf(&quot;+++ WARNING +++ the ADAPTIVE SIGMA is suspiciously small, you should set a safe SIGMA_MIN. 1e-6 will be used here\n&quot;);</span></a>
<a name="1088"><span class="lineNum">    1088 </span><span class="lineNoCov">          0 :             sigma[i]=1e-6;</span></a>
<a name="1089"><span class="lineNum">    1089 </span><span class="lineNoCov">          0 :             sigma_min_.resize(ncv_,1e-6);</span></a>
<a name="1090"><span class="lineNum">    1090 </span>            :           }</a>
<a name="1091"><span class="lineNum">    1091 </span>            :         }</a>
<a name="1092"><span class="lineNum">    1092 </span>            :       }</a>
<a name="1093"><span class="lineNum">    1093 </span>            :       else</a>
<a name="1094"><span class="lineNum">    1094 </span>            :       {</a>
<a name="1095"><span class="lineNum">    1095 </span><span class="lineCov">        150 :         for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1096"><span class="lineNum">    1096 </span><span class="lineCov">        100 :           sigma[i]=std::max(sigma[i],sigma_min_[i]);</span></a>
<a name="1097"><span class="lineNum">    1097 </span>            :       }</a>
<a name="1098"><span class="lineNum">    1098 </span>            :     }</a>
<a name="1099"><span class="lineNum">    1099 </span><span class="lineCov">        257 :     if(!fixed_sigma_)</span></a>
<a name="1100"><span class="lineNum">    1100 </span>            :     {</a>
<a name="1101"><span class="lineNum">    1101 </span><span class="lineCov">         38 :       const double size=mode::explore?counter_:neff; //for EXPLORE neff is not relevant</span></a>
<a name="1102"><span class="lineNum">    1102 </span><span class="lineCov">        197 :       const double s_rescaling=std::pow(size*(ncv_+2.)/4.,-1./(4+ncv_));</span></a>
<a name="1103"><span class="lineNum">    1103 </span><span class="lineCov">        576 :       for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1104"><span class="lineNum">    1104 </span><span class="lineCov">        379 :         sigma[i]*=s_rescaling;</span></a>
<a name="1105"><span class="lineNum">    1105 </span><span class="lineCov">        197 :       if(sigma_min_.size()&gt;0)</span></a>
<a name="1106"><span class="lineNum">    1106 </span>            :       {</a>
<a name="1107"><span class="lineNum">    1107 </span><span class="lineCov">        150 :         for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1108"><span class="lineNum">    1108 </span><span class="lineCov">        100 :           sigma[i]=std::max(sigma[i],sigma_min_[i]);</span></a>
<a name="1109"><span class="lineNum">    1109 </span>            :       }</a>
<a name="1110"><span class="lineNum">    1110 </span>            :     }</a>
<a name="1111"><span class="lineNum">    1111 </span>            :     //the height should be divided by sqrt(2*pi)*sigma0_,</a>
<a name="1112"><span class="lineNum">    1112 </span>            :     //but this overall factor would be canceled when dividing by Zed</a>
<a name="1113"><span class="lineNum">    1113 </span>            :     //thus we skip it altogether, but keep any other sigma rescaling</a>
<a name="1114"><span class="lineNum">    1114 </span><span class="lineCov">        756 :     for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1115"><span class="lineNum">    1115 </span><span class="lineCov">        499 :       height*=(sigma0_[i]/sigma[i]);</span></a>
<a name="1116"><span class="lineNum">    1116 </span>            : </a>
<a name="1117"><span class="lineNum">    1117 </span>            :     //get new kernel center</a>
<a name="1118"><span class="lineNum">    1118 </span><span class="lineCov">        257 :     std::vector&lt;double&gt; center(ncv_);</span></a>
<a name="1119"><span class="lineNum">    1119 </span><span class="lineCov">        756 :     for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1120"><span class="lineNum">    1120 </span><span class="lineCov">        499 :       center[i]=getArgument(i);</span></a>
<a name="1121"><span class="lineNum">    1121 </span>            : </a>
<a name="1122"><span class="lineNum">    1122 </span>            :     //add new kernel(s)</a>
<a name="1123"><span class="lineNum">    1123 </span><span class="lineCov">        257 :     if(NumWalkers_==1)</span></a>
<a name="1124"><span class="lineNum">    1124 </span><span class="lineCov">        131 :       addKernel(height,center,sigma,log_weight);</span></a>
<a name="1125"><span class="lineNum">    1125 </span>            :     else</a>
<a name="1126"><span class="lineNum">    1126 </span>            :     {</a>
<a name="1127"><span class="lineNum">    1127 </span><span class="lineCov">        126 :       std::vector&lt;double&gt; all_height(NumWalkers_,0.0);</span></a>
<a name="1128"><span class="lineNum">    1128 </span><span class="lineCov">        126 :       std::vector&lt;double&gt; all_center(NumWalkers_*ncv_,0.0);</span></a>
<a name="1129"><span class="lineNum">    1129 </span><span class="lineCov">        126 :       std::vector&lt;double&gt; all_sigma(NumWalkers_*ncv_,0.0);</span></a>
<a name="1130"><span class="lineNum">    1130 </span><span class="lineCov">        126 :       std::vector&lt;double&gt; all_logweight(NumWalkers_,0.0);</span></a>
<a name="1131"><span class="lineNum">    1131 </span><span class="lineCov">        126 :       if(comm.Get_rank()==0)</span></a>
<a name="1132"><span class="lineNum">    1132 </span>            :       {</a>
<a name="1133"><span class="lineNum">    1133 </span><span class="lineCov">        126 :         multi_sim_comm.Allgather(height,all_height);</span></a>
<a name="1134"><span class="lineNum">    1134 </span><span class="lineCov">        126 :         multi_sim_comm.Allgather(center,all_center);</span></a>
<a name="1135"><span class="lineNum">    1135 </span><span class="lineCov">        126 :         multi_sim_comm.Allgather(sigma,all_sigma);</span></a>
<a name="1136"><span class="lineNum">    1136 </span><span class="lineCov">        126 :         multi_sim_comm.Allgather(log_weight,all_logweight);</span></a>
<a name="1137"><span class="lineNum">    1137 </span>            :       }</a>
<a name="1138"><span class="lineNum">    1138 </span><span class="lineCov">        126 :       comm.Bcast(all_height,0);</span></a>
<a name="1139"><span class="lineNum">    1139 </span><span class="lineCov">        126 :       comm.Bcast(all_center,0);</span></a>
<a name="1140"><span class="lineNum">    1140 </span><span class="lineCov">        126 :       comm.Bcast(all_sigma,0);</span></a>
<a name="1141"><span class="lineNum">    1141 </span><span class="lineCov">        126 :       comm.Bcast(all_logweight,0);</span></a>
<a name="1142"><span class="lineNum">    1142 </span><span class="lineCov">        126 :       if(nlist_)</span></a>
<a name="1143"><span class="lineNum">    1143 </span>            :       { //gather all the nlist_index_, so merging can be done using it</a>
<a name="1144"><span class="lineNum">    1144 </span><span class="lineCov">         50 :         std::vector&lt;int&gt; all_nlist_size(NumWalkers_);</span></a>
<a name="1145"><span class="lineNum">    1145 </span><span class="lineCov">         50 :         if(comm.Get_rank()==0)</span></a>
<a name="1146"><span class="lineNum">    1146 </span>            :         {</a>
<a name="1147"><span class="lineNum">    1147 </span><span class="lineCov">         50 :           all_nlist_size[walker_rank_]=nlist_index_.size();</span></a>
<a name="1148"><span class="lineNum">    1148 </span><span class="lineCov">         50 :           multi_sim_comm.Sum(all_nlist_size);</span></a>
<a name="1149"><span class="lineNum">    1149 </span>            :         }</a>
<a name="1150"><span class="lineNum">    1150 </span><span class="lineCov">         50 :         comm.Bcast(all_nlist_size,0);</span></a>
<a name="1151"><span class="lineNum">    1151 </span>            :         unsigned tot_size=0;</a>
<a name="1152"><span class="lineNum">    1152 </span><span class="lineCov">        150 :         for(unsigned w=0; w&lt;NumWalkers_; w++)</span></a>
<a name="1153"><span class="lineNum">    1153 </span><span class="lineCov">        100 :           tot_size+=all_nlist_size[w];</span></a>
<a name="1154"><span class="lineNum">    1154 </span><span class="lineCov">         50 :         if(tot_size&gt;0)</span></a>
<a name="1155"><span class="lineNum">    1155 </span>            :         {</a>
<a name="1156"><span class="lineNum">    1156 </span><span class="lineCov">         50 :           std::vector&lt;int&gt; disp(NumWalkers_);</span></a>
<a name="1157"><span class="lineNum">    1157 </span><span class="lineCov">        100 :           for(unsigned w=0; w&lt;NumWalkers_-1; w++)</span></a>
<a name="1158"><span class="lineNum">    1158 </span><span class="lineCov">         50 :             disp[w+1]=disp[w]+all_nlist_size[w];</span></a>
<a name="1159"><span class="lineNum">    1159 </span><span class="lineCov">         50 :           std::vector&lt;unsigned&gt; all_nlist_index(tot_size);</span></a>
<a name="1160"><span class="lineNum">    1160 </span><span class="lineCov">         50 :           if(comm.Get_rank()==0)</span></a>
<a name="1161"><span class="lineNum">    1161 </span><span class="lineCov">         50 :             multi_sim_comm.Allgatherv(nlist_index_,all_nlist_index,&amp;all_nlist_size[0],&amp;disp[0]);</span></a>
<a name="1162"><span class="lineNum">    1162 </span><span class="lineCov">         50 :           comm.Bcast(all_nlist_index,0);</span></a>
<a name="1163"><span class="lineNum">    1163 </span><span class="lineCov">         50 :           std::set&lt;unsigned&gt; nlist_index_set(all_nlist_index.begin(),all_nlist_index.end()); //remove duplicates and sort</span></a>
<a name="1164"><span class="lineNum">    1164 </span><span class="lineCov">         50 :           nlist_index_.assign(nlist_index_set.begin(),nlist_index_set.end());</span></a>
<a name="1165"><span class="lineNum">    1165 </span>            :         }</a>
<a name="1166"><span class="lineNum">    1166 </span>            :       }</a>
<a name="1167"><span class="lineNum">    1167 </span><span class="lineCov">        378 :       for(unsigned w=0; w&lt;NumWalkers_; w++)</span></a>
<a name="1168"><span class="lineNum">    1168 </span>            :       {</a>
<a name="1169"><span class="lineNum">    1169 </span><span class="lineCov">        252 :         std::vector&lt;double&gt; center_w(all_center.begin()+ncv_*w,all_center.begin()+ncv_*(w+1));</span></a>
<a name="1170"><span class="lineNum">    1170 </span><span class="lineCov">        252 :         std::vector&lt;double&gt; sigma_w(all_sigma.begin()+ncv_*w,all_sigma.begin()+ncv_*(w+1));</span></a>
<a name="1171"><span class="lineNum">    1171 </span><span class="lineCov">        252 :         addKernel(all_height[w],center_w,sigma_w,all_logweight[w]);</span></a>
<a name="1172"><span class="lineNum">    1172 </span>            :       }</a>
<a name="1173"><span class="lineNum">    1173 </span>            :     }</a>
<a name="1174"><span class="lineNum">    1174 </span><span class="lineCov">        257 :     getPntrToComponent(&quot;nker&quot;)-&gt;set(kernels_.size());</span></a>
<a name="1175"><span class="lineNum">    1175 </span><span class="lineCov">        257 :     if(nlist_)</span></a>
<a name="1176"><span class="lineNum">    1176 </span>            :     {</a>
<a name="1177"><span class="lineNum">    1177 </span><span class="lineCov">        106 :       getPntrToComponent(&quot;nlker&quot;)-&gt;set(nlist_index_.size());</span></a>
<a name="1178"><span class="lineNum">    1178 </span><span class="lineCov">        106 :       if(nlist_pace_reset_)</span></a>
<a name="1179"><span class="lineNum">    1179 </span><span class="lineCov">         50 :         nlist_update_=true;</span></a>
<a name="1180"><span class="lineNum">    1180 </span>            :     }</a>
<a name="1181"><span class="lineNum">    1181 </span>            : </a>
<a name="1182"><span class="lineNum">    1182 </span>            :     //update Zed_</a>
<a name="1183"><span class="lineNum">    1183 </span><span class="lineCov">        257 :     if(!no_Zed_)</span></a>
<a name="1184"><span class="lineNum">    1184 </span>            :     {</a>
<a name="1185"><span class="lineNum">    1185 </span><span class="lineCov">        197 :       double sum_uprob=0;</span></a>
<a name="1186"><span class="lineNum">    1186 </span><span class="lineCov">        197 :       const unsigned ks=kernels_.size();</span></a>
<a name="1187"><span class="lineNum">    1187 </span><span class="lineCov">        197 :       const unsigned ds=delta_kernels_.size();</span></a>
<a name="1188"><span class="lineNum">    1188 </span><span class="lineCov">        197 :       const bool few_kernels=(ks*ks&lt;(3*ks*ds+2*ds*ds*NumParallel_+100)); //this seems reasonable, but is not rigorous...</span></a>
<a name="1189"><span class="lineNum">    1189 </span><span class="lineCov">        197 :       if(few_kernels) //really needed? Probably is almost always false</span></a>
<a name="1190"><span class="lineNum">    1190 </span>            :       {</a>
<a name="1191"><span class="lineNum">    1191 </span><span class="lineCov">        147 :         #pragma omp parallel num_threads(NumOMP_)</span></a>
<a name="1192"><span class="lineNum">    1192 </span>            :         {</a>
<a name="1193"><span class="lineNum">    1193 </span>            :           #pragma omp for reduction(+:sum_uprob) nowait</a>
<a name="1194"><span class="lineNum">    1194 </span>            :           for(unsigned k=rank_; k&lt;kernels_.size(); k+=NumParallel_)</a>
<a name="1195"><span class="lineNum">    1195 </span>            :             for(unsigned kk=0; kk&lt;kernels_.size(); kk++)</a>
<a name="1196"><span class="lineNum">    1196 </span>            :               sum_uprob+=evaluateKernel(kernels_[kk],kernels_[k].center);</a>
<a name="1197"><span class="lineNum">    1197 </span>            :         }</a>
<a name="1198"><span class="lineNum">    1198 </span><span class="lineCov">        147 :         if(NumParallel_&gt;1)</span></a>
<a name="1199"><span class="lineNum">    1199 </span><span class="lineCov">         50 :           comm.Sum(sum_uprob);</span></a>
<a name="1200"><span class="lineNum">    1200 </span>            :       }</a>
<a name="1201"><span class="lineNum">    1201 </span>            :       else</a>
<a name="1202"><span class="lineNum">    1202 </span>            :       {</a>
<a name="1203"><span class="lineNum">    1203 </span>            :         // Here instead of redoing the full summation, we add only the changes, knowing that</a>
<a name="1204"><span class="lineNum">    1204 </span>            :         // uprob = old_uprob + delta_uprob</a>
<a name="1205"><span class="lineNum">    1205 </span>            :         // and we also need to consider that in the new sum there are some novel centers and some disappeared ones</a>
<a name="1206"><span class="lineNum">    1206 </span><span class="lineCov">         50 :         double delta_sum_uprob=0;</span></a>
<a name="1207"><span class="lineNum">    1207 </span><span class="lineCov">         50 :         if(!nlist_)</span></a>
<a name="1208"><span class="lineNum">    1208 </span>            :         {</a>
<a name="1209"><span class="lineNum">    1209 </span><span class="lineNoCov">          0 :           #pragma omp parallel num_threads(NumOMP_)</span></a>
<a name="1210"><span class="lineNum">    1210 </span>            :           {</a>
<a name="1211"><span class="lineNum">    1211 </span>            :             #pragma omp for reduction(+:delta_sum_uprob) nowait</a>
<a name="1212"><span class="lineNum">    1212 </span>            :             for(unsigned k=rank_; k&lt;kernels_.size(); k+=NumParallel_)</a>
<a name="1213"><span class="lineNum">    1213 </span>            :             {</a>
<a name="1214"><span class="lineNum">    1214 </span>            :               for(unsigned d=0; d&lt;delta_kernels_.size(); d++)</a>
<a name="1215"><span class="lineNum">    1215 </span>            :               {</a>
<a name="1216"><span class="lineNum">    1216 </span>            :                 const double sign=delta_kernels_[d].height&lt;0?-1:1; //take away contribution from kernels that are gone, and add the one from new ones</a>
<a name="1217"><span class="lineNum">    1217 </span>            :                 delta_sum_uprob+=evaluateKernel(delta_kernels_[d],kernels_[k].center)+sign*evaluateKernel(kernels_[k],delta_kernels_[d].center);</a>
<a name="1218"><span class="lineNum">    1218 </span>            :               }</a>
<a name="1219"><span class="lineNum">    1219 </span>            :             }</a>
<a name="1220"><span class="lineNum">    1220 </span>            :           }</a>
<a name="1221"><span class="lineNum">    1221 </span>            :         }</a>
<a name="1222"><span class="lineNum">    1222 </span>            :         else</a>
<a name="1223"><span class="lineNum">    1223 </span>            :         {</a>
<a name="1224"><span class="lineNum">    1224 </span><span class="lineCov">         50 :           #pragma omp parallel num_threads(NumOMP_)</span></a>
<a name="1225"><span class="lineNum">    1225 </span>            :           {</a>
<a name="1226"><span class="lineNum">    1226 </span>            :             #pragma omp for reduction(+:delta_sum_uprob) nowait</a>
<a name="1227"><span class="lineNum">    1227 </span>            :             for(unsigned nk=rank_; nk&lt;nlist_index_.size(); nk+=NumParallel_)</a>
<a name="1228"><span class="lineNum">    1228 </span>            :             {</a>
<a name="1229"><span class="lineNum">    1229 </span>            :               const unsigned k=nlist_index_[nk];</a>
<a name="1230"><span class="lineNum">    1230 </span>            :               for(unsigned d=0; d&lt;delta_kernels_.size(); d++)</a>
<a name="1231"><span class="lineNum">    1231 </span>            :               {</a>
<a name="1232"><span class="lineNum">    1232 </span>            :                 const double sign=delta_kernels_[d].height&lt;0?-1:1; //take away contribution from kernels that are gone, and add the one from new ones</a>
<a name="1233"><span class="lineNum">    1233 </span>            :                 delta_sum_uprob+=evaluateKernel(delta_kernels_[d],kernels_[k].center)+sign*evaluateKernel(kernels_[k],delta_kernels_[d].center);</a>
<a name="1234"><span class="lineNum">    1234 </span>            :               }</a>
<a name="1235"><span class="lineNum">    1235 </span>            :             }</a>
<a name="1236"><span class="lineNum">    1236 </span>            :           }</a>
<a name="1237"><span class="lineNum">    1237 </span>            :         }</a>
<a name="1238"><span class="lineNum">    1238 </span><span class="lineCov">         50 :         if(NumParallel_&gt;1)</span></a>
<a name="1239"><span class="lineNum">    1239 </span><span class="lineNoCov">          0 :           comm.Sum(delta_sum_uprob);</span></a>
<a name="1240"><span class="lineNum">    1240 </span><span class="lineCov">         50 :         #pragma omp parallel num_threads(NumOMP_)</span></a>
<a name="1241"><span class="lineNum">    1241 </span>            :         {</a>
<a name="1242"><span class="lineNum">    1242 </span>            :           #pragma omp for reduction(+:delta_sum_uprob)</a>
<a name="1243"><span class="lineNum">    1243 </span>            :           for(unsigned d=0; d&lt;delta_kernels_.size(); d++)</a>
<a name="1244"><span class="lineNum">    1244 </span>            :           {</a>
<a name="1245"><span class="lineNum">    1245 </span>            :             for(unsigned dd=0; dd&lt;delta_kernels_.size(); dd++)</a>
<a name="1246"><span class="lineNum">    1246 </span>            :             { //now subtract the delta_uprob added before, but not needed</a>
<a name="1247"><span class="lineNum">    1247 </span>            :               const double sign=delta_kernels_[d].height&lt;0?-1:1;</a>
<a name="1248"><span class="lineNum">    1248 </span>            :               delta_sum_uprob-=sign*evaluateKernel(delta_kernels_[dd],delta_kernels_[d].center);</a>
<a name="1249"><span class="lineNum">    1249 </span>            :             }</a>
<a name="1250"><span class="lineNum">    1250 </span>            :           }</a>
<a name="1251"><span class="lineNum">    1251 </span>            :         }</a>
<a name="1252"><span class="lineNum">    1252 </span><span class="lineCov">         50 :         sum_uprob=Zed_*old_KDEnorm_*old_nker+delta_sum_uprob;</span></a>
<a name="1253"><span class="lineNum">    1253 </span>            :       }</a>
<a name="1254"><span class="lineNum">    1254 </span><span class="lineCov">        197 :       Zed_=sum_uprob/KDEnorm_/kernels_.size();</span></a>
<a name="1255"><span class="lineNum">    1255 </span><span class="lineCov">        394 :       getPntrToComponent(&quot;zed&quot;)-&gt;set(Zed_);</span></a>
<a name="1256"><span class="lineNum">    1256 </span>            :     }</a>
<a name="1257"><span class="lineNum">    1257 </span>            : </a>
<a name="1258"><span class="lineNum">    1258 </span>            :     //calculate work if requested</a>
<a name="1259"><span class="lineNum">    1259 </span><span class="lineCov">        257 :     if(calc_work_)</span></a>
<a name="1260"><span class="lineNum">    1260 </span>            :     {</a>
<a name="1261"><span class="lineNum">    1261 </span><span class="lineCov">         70 :       std::vector&lt;double&gt; dummy(ncv_); //derivatives are not actually needed</span></a>
<a name="1262"><span class="lineNum">    1262 </span><span class="lineCov">         70 :       const double prob=getProbAndDerivatives(center,dummy);</span></a>
<a name="1263"><span class="lineNum">    1263 </span><span class="lineCov">         70 :       const double new_bias=kbt_*bias_prefactor_*std::log(prob/Zed_+epsilon_);</span></a>
<a name="1264"><span class="lineNum">    1264 </span><span class="lineCov">         70 :       work_+=new_bias-getOutputQuantity(0);</span></a>
<a name="1265"><span class="lineNum">    1265 </span><span class="lineCov">        140 :       getPntrToComponent(&quot;work&quot;)-&gt;set(work_);</span></a>
<a name="1266"><span class="lineNum">    1266 </span>            :     }</a>
<a name="1267"><span class="lineNum">    1267 </span>            :   }</a>
<a name="1268"><span class="lineNum">    1268 </span>            : </a>
<a name="1269"><span class="lineNum">    1269 </span>            : //dump state if requested</a>
<a name="1270"><span class="lineNum">    1270 </span><span class="lineCov">       1005 :   if( (wStateStride_&gt;0 &amp;&amp; getStep()%wStateStride_==0) || (wStateStride_==-1 &amp;&amp; getCPT()) )</span></a>
<a name="1271"><span class="lineNum">    1271 </span><span class="lineCov">         18 :     dumpStateToFile();</span></a>
<a name="1272"><span class="lineNum">    1272 </span>            : }</a>
<a name="1273"><span class="lineNum">    1273 </span>            : </a>
<a name="1274"><span class="lineNum">    1274 </span>            : template &lt;class mode&gt;</a>
<a name="1275"><span class="lineNum">    1275 </span><span class="lineCov">       1141 : double OPESmetad&lt;mode&gt;::getProbAndDerivatives(const std::vector&lt;double&gt;&amp; cv,std::vector&lt;double&gt;&amp; der_prob)</span></a>
<a name="1276"><span class="lineNum">    1276 </span>            : {</a>
<a name="1277"><span class="lineNum">    1277 </span><span class="lineCov">       1141 :   double prob=0.0;</span></a>
<a name="1278"><span class="lineNum">    1278 </span><span class="lineCov">       1141 :   if(!nlist_)</span></a>
<a name="1279"><span class="lineNum">    1279 </span>            :   {</a>
<a name="1280"><span class="lineNum">    1280 </span><span class="lineCov">        886 :     if(NumOMP_==1 || (unsigned)kernels_.size()&lt;2*NumOMP_*NumParallel_)</span></a>
<a name="1281"><span class="lineNum">    1281 </span>            :     {</a>
<a name="1282"><span class="lineNum">    1282 </span>            :       // for performances and thread safety</a>
<a name="1283"><span class="lineNum">    1283 </span><span class="lineCov">        707 :       std::vector&lt;double&gt; dist(ncv_);</span></a>
<a name="1284"><span class="lineNum">    1284 </span><span class="lineCov">       2647 :       for(unsigned k=rank_; k&lt;kernels_.size(); k+=NumParallel_)</span></a>
<a name="1285"><span class="lineNum">    1285 </span><span class="lineCov">       1940 :         prob+=evaluateKernel(kernels_[k],cv,der_prob,dist);</span></a>
<a name="1286"><span class="lineNum">    1286 </span>            :     }</a>
<a name="1287"><span class="lineNum">    1287 </span>            :     else</a>
<a name="1288"><span class="lineNum">    1288 </span>            :     {</a>
<a name="1289"><span class="lineNum">    1289 </span><span class="lineCov">        179 :       #pragma omp parallel num_threads(NumOMP_)</span></a>
<a name="1290"><span class="lineNum">    1290 </span>            :       {</a>
<a name="1291"><span class="lineNum">    1291 </span>            :         std::vector&lt;double&gt; omp_deriv(der_prob.size(),0.);</a>
<a name="1292"><span class="lineNum">    1292 </span>            :         // for performances and thread safety</a>
<a name="1293"><span class="lineNum">    1293 </span>            :         std::vector&lt;double&gt; dist(ncv_);</a>
<a name="1294"><span class="lineNum">    1294 </span>            :         #pragma omp for reduction(+:prob) nowait</a>
<a name="1295"><span class="lineNum">    1295 </span>            :         for(unsigned k=rank_; k&lt;kernels_.size(); k+=NumParallel_)</a>
<a name="1296"><span class="lineNum">    1296 </span>            :           prob+=evaluateKernel(kernels_[k],cv,omp_deriv,dist);</a>
<a name="1297"><span class="lineNum">    1297 </span>            :         #pragma omp critical</a>
<a name="1298"><span class="lineNum">    1298 </span>            :         for(unsigned i=0; i&lt;ncv_; i++)</a>
<a name="1299"><span class="lineNum">    1299 </span>            :           der_prob[i]+=omp_deriv[i];</a>
<a name="1300"><span class="lineNum">    1300 </span>            :       }</a>
<a name="1301"><span class="lineNum">    1301 </span>            :     }</a>
<a name="1302"><span class="lineNum">    1302 </span>            :   }</a>
<a name="1303"><span class="lineNum">    1303 </span>            :   else</a>
<a name="1304"><span class="lineNum">    1304 </span>            :   {</a>
<a name="1305"><span class="lineNum">    1305 </span><span class="lineCov">        255 :     if(NumOMP_==1 || (unsigned)nlist_index_.size()&lt;2*NumOMP_*NumParallel_)</span></a>
<a name="1306"><span class="lineNum">    1306 </span>            :     {</a>
<a name="1307"><span class="lineNum">    1307 </span>            :       // for performances and thread safety</a>
<a name="1308"><span class="lineNum">    1308 </span><span class="lineCov">        230 :       std::vector&lt;double&gt; dist(ncv_);</span></a>
<a name="1309"><span class="lineNum">    1309 </span><span class="lineCov">        660 :       for(unsigned nk=rank_; nk&lt;nlist_index_.size(); nk+=NumParallel_)</span></a>
<a name="1310"><span class="lineNum">    1310 </span><span class="lineCov">        430 :         prob+=evaluateKernel(kernels_[nlist_index_[nk]],cv,der_prob,dist);</span></a>
<a name="1311"><span class="lineNum">    1311 </span>            :     }</a>
<a name="1312"><span class="lineNum">    1312 </span>            :     else</a>
<a name="1313"><span class="lineNum">    1313 </span>            :     {</a>
<a name="1314"><span class="lineNum">    1314 </span><span class="lineCov">         25 :       #pragma omp parallel num_threads(NumOMP_)</span></a>
<a name="1315"><span class="lineNum">    1315 </span>            :       {</a>
<a name="1316"><span class="lineNum">    1316 </span>            :         std::vector&lt;double&gt; omp_deriv(der_prob.size(),0.);</a>
<a name="1317"><span class="lineNum">    1317 </span>            :         // for performances and thread safety</a>
<a name="1318"><span class="lineNum">    1318 </span>            :         std::vector&lt;double&gt; dist(ncv_);</a>
<a name="1319"><span class="lineNum">    1319 </span>            :         #pragma omp for reduction(+:prob) nowait</a>
<a name="1320"><span class="lineNum">    1320 </span>            :         for(unsigned nk=rank_; nk&lt;nlist_index_.size(); nk+=NumParallel_)</a>
<a name="1321"><span class="lineNum">    1321 </span>            :           prob+=evaluateKernel(kernels_[nlist_index_[nk]],cv,omp_deriv,dist);</a>
<a name="1322"><span class="lineNum">    1322 </span>            :         #pragma omp critical</a>
<a name="1323"><span class="lineNum">    1323 </span>            :         for(unsigned i=0; i&lt;ncv_; i++)</a>
<a name="1324"><span class="lineNum">    1324 </span>            :           der_prob[i]+=omp_deriv[i];</a>
<a name="1325"><span class="lineNum">    1325 </span>            :       }</a>
<a name="1326"><span class="lineNum">    1326 </span>            :     }</a>
<a name="1327"><span class="lineNum">    1327 </span>            :   }</a>
<a name="1328"><span class="lineNum">    1328 </span><span class="lineCov">       1141 :   if(NumParallel_&gt;1)</span></a>
<a name="1329"><span class="lineNum">    1329 </span>            :   {</a>
<a name="1330"><span class="lineNum">    1330 </span><span class="lineCov">        224 :     comm.Sum(prob);</span></a>
<a name="1331"><span class="lineNum">    1331 </span><span class="lineCov">        224 :     comm.Sum(der_prob);</span></a>
<a name="1332"><span class="lineNum">    1332 </span>            :   }</a>
<a name="1333"><span class="lineNum">    1333 </span>            : //normalize the estimate</a>
<a name="1334"><span class="lineNum">    1334 </span><span class="lineCov">       1141 :   prob/=KDEnorm_;</span></a>
<a name="1335"><span class="lineNum">    1335 </span><span class="lineCov">       3311 :   for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1336"><span class="lineNum">    1336 </span><span class="lineCov">       2170 :     der_prob[i]/=KDEnorm_;</span></a>
<a name="1337"><span class="lineNum">    1337 </span>            : </a>
<a name="1338"><span class="lineNum">    1338 </span><span class="lineCov">       1141 :   return prob;</span></a>
<a name="1339"><span class="lineNum">    1339 </span>            : }</a>
<a name="1340"><span class="lineNum">    1340 </span>            : </a>
<a name="1341"><span class="lineNum">    1341 </span>            : template &lt;class mode&gt;</a>
<a name="1342"><span class="lineNum">    1342 </span><span class="lineCov">        513 : void OPESmetad&lt;mode&gt;::addKernel(const double height,const std::vector&lt;double&gt;&amp; center,const std::vector&lt;double&gt;&amp; sigma)</span></a>
<a name="1343"><span class="lineNum">    1343 </span>            : {</a>
<a name="1344"><span class="lineNum">    1344 </span>            :   bool no_match=true;</a>
<a name="1345"><span class="lineNum">    1345 </span><span class="lineCov">        513 :   if(threshold2_!=0)</span></a>
<a name="1346"><span class="lineNum">    1346 </span>            :   {</a>
<a name="1347"><span class="lineNum">    1347 </span><span class="lineCov">        513 :     unsigned taker_k=getMergeableKernel(center,kernels_.size());</span></a>
<a name="1348"><span class="lineNum">    1348 </span><span class="lineCov">        513 :     if(taker_k&lt;kernels_.size())</span></a>
<a name="1349"><span class="lineNum">    1349 </span>            :     {</a>
<a name="1350"><span class="lineNum">    1350 </span>            :       no_match=false;</a>
<a name="1351"><span class="lineNum">    1351 </span><span class="lineCov">        388 :       delta_kernels_.emplace_back(-1*kernels_[taker_k].height,kernels_[taker_k].center,kernels_[taker_k].sigma);</span></a>
<a name="1352"><span class="lineNum">    1352 </span><span class="lineCov">        776 :       mergeKernels(kernels_[taker_k],kernel(height,center,sigma));</span></a>
<a name="1353"><span class="lineNum">    1353 </span><span class="lineCov">        388 :       delta_kernels_.push_back(kernels_[taker_k]);</span></a>
<a name="1354"><span class="lineNum">    1354 </span><span class="lineCov">        388 :       if(recursive_merge_) //the overhead is worth it if it keeps low the total number of kernels</span></a>
<a name="1355"><span class="lineNum">    1355 </span>            :       {</a>
<a name="1356"><span class="lineNum">    1356 </span>            :         unsigned giver_k=taker_k;</a>
<a name="1357"><span class="lineNum">    1357 </span><span class="lineCov">        337 :         taker_k=getMergeableKernel(kernels_[giver_k].center,giver_k);</span></a>
<a name="1358"><span class="lineNum">    1358 </span><span class="lineCov">        337 :         while(taker_k&lt;kernels_.size())</span></a>
<a name="1359"><span class="lineNum">    1359 </span>            :         {</a>
<a name="1360"><span class="lineNum">    1360 </span><span class="lineNoCov">          0 :           delta_kernels_.pop_back();</span></a>
<a name="1361"><span class="lineNum">    1361 </span><span class="lineNoCov">          0 :           delta_kernels_.emplace_back(-1*kernels_[taker_k].height,kernels_[taker_k].center,kernels_[taker_k].sigma);</span></a>
<a name="1362"><span class="lineNum">    1362 </span><span class="lineNoCov">          0 :           if(taker_k&gt;giver_k) //saves time when erasing</span></a>
<a name="1363"><span class="lineNum">    1363 </span>            :             std::swap(taker_k,giver_k);</a>
<a name="1364"><span class="lineNum">    1364 </span><span class="lineNoCov">          0 :           mergeKernels(kernels_[taker_k],kernels_[giver_k]);</span></a>
<a name="1365"><span class="lineNum">    1365 </span><span class="lineNoCov">          0 :           delta_kernels_.push_back(kernels_[taker_k]);</span></a>
<a name="1366"><span class="lineNum">    1366 </span><span class="lineNoCov">          0 :           kernels_.erase(kernels_.begin()+giver_k);</span></a>
<a name="1367"><span class="lineNum">    1367 </span><span class="lineNoCov">          0 :           if(nlist_)</span></a>
<a name="1368"><span class="lineNum">    1368 </span>            :           {</a>
<a name="1369"><span class="lineNum">    1369 </span>            :             unsigned giver_nk=0;</a>
<a name="1370"><span class="lineNum">    1370 </span>            :             bool found_giver=false;</a>
<a name="1371"><span class="lineNum">    1371 </span><span class="lineNoCov">          0 :             for(unsigned nk=0; nk&lt;nlist_index_.size(); nk++)</span></a>
<a name="1372"><span class="lineNum">    1372 </span>            :             {</a>
<a name="1373"><span class="lineNum">    1373 </span><span class="lineNoCov">          0 :               if(found_giver)</span></a>
<a name="1374"><span class="lineNum">    1374 </span><span class="lineNoCov">          0 :                 nlist_index_[nk]--; //all the indexes shift due to erase</span></a>
<a name="1375"><span class="lineNum">    1375 </span><span class="lineNoCov">          0 :               if(nlist_index_[nk]==giver_k)</span></a>
<a name="1376"><span class="lineNum">    1376 </span>            :               {</a>
<a name="1377"><span class="lineNum">    1377 </span>            :                 giver_nk=nk;</a>
<a name="1378"><span class="lineNum">    1378 </span>            :                 found_giver=true;</a>
<a name="1379"><span class="lineNum">    1379 </span>            :               }</a>
<a name="1380"><span class="lineNum">    1380 </span>            :             }</a>
<a name="1381"><span class="lineNum">    1381 </span>            :             plumed_dbg_massert(found_giver,&quot;problem with merging and NLIST&quot;);</a>
<a name="1382"><span class="lineNum">    1382 </span><span class="lineNoCov">          0 :             nlist_index_.erase(nlist_index_.begin()+giver_nk);</span></a>
<a name="1383"><span class="lineNum">    1383 </span>            :           }</a>
<a name="1384"><span class="lineNum">    1384 </span>            :           giver_k=taker_k;</a>
<a name="1385"><span class="lineNum">    1385 </span><span class="lineNoCov">          0 :           taker_k=getMergeableKernel(kernels_[giver_k].center,giver_k);</span></a>
<a name="1386"><span class="lineNum">    1386 </span>            :         }</a>
<a name="1387"><span class="lineNum">    1387 </span>            :       }</a>
<a name="1388"><span class="lineNum">    1388 </span>            :     }</a>
<a name="1389"><span class="lineNum">    1389 </span>            :   }</a>
<a name="1390"><span class="lineNum">    1390 </span>            :   if(no_match)</a>
<a name="1391"><span class="lineNum">    1391 </span>            :   {</a>
<a name="1392"><span class="lineNum">    1392 </span><span class="lineCov">        125 :     kernels_.emplace_back(height,center,sigma);</span></a>
<a name="1393"><span class="lineNum">    1393 </span><span class="lineCov">        125 :     delta_kernels_.emplace_back(height,center,sigma);</span></a>
<a name="1394"><span class="lineNum">    1394 </span><span class="lineCov">        125 :     if(nlist_)</span></a>
<a name="1395"><span class="lineNum">    1395 </span><span class="lineCov">         12 :       nlist_index_.push_back(kernels_.size()-1);</span></a>
<a name="1396"><span class="lineNum">    1396 </span>            :   }</a>
<a name="1397"><span class="lineNum">    1397 </span><span class="lineCov">        513 : }</span></a>
<a name="1398"><span class="lineNum">    1398 </span>            : </a>
<a name="1399"><span class="lineNum">    1399 </span>            : template &lt;class mode&gt;</a>
<a name="1400"><span class="lineNum">    1400 </span><span class="lineCov">        383 : void OPESmetad&lt;mode&gt;::addKernel(const double height,const std::vector&lt;double&gt;&amp; center,const std::vector&lt;double&gt;&amp; sigma,const double logweight)</span></a>
<a name="1401"><span class="lineNum">    1401 </span>            : {</a>
<a name="1402"><span class="lineNum">    1402 </span><span class="lineCov">        383 :   addKernel(height,center,sigma);</span></a>
<a name="1403"><span class="lineNum">    1403 </span>            : //write to file</a>
<a name="1404"><span class="lineNum">    1404 </span><span class="lineCov">        383 :   kernelsOfile_.printField(&quot;time&quot;,getTime());</span></a>
<a name="1405"><span class="lineNum">    1405 </span><span class="lineCov">       1134 :   for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1406"><span class="lineNum">    1406 </span><span class="lineCov">        751 :     kernelsOfile_.printField(getPntrToArgument(i),center[i]);</span></a>
<a name="1407"><span class="lineNum">    1407 </span><span class="lineCov">       1134 :   for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1408"><span class="lineNum">    1408 </span><span class="lineCov">       1502 :     kernelsOfile_.printField(&quot;sigma_&quot;+getPntrToArgument(i)-&gt;getName(),sigma[i]);</span></a>
<a name="1409"><span class="lineNum">    1409 </span><span class="lineCov">        383 :   kernelsOfile_.printField(&quot;height&quot;,height);</span></a>
<a name="1410"><span class="lineNum">    1410 </span><span class="lineCov">        383 :   kernelsOfile_.printField(&quot;logweight&quot;,logweight);</span></a>
<a name="1411"><span class="lineNum">    1411 </span><span class="lineCov">        383 :   kernelsOfile_.printField();</span></a>
<a name="1412"><span class="lineNum">    1412 </span><span class="lineCov">        383 : }</span></a>
<a name="1413"><span class="lineNum">    1413 </span>            : </a>
<a name="1414"><span class="lineNum">    1414 </span>            : template &lt;class mode&gt;</a>
<a name="1415"><span class="lineNum">    1415 </span><span class="lineCov">        850 : unsigned OPESmetad&lt;mode&gt;::getMergeableKernel(const std::vector&lt;double&gt;&amp; giver_center,const unsigned giver_k)</span></a>
<a name="1416"><span class="lineNum">    1416 </span>            : { //returns kernels_.size() if no match is found</a>
<a name="1417"><span class="lineNum">    1417 </span><span class="lineCov">        850 :   unsigned min_k=kernels_.size();</span></a>
<a name="1418"><span class="lineNum">    1418 </span><span class="lineCov">        850 :   double min_norm2=threshold2_;</span></a>
<a name="1419"><span class="lineNum">    1419 </span><span class="lineCov">        850 :   if(!nlist_)</span></a>
<a name="1420"><span class="lineNum">    1420 </span>            :   {</a>
<a name="1421"><span class="lineNum">    1421 </span><span class="lineCov">        550 :     #pragma omp parallel num_threads(NumOMP_)</span></a>
<a name="1422"><span class="lineNum">    1422 </span>            :     {</a>
<a name="1423"><span class="lineNum">    1423 </span>            :       unsigned min_k_omp = min_k;</a>
<a name="1424"><span class="lineNum">    1424 </span>            :       double min_norm2_omp = threshold2_;</a>
<a name="1425"><span class="lineNum">    1425 </span>            :       #pragma omp for nowait</a>
<a name="1426"><span class="lineNum">    1426 </span>            :       for(unsigned k=rank_; k&lt;kernels_.size(); k+=NumParallel_)</a>
<a name="1427"><span class="lineNum">    1427 </span>            :       {</a>
<a name="1428"><span class="lineNum">    1428 </span>            :         if(k==giver_k) //a kernel should not be merged with itself</a>
<a name="1429"><span class="lineNum">    1429 </span>            :           continue;</a>
<a name="1430"><span class="lineNum">    1430 </span>            :         double norm2=0;</a>
<a name="1431"><span class="lineNum">    1431 </span>            :         for(unsigned i=0; i&lt;ncv_; i++)</a>
<a name="1432"><span class="lineNum">    1432 </span>            :         {</a>
<a name="1433"><span class="lineNum">    1433 </span>            :           const double dist_i=difference(i,giver_center[i],kernels_[k].center[i])/kernels_[k].sigma[i];</a>
<a name="1434"><span class="lineNum">    1434 </span>            :           norm2+=dist_i*dist_i;</a>
<a name="1435"><span class="lineNum">    1435 </span>            :           if(norm2&gt;=min_norm2_omp)</a>
<a name="1436"><span class="lineNum">    1436 </span>            :             break;</a>
<a name="1437"><span class="lineNum">    1437 </span>            :         }</a>
<a name="1438"><span class="lineNum">    1438 </span>            :         if(norm2&lt;min_norm2_omp)</a>
<a name="1439"><span class="lineNum">    1439 </span>            :         {</a>
<a name="1440"><span class="lineNum">    1440 </span>            :           min_norm2_omp=norm2;</a>
<a name="1441"><span class="lineNum">    1441 </span>            :           min_k_omp=k;</a>
<a name="1442"><span class="lineNum">    1442 </span>            :         }</a>
<a name="1443"><span class="lineNum">    1443 </span>            :       }</a>
<a name="1444"><span class="lineNum">    1444 </span>            :       #pragma omp critical</a>
<a name="1445"><span class="lineNum">    1445 </span>            :       {</a>
<a name="1446"><span class="lineNum">    1446 </span>            :         if(min_norm2_omp &lt; min_norm2)</a>
<a name="1447"><span class="lineNum">    1447 </span>            :         {</a>
<a name="1448"><span class="lineNum">    1448 </span>            :           min_norm2 = min_norm2_omp;</a>
<a name="1449"><span class="lineNum">    1449 </span>            :           min_k = min_k_omp;</a>
<a name="1450"><span class="lineNum">    1450 </span>            :         }</a>
<a name="1451"><span class="lineNum">    1451 </span>            :       }</a>
<a name="1452"><span class="lineNum">    1452 </span>            :     }</a>
<a name="1453"><span class="lineNum">    1453 </span>            :   }</a>
<a name="1454"><span class="lineNum">    1454 </span>            :   else</a>
<a name="1455"><span class="lineNum">    1455 </span>            :   {</a>
<a name="1456"><span class="lineNum">    1456 </span><span class="lineCov">        300 :     #pragma omp parallel num_threads(NumOMP_)</span></a>
<a name="1457"><span class="lineNum">    1457 </span>            :     {</a>
<a name="1458"><span class="lineNum">    1458 </span>            :       unsigned min_k_omp = min_k;</a>
<a name="1459"><span class="lineNum">    1459 </span>            :       double min_norm2_omp = threshold2_;</a>
<a name="1460"><span class="lineNum">    1460 </span>            :       #pragma omp for nowait</a>
<a name="1461"><span class="lineNum">    1461 </span>            :       for(unsigned nk=rank_; nk&lt;nlist_index_.size(); nk+=NumParallel_)</a>
<a name="1462"><span class="lineNum">    1462 </span>            :       {</a>
<a name="1463"><span class="lineNum">    1463 </span>            :         const unsigned k=nlist_index_[nk];</a>
<a name="1464"><span class="lineNum">    1464 </span>            :         if(k==giver_k) //a kernel should not be merged with itself</a>
<a name="1465"><span class="lineNum">    1465 </span>            :           continue;</a>
<a name="1466"><span class="lineNum">    1466 </span>            :         double norm2=0;</a>
<a name="1467"><span class="lineNum">    1467 </span>            :         for(unsigned i=0; i&lt;ncv_; i++)</a>
<a name="1468"><span class="lineNum">    1468 </span>            :         {</a>
<a name="1469"><span class="lineNum">    1469 </span>            :           const double dist_i=difference(i,giver_center[i],kernels_[k].center[i])/kernels_[k].sigma[i];</a>
<a name="1470"><span class="lineNum">    1470 </span>            :           norm2+=dist_i*dist_i;</a>
<a name="1471"><span class="lineNum">    1471 </span>            :           if(norm2&gt;=min_norm2)</a>
<a name="1472"><span class="lineNum">    1472 </span>            :             break;</a>
<a name="1473"><span class="lineNum">    1473 </span>            :         }</a>
<a name="1474"><span class="lineNum">    1474 </span>            :         if(norm2&lt;min_norm2_omp)</a>
<a name="1475"><span class="lineNum">    1475 </span>            :         {</a>
<a name="1476"><span class="lineNum">    1476 </span>            :           min_norm2_omp=norm2;</a>
<a name="1477"><span class="lineNum">    1477 </span>            :           min_k_omp=k;</a>
<a name="1478"><span class="lineNum">    1478 </span>            :         }</a>
<a name="1479"><span class="lineNum">    1479 </span>            :       }</a>
<a name="1480"><span class="lineNum">    1480 </span>            :       #pragma omp critical</a>
<a name="1481"><span class="lineNum">    1481 </span>            :       {</a>
<a name="1482"><span class="lineNum">    1482 </span>            :         if(min_norm2_omp &lt; min_norm2)</a>
<a name="1483"><span class="lineNum">    1483 </span>            :         {</a>
<a name="1484"><span class="lineNum">    1484 </span>            :           min_norm2 = min_norm2_omp;</a>
<a name="1485"><span class="lineNum">    1485 </span>            :           min_k = min_k_omp;</a>
<a name="1486"><span class="lineNum">    1486 </span>            :         }</a>
<a name="1487"><span class="lineNum">    1487 </span>            :       }</a>
<a name="1488"><span class="lineNum">    1488 </span>            :     }</a>
<a name="1489"><span class="lineNum">    1489 </span>            :   }</a>
<a name="1490"><span class="lineNum">    1490 </span><span class="lineCov">        850 :   if(NumParallel_&gt;1)</span></a>
<a name="1491"><span class="lineNum">    1491 </span>            :   {</a>
<a name="1492"><span class="lineNum">    1492 </span><span class="lineCov">        134 :     std::vector&lt;double&gt; all_min_norm2(NumParallel_);</span></a>
<a name="1493"><span class="lineNum">    1493 </span><span class="lineCov">        134 :     std::vector&lt;unsigned&gt; all_min_k(NumParallel_);</span></a>
<a name="1494"><span class="lineNum">    1494 </span><span class="lineCov">        134 :     comm.Allgather(min_norm2,all_min_norm2);</span></a>
<a name="1495"><span class="lineNum">    1495 </span><span class="lineCov">        134 :     comm.Allgather(min_k,all_min_k);</span></a>
<a name="1496"><span class="lineNum">    1496 </span>            :     const unsigned best=std::distance(std::begin(all_min_norm2),std::min_element(std::begin(all_min_norm2),std::end(all_min_norm2)));</a>
<a name="1497"><span class="lineNum">    1497 </span><span class="lineCov">        134 :     min_k=all_min_k[best];</span></a>
<a name="1498"><span class="lineNum">    1498 </span>            :   }</a>
<a name="1499"><span class="lineNum">    1499 </span><span class="lineCov">        850 :   return min_k;</span></a>
<a name="1500"><span class="lineNum">    1500 </span>            : }</a>
<a name="1501"><span class="lineNum">    1501 </span>            : </a>
<a name="1502"><span class="lineNum">    1502 </span>            : template &lt;class mode&gt;</a>
<a name="1503"><span class="lineNum">    1503 </span><span class="lineCov">        250 : void OPESmetad&lt;mode&gt;::updateNlist(const std::vector&lt;double&gt;&amp; new_center)</span></a>
<a name="1504"><span class="lineNum">    1504 </span>            : {</a>
<a name="1505"><span class="lineNum">    1505 </span><span class="lineCov">        250 :   if(kernels_.size()==0) //no need to check for neighbors</span></a>
<a name="1506"><span class="lineNum">    1506 </span><span class="lineCov">          6 :     return;</span></a>
<a name="1507"><span class="lineNum">    1507 </span>            : </a>
<a name="1508"><span class="lineNum">    1508 </span><span class="lineCov">        244 :   nlist_center_=new_center;</span></a>
<a name="1509"><span class="lineNum">    1509 </span><span class="lineCov">        244 :   nlist_index_.clear();</span></a>
<a name="1510"><span class="lineNum">    1510 </span>            :   //first we gather all the nlist_index</a>
<a name="1511"><span class="lineNum">    1511 </span><span class="lineCov">        244 :   if(NumOMP_==1 || (unsigned)kernels_.size()&lt;2*NumOMP_*NumParallel_)</span></a>
<a name="1512"><span class="lineNum">    1512 </span>            :   {</a>
<a name="1513"><span class="lineNum">    1513 </span><span class="lineCov">        198 :     for(unsigned k=rank_; k&lt;kernels_.size(); k+=NumParallel_)</span></a>
<a name="1514"><span class="lineNum">    1514 </span>            :     {</a>
<a name="1515"><span class="lineNum">    1515 </span>            :       double norm2_k=0;</a>
<a name="1516"><span class="lineNum">    1516 </span><span class="lineCov">        444 :       for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1517"><span class="lineNum">    1517 </span>            :       {</a>
<a name="1518"><span class="lineNum">    1518 </span><span class="lineCov">        296 :         const double dist_ik=difference(i,nlist_center_[i],kernels_[k].center[i])/kernels_[k].sigma[i];</span></a>
<a name="1519"><span class="lineNum">    1519 </span><span class="lineCov">        296 :         norm2_k+=dist_ik*dist_ik;</span></a>
<a name="1520"><span class="lineNum">    1520 </span>            :       }</a>
<a name="1521"><span class="lineNum">    1521 </span><span class="lineCov">        148 :       if(norm2_k&lt;=nlist_param_[0]*cutoff2_)</span></a>
<a name="1522"><span class="lineNum">    1522 </span><span class="lineCov">        104 :         nlist_index_.push_back(k);</span></a>
<a name="1523"><span class="lineNum">    1523 </span>            :     }</a>
<a name="1524"><span class="lineNum">    1524 </span>            :   }</a>
<a name="1525"><span class="lineNum">    1525 </span>            :   else</a>
<a name="1526"><span class="lineNum">    1526 </span>            :   {</a>
<a name="1527"><span class="lineNum">    1527 </span><span class="lineCov">        194 :     #pragma omp parallel num_threads(NumOMP_)</span></a>
<a name="1528"><span class="lineNum">    1528 </span>            :     {</a>
<a name="1529"><span class="lineNum">    1529 </span>            :       std::vector&lt;unsigned&gt; private_nlist_index;</a>
<a name="1530"><span class="lineNum">    1530 </span>            :       #pragma omp for nowait</a>
<a name="1531"><span class="lineNum">    1531 </span>            :       for(unsigned k=rank_; k&lt;kernels_.size(); k+=NumParallel_)</a>
<a name="1532"><span class="lineNum">    1532 </span>            :       {</a>
<a name="1533"><span class="lineNum">    1533 </span>            :         double norm2_k=0;</a>
<a name="1534"><span class="lineNum">    1534 </span>            :         for(unsigned i=0; i&lt;ncv_; i++)</a>
<a name="1535"><span class="lineNum">    1535 </span>            :         {</a>
<a name="1536"><span class="lineNum">    1536 </span>            :           const double dist_ik=difference(i,nlist_center_[i],kernels_[k].center[i])/kernels_[k].sigma[i];</a>
<a name="1537"><span class="lineNum">    1537 </span>            :           norm2_k+=dist_ik*dist_ik;</a>
<a name="1538"><span class="lineNum">    1538 </span>            :         }</a>
<a name="1539"><span class="lineNum">    1539 </span>            :         if(norm2_k&lt;=nlist_param_[0]*cutoff2_)</a>
<a name="1540"><span class="lineNum">    1540 </span>            :           private_nlist_index.push_back(k);</a>
<a name="1541"><span class="lineNum">    1541 </span>            :       }</a>
<a name="1542"><span class="lineNum">    1542 </span>            :       #pragma omp critical</a>
<a name="1543"><span class="lineNum">    1543 </span>            :       nlist_index_.insert(nlist_index_.end(),private_nlist_index.begin(),private_nlist_index.end());</a>
<a name="1544"><span class="lineNum">    1544 </span>            :     }</a>
<a name="1545"><span class="lineNum">    1545 </span><span class="lineCov">        194 :     if(recursive_merge_)</span></a>
<a name="1546"><span class="lineNum">    1546 </span><span class="lineCov">        194 :       std::sort(nlist_index_.begin(),nlist_index_.end());</span></a>
<a name="1547"><span class="lineNum">    1547 </span>            :   }</a>
<a name="1548"><span class="lineNum">    1548 </span><span class="lineCov">        244 :   if(NumParallel_&gt;1)</span></a>
<a name="1549"><span class="lineNum">    1549 </span>            :   {</a>
<a name="1550"><span class="lineNum">    1550 </span><span class="lineCov">        100 :     std::vector&lt;int&gt; all_nlist_size(NumParallel_);</span></a>
<a name="1551"><span class="lineNum">    1551 </span><span class="lineCov">        100 :     all_nlist_size[rank_]=nlist_index_.size();</span></a>
<a name="1552"><span class="lineNum">    1552 </span><span class="lineCov">        100 :     comm.Sum(all_nlist_size);</span></a>
<a name="1553"><span class="lineNum">    1553 </span>            :     unsigned tot_size=0;</a>
<a name="1554"><span class="lineNum">    1554 </span><span class="lineCov">        300 :     for(unsigned r=0; r&lt;NumParallel_; r++)</span></a>
<a name="1555"><span class="lineNum">    1555 </span><span class="lineCov">        200 :       tot_size+=all_nlist_size[r];</span></a>
<a name="1556"><span class="lineNum">    1556 </span><span class="lineCov">        100 :     if(tot_size&gt;0)</span></a>
<a name="1557"><span class="lineNum">    1557 </span>            :     {</a>
<a name="1558"><span class="lineNum">    1558 </span><span class="lineCov">        100 :       std::vector&lt;int&gt; disp(NumParallel_);</span></a>
<a name="1559"><span class="lineNum">    1559 </span><span class="lineCov">        200 :       for(unsigned r=0; r&lt;NumParallel_-1; r++)</span></a>
<a name="1560"><span class="lineNum">    1560 </span><span class="lineCov">        100 :         disp[r+1]=disp[r]+all_nlist_size[r];</span></a>
<a name="1561"><span class="lineNum">    1561 </span><span class="lineCov">        100 :       std::vector&lt;unsigned&gt; local_nlist_index=nlist_index_;</span></a>
<a name="1562"><span class="lineNum">    1562 </span><span class="lineCov">        100 :       nlist_index_.resize(tot_size);</span></a>
<a name="1563"><span class="lineNum">    1563 </span><span class="lineCov">        100 :       comm.Allgatherv(local_nlist_index,nlist_index_,&amp;all_nlist_size[0],&amp;disp[0]);</span></a>
<a name="1564"><span class="lineNum">    1564 </span><span class="lineCov">        100 :       if(recursive_merge_)</span></a>
<a name="1565"><span class="lineNum">    1565 </span><span class="lineCov">        100 :         std::sort(nlist_index_.begin(),nlist_index_.end());</span></a>
<a name="1566"><span class="lineNum">    1566 </span>            :     }</a>
<a name="1567"><span class="lineNum">    1567 </span>            :   }</a>
<a name="1568"><span class="lineNum">    1568 </span>            :   //calculate the square deviation</a>
<a name="1569"><span class="lineNum">    1569 </span><span class="lineCov">        244 :   std::vector&lt;double&gt; dev2(ncv_,0.);</span></a>
<a name="1570"><span class="lineNum">    1570 </span><span class="lineCov">        773 :   for(unsigned k=rank_; k&lt;nlist_index_.size(); k+=NumParallel_)</span></a>
<a name="1571"><span class="lineNum">    1571 </span>            :   {</a>
<a name="1572"><span class="lineNum">    1572 </span><span class="lineCov">       1587 :     for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1573"><span class="lineNum">    1573 </span>            :     {</a>
<a name="1574"><span class="lineNum">    1574 </span><span class="lineCov">       1058 :       const double diff_ik=difference(i,nlist_center_[i],kernels_[nlist_index_[k]].center[i]);</span></a>
<a name="1575"><span class="lineNum">    1575 </span><span class="lineCov">       1058 :       dev2[i]+=diff_ik*diff_ik;</span></a>
<a name="1576"><span class="lineNum">    1576 </span>            :     }</a>
<a name="1577"><span class="lineNum">    1577 </span>            :   }</a>
<a name="1578"><span class="lineNum">    1578 </span><span class="lineCov">        244 :   if(NumParallel_&gt;1)</span></a>
<a name="1579"><span class="lineNum">    1579 </span><span class="lineCov">        100 :     comm.Sum(dev2);</span></a>
<a name="1580"><span class="lineNum">    1580 </span><span class="lineCov">        732 :   for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1581"><span class="lineNum">    1581 </span>            :   {</a>
<a name="1582"><span class="lineNum">    1582 </span><span class="lineCov">        488 :     if(dev2[i]==0) //e.g. if nlist_index_.size()==0</span></a>
<a name="1583"><span class="lineNum">    1583 </span><span class="lineCov">         56 :       nlist_dev2_[i]=std::pow(kernels_.back().sigma[i],2);</span></a>
<a name="1584"><span class="lineNum">    1584 </span>            :     else</a>
<a name="1585"><span class="lineNum">    1585 </span><span class="lineCov">        432 :       nlist_dev2_[i]=dev2[i]/nlist_index_.size();</span></a>
<a name="1586"><span class="lineNum">    1586 </span>            :   }</a>
<a name="1587"><span class="lineNum">    1587 </span><span class="lineCov">        244 :   getPntrToComponent(&quot;nlker&quot;)-&gt;set(nlist_index_.size());</span></a>
<a name="1588"><span class="lineNum">    1588 </span><span class="lineCov">        244 :   getPntrToComponent(&quot;nlsteps&quot;)-&gt;set(nlist_steps_);</span></a>
<a name="1589"><span class="lineNum">    1589 </span><span class="lineCov">        244 :   nlist_steps_=0;</span></a>
<a name="1590"><span class="lineNum">    1590 </span><span class="lineCov">        244 :   nlist_update_=false;</span></a>
<a name="1591"><span class="lineNum">    1591 </span>            : }</a>
<a name="1592"><span class="lineNum">    1592 </span>            : </a>
<a name="1593"><span class="lineNum">    1593 </span>            : template &lt;class mode&gt;</a>
<a name="1594"><span class="lineNum">    1594 </span><span class="lineCov">         18 : void OPESmetad&lt;mode&gt;::dumpStateToFile()</span></a>
<a name="1595"><span class="lineNum">    1595 </span>            : {</a>
<a name="1596"><span class="lineNum">    1596 </span>            : //gather adaptive sigma info if needed</a>
<a name="1597"><span class="lineNum">    1597 </span>            : //doing this while writing to file can lead to misterious slowdowns</a>
<a name="1598"><span class="lineNum">    1598 </span>            :   std::vector&lt;double&gt; all_sigma0;</a>
<a name="1599"><span class="lineNum">    1599 </span>            :   std::vector&lt;double&gt; all_av_cv;</a>
<a name="1600"><span class="lineNum">    1600 </span>            :   std::vector&lt;double&gt; all_av_M2;</a>
<a name="1601"><span class="lineNum">    1601 </span><span class="lineCov">         18 :   if(adaptive_sigma_ &amp;&amp; NumWalkers_&gt;1)</span></a>
<a name="1602"><span class="lineNum">    1602 </span>            :   {</a>
<a name="1603"><span class="lineNum">    1603 </span><span class="lineCov">         16 :     all_sigma0.resize(NumWalkers_*ncv_);</span></a>
<a name="1604"><span class="lineNum">    1604 </span><span class="lineCov">         16 :     all_av_cv.resize(NumWalkers_*ncv_);</span></a>
<a name="1605"><span class="lineNum">    1605 </span><span class="lineCov">         16 :     all_av_M2.resize(NumWalkers_*ncv_);</span></a>
<a name="1606"><span class="lineNum">    1606 </span><span class="lineCov">         16 :     if(comm.Get_rank()==0)</span></a>
<a name="1607"><span class="lineNum">    1607 </span>            :     {</a>
<a name="1608"><span class="lineNum">    1608 </span><span class="lineCov">         16 :       multi_sim_comm.Allgather(sigma0_,all_sigma0);</span></a>
<a name="1609"><span class="lineNum">    1609 </span><span class="lineCov">         16 :       multi_sim_comm.Allgather(av_cv_,all_av_cv);</span></a>
<a name="1610"><span class="lineNum">    1610 </span><span class="lineCov">         16 :       multi_sim_comm.Allgather(av_M2_,all_av_M2);</span></a>
<a name="1611"><span class="lineNum">    1611 </span>            :     }</a>
<a name="1612"><span class="lineNum">    1612 </span><span class="lineCov">         16 :     comm.Bcast(all_sigma0,0);</span></a>
<a name="1613"><span class="lineNum">    1613 </span><span class="lineCov">         16 :     comm.Bcast(all_av_cv,0);</span></a>
<a name="1614"><span class="lineNum">    1614 </span><span class="lineCov">         16 :     comm.Bcast(all_av_M2,0);</span></a>
<a name="1615"><span class="lineNum">    1615 </span>            :   }</a>
<a name="1616"><span class="lineNum">    1616 </span>            : </a>
<a name="1617"><span class="lineNum">    1617 </span>            : //rewrite header or rewind file</a>
<a name="1618"><span class="lineNum">    1618 </span><span class="lineCov">         18 :   if(storeOldStates_)</span></a>
<a name="1619"><span class="lineNum">    1619 </span><span class="lineCov">         16 :     stateOfile_.clearFields();</span></a>
<a name="1620"><span class="lineNum">    1620 </span><span class="lineCov">          2 :   else if(walker_rank_==0)</span></a>
<a name="1621"><span class="lineNum">    1621 </span><span class="lineCov">          2 :     stateOfile_.rewind();</span></a>
<a name="1622"><span class="lineNum">    1622 </span>            : //define fields</a>
<a name="1623"><span class="lineNum">    1623 </span><span class="lineCov">         18 :   stateOfile_.addConstantField(&quot;action&quot;);</span></a>
<a name="1624"><span class="lineNum">    1624 </span><span class="lineCov">         18 :   stateOfile_.addConstantField(&quot;biasfactor&quot;);</span></a>
<a name="1625"><span class="lineNum">    1625 </span><span class="lineCov">         18 :   stateOfile_.addConstantField(&quot;epsilon&quot;);</span></a>
<a name="1626"><span class="lineNum">    1626 </span><span class="lineCov">         18 :   stateOfile_.addConstantField(&quot;kernel_cutoff&quot;);</span></a>
<a name="1627"><span class="lineNum">    1627 </span><span class="lineCov">         18 :   stateOfile_.addConstantField(&quot;compression_threshold&quot;);</span></a>
<a name="1628"><span class="lineNum">    1628 </span><span class="lineCov">         18 :   stateOfile_.addConstantField(&quot;zed&quot;);</span></a>
<a name="1629"><span class="lineNum">    1629 </span><span class="lineCov">         18 :   stateOfile_.addConstantField(&quot;sum_weights&quot;);</span></a>
<a name="1630"><span class="lineNum">    1630 </span><span class="lineCov">         18 :   stateOfile_.addConstantField(&quot;sum_weights2&quot;);</span></a>
<a name="1631"><span class="lineNum">    1631 </span><span class="lineCov">         18 :   stateOfile_.addConstantField(&quot;counter&quot;);</span></a>
<a name="1632"><span class="lineNum">    1632 </span><span class="lineCov">         18 :   if(adaptive_sigma_)</span></a>
<a name="1633"><span class="lineNum">    1633 </span>            :   {</a>
<a name="1634"><span class="lineNum">    1634 </span><span class="lineCov">         18 :     stateOfile_.addConstantField(&quot;adaptive_counter&quot;);</span></a>
<a name="1635"><span class="lineNum">    1635 </span><span class="lineCov">         18 :     if(NumWalkers_==1)</span></a>
<a name="1636"><span class="lineNum">    1636 </span>            :     {</a>
<a name="1637"><span class="lineNum">    1637 </span><span class="lineCov">          6 :       for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1638"><span class="lineNum">    1638 </span>            :       {</a>
<a name="1639"><span class="lineNum">    1639 </span><span class="lineCov">          8 :         stateOfile_.addConstantField(&quot;sigma0_&quot;+getPntrToArgument(i)-&gt;getName());</span></a>
<a name="1640"><span class="lineNum">    1640 </span><span class="lineCov">          8 :         stateOfile_.addConstantField(&quot;av_cv_&quot;+getPntrToArgument(i)-&gt;getName());</span></a>
<a name="1641"><span class="lineNum">    1641 </span><span class="lineCov">          8 :         stateOfile_.addConstantField(&quot;av_M2_&quot;+getPntrToArgument(i)-&gt;getName());</span></a>
<a name="1642"><span class="lineNum">    1642 </span>            :       }</a>
<a name="1643"><span class="lineNum">    1643 </span>            :     }</a>
<a name="1644"><span class="lineNum">    1644 </span>            :     else</a>
<a name="1645"><span class="lineNum">    1645 </span>            :     {</a>
<a name="1646"><span class="lineNum">    1646 </span><span class="lineCov">         48 :       for(unsigned w=0; w&lt;NumWalkers_; w++)</span></a>
<a name="1647"><span class="lineNum">    1647 </span><span class="lineCov">         96 :         for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1648"><span class="lineNum">    1648 </span>            :         {</a>
<a name="1649"><span class="lineNum">    1649 </span><span class="lineCov">        128 :           const std::string arg_iw=getPntrToArgument(i)-&gt;getName()+&quot;_&quot;+std::to_string(w);</span></a>
<a name="1650"><span class="lineNum">    1650 </span><span class="lineCov">         64 :           stateOfile_.addConstantField(&quot;sigma0_&quot;+arg_iw);</span></a>
<a name="1651"><span class="lineNum">    1651 </span><span class="lineCov">         64 :           stateOfile_.addConstantField(&quot;av_cv_&quot;+arg_iw);</span></a>
<a name="1652"><span class="lineNum">    1652 </span><span class="lineCov">        128 :           stateOfile_.addConstantField(&quot;av_M2_&quot;+arg_iw);</span></a>
<a name="1653"><span class="lineNum">    1653 </span>            :         }</a>
<a name="1654"><span class="lineNum">    1654 </span>            :     }</a>
<a name="1655"><span class="lineNum">    1655 </span>            :   }</a>
<a name="1656"><span class="lineNum">    1656 </span>            : //print fields</a>
<a name="1657"><span class="lineNum">    1657 </span><span class="lineCov">         54 :   for(unsigned i=0; i&lt;ncv_; i++) //periodicity of CVs</span></a>
<a name="1658"><span class="lineNum">    1658 </span><span class="lineCov">         36 :     stateOfile_.setupPrintValue(getPntrToArgument(i));</span></a>
<a name="1659"><span class="lineNum">    1659 </span><span class="lineCov">         36 :   stateOfile_.printField(&quot;action&quot;,getName()+&quot;_state&quot;);</span></a>
<a name="1660"><span class="lineNum">    1660 </span><span class="lineCov">         18 :   stateOfile_.printField(&quot;biasfactor&quot;,biasfactor_);</span></a>
<a name="1661"><span class="lineNum">    1661 </span><span class="lineCov">         18 :   stateOfile_.printField(&quot;epsilon&quot;,epsilon_);</span></a>
<a name="1662"><span class="lineNum">    1662 </span><span class="lineCov">         18 :   stateOfile_.printField(&quot;kernel_cutoff&quot;,sqrt(cutoff2_));</span></a>
<a name="1663"><span class="lineNum">    1663 </span><span class="lineCov">         18 :   stateOfile_.printField(&quot;compression_threshold&quot;,sqrt(threshold2_));</span></a>
<a name="1664"><span class="lineNum">    1664 </span><span class="lineCov">         18 :   stateOfile_.printField(&quot;zed&quot;,Zed_);</span></a>
<a name="1665"><span class="lineNum">    1665 </span><span class="lineCov">         18 :   stateOfile_.printField(&quot;sum_weights&quot;,sum_weights_);</span></a>
<a name="1666"><span class="lineNum">    1666 </span><span class="lineCov">         18 :   stateOfile_.printField(&quot;sum_weights2&quot;,sum_weights2_);</span></a>
<a name="1667"><span class="lineNum">    1667 </span><span class="lineCov">         18 :   stateOfile_.printField(&quot;counter&quot;,counter_);</span></a>
<a name="1668"><span class="lineNum">    1668 </span><span class="lineCov">         18 :   if(adaptive_sigma_)</span></a>
<a name="1669"><span class="lineNum">    1669 </span>            :   {</a>
<a name="1670"><span class="lineNum">    1670 </span><span class="lineCov">         18 :     stateOfile_.printField(&quot;adaptive_counter&quot;,adaptive_counter_);</span></a>
<a name="1671"><span class="lineNum">    1671 </span><span class="lineCov">         18 :     if(NumWalkers_==1)</span></a>
<a name="1672"><span class="lineNum">    1672 </span>            :     {</a>
<a name="1673"><span class="lineNum">    1673 </span><span class="lineCov">          6 :       for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1674"><span class="lineNum">    1674 </span>            :       {</a>
<a name="1675"><span class="lineNum">    1675 </span><span class="lineCov">          8 :         stateOfile_.printField(&quot;sigma0_&quot;+getPntrToArgument(i)-&gt;getName(),sigma0_[i]);</span></a>
<a name="1676"><span class="lineNum">    1676 </span><span class="lineCov">          8 :         stateOfile_.printField(&quot;av_cv_&quot;+getPntrToArgument(i)-&gt;getName(),av_cv_[i]);</span></a>
<a name="1677"><span class="lineNum">    1677 </span><span class="lineCov">          8 :         stateOfile_.printField(&quot;av_M2_&quot;+getPntrToArgument(i)-&gt;getName(),av_M2_[i]);</span></a>
<a name="1678"><span class="lineNum">    1678 </span>            :       }</a>
<a name="1679"><span class="lineNum">    1679 </span>            :     }</a>
<a name="1680"><span class="lineNum">    1680 </span>            :     else</a>
<a name="1681"><span class="lineNum">    1681 </span>            :     {</a>
<a name="1682"><span class="lineNum">    1682 </span><span class="lineCov">         48 :       for(unsigned w=0; w&lt;NumWalkers_; w++)</span></a>
<a name="1683"><span class="lineNum">    1683 </span><span class="lineCov">         96 :         for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1684"><span class="lineNum">    1684 </span>            :         {</a>
<a name="1685"><span class="lineNum">    1685 </span><span class="lineCov">        128 :           const std::string arg_iw=getPntrToArgument(i)-&gt;getName()+&quot;_&quot;+std::to_string(w);</span></a>
<a name="1686"><span class="lineNum">    1686 </span><span class="lineCov">         64 :           stateOfile_.printField(&quot;sigma0_&quot;+arg_iw,all_sigma0[w*ncv_+i]);</span></a>
<a name="1687"><span class="lineNum">    1687 </span><span class="lineCov">         64 :           stateOfile_.printField(&quot;av_cv_&quot;+arg_iw,all_av_cv[w*ncv_+i]);</span></a>
<a name="1688"><span class="lineNum">    1688 </span><span class="lineCov">        128 :           stateOfile_.printField(&quot;av_M2_&quot;+arg_iw,all_av_M2[w*ncv_+i]);</span></a>
<a name="1689"><span class="lineNum">    1689 </span>            :         }</a>
<a name="1690"><span class="lineNum">    1690 </span>            :     }</a>
<a name="1691"><span class="lineNum">    1691 </span>            :   }</a>
<a name="1692"><span class="lineNum">    1692 </span>            : //print kernels</a>
<a name="1693"><span class="lineNum">    1693 </span><span class="lineCov">         82 :   for(unsigned k=0; k&lt;kernels_.size(); k++)</span></a>
<a name="1694"><span class="lineNum">    1694 </span>            :   {</a>
<a name="1695"><span class="lineNum">    1695 </span><span class="lineCov">         64 :     stateOfile_.printField(&quot;time&quot;,getTime()); //this is not very usefull</span></a>
<a name="1696"><span class="lineNum">    1696 </span><span class="lineCov">        192 :     for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1697"><span class="lineNum">    1697 </span><span class="lineCov">        128 :       stateOfile_.printField(getPntrToArgument(i),kernels_[k].center[i]);</span></a>
<a name="1698"><span class="lineNum">    1698 </span><span class="lineCov">        192 :     for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1699"><span class="lineNum">    1699 </span><span class="lineCov">        256 :       stateOfile_.printField(&quot;sigma_&quot;+getPntrToArgument(i)-&gt;getName(),kernels_[k].sigma[i]);</span></a>
<a name="1700"><span class="lineNum">    1700 </span><span class="lineCov">         64 :     stateOfile_.printField(&quot;height&quot;,kernels_[k].height);</span></a>
<a name="1701"><span class="lineNum">    1701 </span><span class="lineCov">         64 :     stateOfile_.printField();</span></a>
<a name="1702"><span class="lineNum">    1702 </span>            :   }</a>
<a name="1703"><span class="lineNum">    1703 </span>            : //make sure file is written even if small</a>
<a name="1704"><span class="lineNum">    1704 </span><span class="lineCov">         18 :   if(!storeOldStates_)</span></a>
<a name="1705"><span class="lineNum">    1705 </span><span class="lineCov">          2 :     stateOfile_.flush();</span></a>
<a name="1706"><span class="lineNum">    1706 </span><span class="lineCov">         18 : }</span></a>
<a name="1707"><span class="lineNum">    1707 </span>            : </a>
<a name="1708"><span class="lineNum">    1708 </span>            : template &lt;class mode&gt;</a>
<a name="1709"><span class="lineNum">    1709 </span><span class="lineCov">       5969 : inline double OPESmetad&lt;mode&gt;::evaluateKernel(const kernel&amp; G,const std::vector&lt;double&gt;&amp; x) const</span></a>
<a name="1710"><span class="lineNum">    1710 </span>            : { //NB: cannot be a method of kernel class, because uses external variables (for cutoff)</a>
<a name="1711"><span class="lineNum">    1711 </span>            :   double norm2=0;</a>
<a name="1712"><span class="lineNum">    1712 </span><span class="lineCov">      13923 :   for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1713"><span class="lineNum">    1713 </span>            :   {</a>
<a name="1714"><span class="lineNum">    1714 </span><span class="lineCov">      10288 :     const double dist_i=difference(i,G.center[i],x[i])/G.sigma[i];</span></a>
<a name="1715"><span class="lineNum">    1715 </span><span class="lineCov">      10288 :     norm2+=dist_i*dist_i;</span></a>
<a name="1716"><span class="lineNum">    1716 </span><span class="lineCov">      10288 :     if(norm2&gt;=cutoff2_)</span></a>
<a name="1717"><span class="lineNum">    1717 </span>            :       return 0;</a>
<a name="1718"><span class="lineNum">    1718 </span>            :   }</a>
<a name="1719"><span class="lineNum">    1719 </span><span class="lineCov">       3635 :   return G.height*(std::exp(-0.5*norm2)-val_at_cutoff_);</span></a>
<a name="1720"><span class="lineNum">    1720 </span>            : }</a>
<a name="1721"><span class="lineNum">    1721 </span>            : </a>
<a name="1722"><span class="lineNum">    1722 </span>            : template &lt;class mode&gt;</a>
<a name="1723"><span class="lineNum">    1723 </span><span class="lineCov">       3364 : inline double OPESmetad&lt;mode&gt;::evaluateKernel(const kernel&amp; G,const std::vector&lt;double&gt;&amp; x, std::vector&lt;double&gt;&amp; acc_der, std::vector&lt;double&gt;&amp; dist)</span></a>
<a name="1724"><span class="lineNum">    1724 </span>            : { //NB: cannot be a method of kernel class, because uses external variables (for cutoff)</a>
<a name="1725"><span class="lineNum">    1725 </span>            :   double norm2=0;</a>
<a name="1726"><span class="lineNum">    1726 </span><span class="lineCov">       7483 :   for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1727"><span class="lineNum">    1727 </span>            :   {</a>
<a name="1728"><span class="lineNum">    1728 </span><span class="lineCov">       5578 :     dist[i]=difference(i,G.center[i],x[i])/G.sigma[i];</span></a>
<a name="1729"><span class="lineNum">    1729 </span><span class="lineCov">       5578 :     norm2+=dist[i]*dist[i];</span></a>
<a name="1730"><span class="lineNum">    1730 </span><span class="lineCov">       5578 :     if(norm2&gt;=cutoff2_)</span></a>
<a name="1731"><span class="lineNum">    1731 </span>            :       return 0;</a>
<a name="1732"><span class="lineNum">    1732 </span>            :   }</a>
<a name="1733"><span class="lineNum">    1733 </span><span class="lineCov">       1905 :   const double val=G.height*(std::exp(-0.5*norm2)-val_at_cutoff_);</span></a>
<a name="1734"><span class="lineNum">    1734 </span><span class="lineCov">       5576 :   for(unsigned i=0; i&lt;ncv_; i++)</span></a>
<a name="1735"><span class="lineNum">    1735 </span><span class="lineCov">       3671 :     acc_der[i]-=dist[i]/G.sigma[i]*val; //NB: we accumulate the derivative into der</span></a>
<a name="1736"><span class="lineNum">    1736 </span>            :   return val;</a>
<a name="1737"><span class="lineNum">    1737 </span>            : }</a>
<a name="1738"><span class="lineNum">    1738 </span>            : </a>
<a name="1739"><span class="lineNum">    1739 </span>            : template &lt;class mode&gt;</a>
<a name="1740"><span class="lineNum">    1740 </span><span class="lineCov">        388 : inline void OPESmetad&lt;mode&gt;::mergeKernels(kernel&amp; k1,const kernel&amp; k2)</span></a>
<a name="1741"><span class="lineNum">    1741 </span>            : {</a>
<a name="1742"><span class="lineNum">    1742 </span><span class="lineCov">        388 :   const double h=k1.height+k2.height;</span></a>
<a name="1743"><span class="lineNum">    1743 </span><span class="lineCov">       1159 :   for(unsigned i=0; i&lt;k1.center.size(); i++)</span></a>
<a name="1744"><span class="lineNum">    1744 </span>            :   {</a>
<a name="1745"><span class="lineNum">    1745 </span><span class="lineCov">        771 :     const bool isPeriodic_i=getPntrToArgument(i)-&gt;isPeriodic();</span></a>
<a name="1746"><span class="lineNum">    1746 </span><span class="lineCov">        771 :     if(isPeriodic_i)</span></a>
<a name="1747"><span class="lineNum">    1747 </span><span class="lineCov">        771 :       k1.center[i]=k2.center[i]+difference(i,k2.center[i],k1.center[i]); //fix PBC</span></a>
<a name="1748"><span class="lineNum">    1748 </span><span class="lineCov">        771 :     const double c_i=(k1.height*k1.center[i]+k2.height*k2.center[i])/h;</span></a>
<a name="1749"><span class="lineNum">    1749 </span><span class="lineCov">        771 :     const double ss_k1_part=k1.height*(k1.sigma[i]*k1.sigma[i]+k1.center[i]*k1.center[i]);</span></a>
<a name="1750"><span class="lineNum">    1750 </span><span class="lineCov">        771 :     const double ss_k2_part=k2.height*(k2.sigma[i]*k2.sigma[i]+k2.center[i]*k2.center[i]);</span></a>
<a name="1751"><span class="lineNum">    1751 </span><span class="lineCov">        771 :     const double ss_i=(ss_k1_part+ss_k2_part)/h-c_i*c_i;</span></a>
<a name="1752"><span class="lineNum">    1752 </span><span class="lineCov">        771 :     if(isPeriodic_i)</span></a>
<a name="1753"><span class="lineNum">    1753 </span><span class="lineCov">        771 :       k1.center[i]=bringBackInPbc(i,c_i);</span></a>
<a name="1754"><span class="lineNum">    1754 </span>            :     else</a>
<a name="1755"><span class="lineNum">    1755 </span><span class="lineNoCov">          0 :       k1.center[i]=c_i;</span></a>
<a name="1756"><span class="lineNum">    1756 </span><span class="lineCov">        771 :     k1.sigma[i]=sqrt(ss_i);</span></a>
<a name="1757"><span class="lineNum">    1757 </span>            :   }</a>
<a name="1758"><span class="lineNum">    1758 </span><span class="lineCov">        388 :   k1.height=h;</span></a>
<a name="1759"><span class="lineNum">    1759 </span><span class="lineCov">        388 : }</span></a>
<a name="1760"><span class="lineNum">    1760 </span>            : </a>
<a name="1761"><span class="lineNum">    1761 </span>            : }</a>
<a name="1762"><span class="lineNum">    1762 </span>            : }</a>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="https://github.com/linux-test-project/lcov" target="_parent">LCOV version 1.16</a></td></tr>
  </table>
  <br>

</body>
</html>
