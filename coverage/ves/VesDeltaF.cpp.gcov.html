<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - plumed test coverage - ves/VesDeltaF.cpp</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">ves</a> - VesDeltaF.cpp<span style="font-size: 80%;"> (source / <a href="VesDeltaF.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">plumed test coverage</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">346</td>
            <td class="headerCovTableEntry">356</td>
            <td class="headerCovTableEntryHi">97.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2024-10-18 14:29:08</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">10</td>
            <td class="headerCovTableEntry">11</td>
            <td class="headerCovTableEntryHi">90.9 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</a>
<a name="2"><span class="lineNum">       2 </span>            :    Copyright (c) 2016-2021 The VES code team</a>
<a name="3"><span class="lineNum">       3 </span>            :    (see the PEOPLE-VES file at the root of this folder for a list of names)</a>
<a name="4"><span class="lineNum">       4 </span>            : </a>
<a name="5"><span class="lineNum">       5 </span>            :    See http://www.ves-code.org for more information.</a>
<a name="6"><span class="lineNum">       6 </span>            : </a>
<a name="7"><span class="lineNum">       7 </span>            :    This file is part of VES code module.</a>
<a name="8"><span class="lineNum">       8 </span>            : </a>
<a name="9"><span class="lineNum">       9 </span>            :    The VES code module is free software: you can redistribute it and/or modify</a>
<a name="10"><span class="lineNum">      10 </span>            :    it under the terms of the GNU Lesser General Public License as published by</a>
<a name="11"><span class="lineNum">      11 </span>            :    the Free Software Foundation, either version 3 of the License, or</a>
<a name="12"><span class="lineNum">      12 </span>            :    (at your option) any later version.</a>
<a name="13"><span class="lineNum">      13 </span>            : </a>
<a name="14"><span class="lineNum">      14 </span>            :    The VES code module is distributed in the hope that it will be useful,</a>
<a name="15"><span class="lineNum">      15 </span>            :    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="16"><span class="lineNum">      16 </span>            :    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="17"><span class="lineNum">      17 </span>            :    GNU Lesser General Public License for more details.</a>
<a name="18"><span class="lineNum">      18 </span>            : </a>
<a name="19"><span class="lineNum">      19 </span>            :    You should have received a copy of the GNU Lesser General Public License</a>
<a name="20"><span class="lineNum">      20 </span>            :    along with the VES code module.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="21"><span class="lineNum">      21 </span>            : +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */</a>
<a name="22"><span class="lineNum">      22 </span>            : </a>
<a name="23"><span class="lineNum">      23 </span>            : #include &quot;bias/Bias.h&quot;</a>
<a name="24"><span class="lineNum">      24 </span>            : #include &quot;core/PlumedMain.h&quot;</a>
<a name="25"><span class="lineNum">      25 </span>            : #include &quot;core/ActionRegister.h&quot;</a>
<a name="26"><span class="lineNum">      26 </span>            : #include &quot;core/Atoms.h&quot;</a>
<a name="27"><span class="lineNum">      27 </span>            : #include &quot;tools/Communicator.h&quot;</a>
<a name="28"><span class="lineNum">      28 </span>            : #include &quot;tools/Grid.h&quot;</a>
<a name="29"><span class="lineNum">      29 </span>            : #include &quot;tools/File.h&quot;</a>
<a name="30"><span class="lineNum">      30 </span>            : //#include &lt;algorithm&gt; //std::fill</a>
<a name="31"><span class="lineNum">      31 </span>            : </a>
<a name="32"><span class="lineNum">      32 </span>            : namespace PLMD {</a>
<a name="33"><span class="lineNum">      33 </span>            : namespace ves {</a>
<a name="34"><span class="lineNum">      34 </span>            : </a>
<a name="35"><span class="lineNum">      35 </span>            : //+PLUMEDOC VES_BIAS VES_DELTA_F</a>
<a name="36"><span class="lineNum">      36 </span>            : /*</a>
<a name="37"><span class="lineNum">      37 </span>            : Implementation of VES Delta F method</a>
<a name="38"><span class="lineNum">      38 </span>            : </a>
<a name="39"><span class="lineNum">      39 </span>            : Implementation of VES\f$\Delta F\f$ method \cite Invernizzi2019vesdeltaf (step two only).</a>
<a name="40"><span class="lineNum">      40 </span>            : </a>
<a name="41"><span class="lineNum">      41 </span>            : \warning</a>
<a name="42"><span class="lineNum">      42 </span>            :   Notice that this is a stand-alone bias Action, it does not need any of the other VES module components</a>
<a name="43"><span class="lineNum">      43 </span>            : </a>
<a name="44"><span class="lineNum">      44 </span>            : First you should create some estimate of the local free energy basins of your system,</a>
<a name="45"><span class="lineNum">      45 </span>            : using e.g. multiple \ref METAD short runs, and combining them with the \ref sum_hills utility.</a>
<a name="46"><span class="lineNum">      46 </span>            : Once you have them, you can use this bias Action to perform the VES optimization part of the method.</a>
<a name="47"><span class="lineNum">      47 </span>            : </a>
<a name="48"><span class="lineNum">      48 </span>            : These \f$N+1\f$ local basins are used to model the global free energy.</a>
<a name="49"><span class="lineNum">      49 </span>            : In particular, given the conditional probabilities \f$P(\mathbf{s}|i)\propto e^{-\beta F_i(\mathbf{s})}\f$</a>
<a name="50"><span class="lineNum">      50 </span>            : and the probabilities of being in a given basin \f$P_i\f$, we can write:</a>
<a name="51"><span class="lineNum">      51 </span>            : \f[</a>
<a name="52"><span class="lineNum">      52 </span>            :   e^{-\beta F(\mathbf{s})}\propto P(\mathbf{s})=\sum_{i=0}^N P(\mathbf{s}|i)P_i \, .</a>
<a name="53"><span class="lineNum">      53 </span>            : \f]</a>
<a name="54"><span class="lineNum">      54 </span>            : We use this free energy model and the chosen bias factor \f$\gamma\f$ to build the bias potential:</a>
<a name="55"><span class="lineNum">      55 </span>            : \f$V(\mathbf{s})=-(1-1/\gamma)F(\mathbf{s})\f$.</a>
<a name="56"><span class="lineNum">      56 </span>            : Or, more explicitly:</a>
<a name="57"><span class="lineNum">      57 </span>            : \f[</a>
<a name="58"><span class="lineNum">      58 </span>            :   V(\mathbf{s})=(1-1/\gamma)\frac{1}{\beta}\log\left[e^{-\beta F_0(\mathbf{s})}</a>
<a name="59"><span class="lineNum">      59 </span>            :   +\sum_{i=1}^{N} e^{-\beta F_i(\mathbf{s})} e^{-\beta \alpha_i}\right] \, ,</a>
<a name="60"><span class="lineNum">      60 </span>            : \f]</a>
<a name="61"><span class="lineNum">      61 </span>            : where the parameters \f$\boldsymbol{\alpha}\f$ are the \f$N\f$ free energy differences (see below) from the \f$F_0\f$ basin.</a>
<a name="62"><span class="lineNum">      62 </span>            : </a>
<a name="63"><span class="lineNum">      63 </span>            : By default the \f$F_i(\mathbf{s})\f$ are shifted so that \f$\min[F_i(\mathbf{s})]=0\f$ for all \f$i=\{0,...,N\}\f$.</a>
<a name="64"><span class="lineNum">      64 </span>            : In this case the optimization parameters \f$\alpha_i\f$ are the difference in height between the minima of the basins.</a>
<a name="65"><span class="lineNum">      65 </span>            : Using the keyword `NORMALIZE`, you can also decide to normalize the local free energies so that</a>
<a name="66"><span class="lineNum">      66 </span>            : \f$\int d\mathbf{s}\, e^{-\beta F_i(\mathbf{s})}=1\f$.</a>
<a name="67"><span class="lineNum">      67 </span>            : In this case the parameters will represent not the difference in height (which depends on the chosen CVs),</a>
<a name="68"><span class="lineNum">      68 </span>            : but the actual free energy difference, \f$\alpha_i=\Delta F_i\f$.</a>
<a name="69"><span class="lineNum">      69 </span>            : </a>
<a name="70"><span class="lineNum">      70 </span>            : However, as discussed in Ref. \cite Invernizzi2019vesdeltaf, a better estimate of \f$\Delta F_i\f$ should be obtained through the reweighting procedure.</a>
<a name="71"><span class="lineNum">      71 </span>            : </a>
<a name="72"><span class="lineNum">      72 </span>            : \par Examples</a>
<a name="73"><span class="lineNum">      73 </span>            : </a>
<a name="74"><span class="lineNum">      74 </span>            : The following performs the optimization of the free energy difference between two metastable basins:</a>
<a name="75"><span class="lineNum">      75 </span>            : </a>
<a name="76"><span class="lineNum">      76 </span>            : \plumedfile</a>
<a name="77"><span class="lineNum">      77 </span>            : cv: DISTANCE ATOMS=1,2</a>
<a name="78"><span class="lineNum">      78 </span>            : ves: VES_DELTA_F ...</a>
<a name="79"><span class="lineNum">      79 </span>            :   ARG=cv</a>
<a name="80"><span class="lineNum">      80 </span>            :   TEMP=300</a>
<a name="81"><span class="lineNum">      81 </span>            :   FILE_F0=fesA.data</a>
<a name="82"><span class="lineNum">      82 </span>            :   FILE_F1=fesB.data</a>
<a name="83"><span class="lineNum">      83 </span>            :   BIASFACTOR=10.0</a>
<a name="84"><span class="lineNum">      84 </span>            :   M_STEP=0.1</a>
<a name="85"><span class="lineNum">      85 </span>            :   AV_STRIDE=500</a>
<a name="86"><span class="lineNum">      86 </span>            :   PRINT_STRIDE=100</a>
<a name="87"><span class="lineNum">      87 </span>            : ...</a>
<a name="88"><span class="lineNum">      88 </span>            : PRINT FMT=%g STRIDE=500 FILE=Colvar.data ARG=cv,ves.bias,ves.rct</a>
<a name="89"><span class="lineNum">      89 </span>            : \endplumedfile</a>
<a name="90"><span class="lineNum">      90 </span>            : </a>
<a name="91"><span class="lineNum">      91 </span>            : The local FES files can be obtained as described in Sec. 4.2 of Ref. \cite Invernizzi2019vesdeltaf, i.e. for example:</a>
<a name="92"><span class="lineNum">      92 </span>            : - run 4 independent metad runs, all starting from basin A, and kill them as soon as they make the first transition (see e.g. \ref COMMITTOR)</a>
<a name="93"><span class="lineNum">      93 </span>            : - \verbatim cat HILLS* &gt; all_HILLS \endverbatim</a>
<a name="94"><span class="lineNum">      94 </span>            : - \verbatim plumed sum_hills --hills all_HILLS --outfile all_fesA.dat --mintozero --min 0 --max 1 --bin 100 \endverbatim</a>
<a name="95"><span class="lineNum">      95 </span>            : - \verbatim awk -v n_rep=4 '{if($1!=&quot;#!&quot; &amp;&amp; $1!=&quot;&quot;) {for(i=1+(NF-1)/2; i&lt;=NF; i++) $i/=n_rep;} print $0}' all_fesA.dat &gt; fesA.data \endverbatim</a>
<a name="96"><span class="lineNum">      96 </span>            : </a>
<a name="97"><span class="lineNum">      97 </span>            : The header of both FES files must be identical, and should be similar to the following:</a>
<a name="98"><span class="lineNum">      98 </span>            : </a>
<a name="99"><span class="lineNum">      99 </span>            : \auxfile{fesA.data}</a>
<a name="100"><span class="lineNum">     100 </span>            : #! FIELDS cv file.free der_cv</a>
<a name="101"><span class="lineNum">     101 </span>            : #! SET min_cv 0</a>
<a name="102"><span class="lineNum">     102 </span>            : #! SET max_cv 1</a>
<a name="103"><span class="lineNum">     103 </span>            : #! SET nbins_cv  100</a>
<a name="104"><span class="lineNum">     104 </span>            : #! SET periodic_cv false</a>
<a name="105"><span class="lineNum">     105 </span>            : 0 0 0</a>
<a name="106"><span class="lineNum">     106 </span>            : \endauxfile</a>
<a name="107"><span class="lineNum">     107 </span>            : \auxfile{fesB.data}</a>
<a name="108"><span class="lineNum">     108 </span>            : #! FIELDS cv file.free der_cv</a>
<a name="109"><span class="lineNum">     109 </span>            : #! SET min_cv 0</a>
<a name="110"><span class="lineNum">     110 </span>            : #! SET max_cv 1</a>
<a name="111"><span class="lineNum">     111 </span>            : #! SET nbins_cv  100</a>
<a name="112"><span class="lineNum">     112 </span>            : #! SET periodic_cv false</a>
<a name="113"><span class="lineNum">     113 </span>            : 0 0 0</a>
<a name="114"><span class="lineNum">     114 </span>            : \endauxfile</a>
<a name="115"><span class="lineNum">     115 </span>            : </a>
<a name="116"><span class="lineNum">     116 </span>            : */</a>
<a name="117"><span class="lineNum">     117 </span>            : //+ENDPLUMEDOC</a>
<a name="118"><span class="lineNum">     118 </span>            : </a>
<a name="119"><span class="lineNum">     119 </span>            : class VesDeltaF : public bias::Bias {</a>
<a name="120"><span class="lineNum">     120 </span>            : </a>
<a name="121"><span class="lineNum">     121 </span>            : private:</a>
<a name="122"><span class="lineNum">     122 </span>            :   double beta_;</a>
<a name="123"><span class="lineNum">     123 </span>            :   unsigned NumParallel_;</a>
<a name="124"><span class="lineNum">     124 </span>            :   unsigned rank_;</a>
<a name="125"><span class="lineNum">     125 </span>            :   unsigned NumWalkers_;</a>
<a name="126"><span class="lineNum">     126 </span>            :   bool isFirstStep_;</a>
<a name="127"><span class="lineNum">     127 </span>            :   bool afterCalculate_;</a>
<a name="128"><span class="lineNum">     128 </span>            : </a>
<a name="129"><span class="lineNum">     129 </span>            : //prob</a>
<a name="130"><span class="lineNum">     130 </span>            :   double tot_prob_;</a>
<a name="131"><span class="lineNum">     131 </span>            :   std::vector&lt;double&gt; prob_;</a>
<a name="132"><span class="lineNum">     132 </span>            :   std::vector&lt; std::vector&lt;double&gt; &gt; der_prob_;</a>
<a name="133"><span class="lineNum">     133 </span>            : </a>
<a name="134"><span class="lineNum">     134 </span>            : //local basins</a>
<a name="135"><span class="lineNum">     135 </span>            :   std::vector&lt; std::unique_ptr&lt;Grid&gt; &gt; grid_p_; //pointers because of GridBase::create</a>
<a name="136"><span class="lineNum">     136 </span>            :   std::vector&lt;double&gt; norm_;</a>
<a name="137"><span class="lineNum">     137 </span>            : </a>
<a name="138"><span class="lineNum">     138 </span>            : //optimizer-related stuff</a>
<a name="139"><span class="lineNum">     139 </span>            :   long long unsigned mean_counter_;</a>
<a name="140"><span class="lineNum">     140 </span>            :   unsigned mean_weight_tau_;</a>
<a name="141"><span class="lineNum">     141 </span>            :   unsigned alpha_size_;</a>
<a name="142"><span class="lineNum">     142 </span>            :   unsigned sym_alpha_size_;</a>
<a name="143"><span class="lineNum">     143 </span>            :   std::vector&lt;double&gt; mean_alpha_;</a>
<a name="144"><span class="lineNum">     144 </span>            :   std::vector&lt;double&gt; inst_alpha_;</a>
<a name="145"><span class="lineNum">     145 </span>            :   std::vector&lt;double&gt; past_increment2_;</a>
<a name="146"><span class="lineNum">     146 </span>            :   double minimization_step_;</a>
<a name="147"><span class="lineNum">     147 </span>            :   bool damping_off_;</a>
<a name="148"><span class="lineNum">     148 </span>            : //'tg' -&gt; 'target distribution'</a>
<a name="149"><span class="lineNum">     149 </span>            :   double inv_gamma_;</a>
<a name="150"><span class="lineNum">     150 </span>            :   unsigned tg_counter_;</a>
<a name="151"><span class="lineNum">     151 </span>            :   unsigned tg_stride_;</a>
<a name="152"><span class="lineNum">     152 </span>            :   std::vector&lt;double&gt; tg_dV_dAlpha_;</a>
<a name="153"><span class="lineNum">     153 </span>            :   std::vector&lt;double&gt; tg_d2V_dAlpha2_;</a>
<a name="154"><span class="lineNum">     154 </span>            : //'av' -&gt; 'ensemble average'</a>
<a name="155"><span class="lineNum">     155 </span>            :   unsigned av_counter_;</a>
<a name="156"><span class="lineNum">     156 </span>            :   unsigned av_stride_;</a>
<a name="157"><span class="lineNum">     157 </span>            :   std::vector&lt;double&gt; av_dV_dAlpha_;</a>
<a name="158"><span class="lineNum">     158 </span>            :   std::vector&lt;double&gt; av_dV_dAlpha_prod_;</a>
<a name="159"><span class="lineNum">     159 </span>            :   std::vector&lt;double&gt; av_d2V_dAlpha2_;</a>
<a name="160"><span class="lineNum">     160 </span>            : //printing</a>
<a name="161"><span class="lineNum">     161 </span>            :   unsigned print_stride_;</a>
<a name="162"><span class="lineNum">     162 </span>            :   OFile alphaOfile_;</a>
<a name="163"><span class="lineNum">     163 </span>            : //other</a>
<a name="164"><span class="lineNum">     164 </span>            :   std::vector&lt;double&gt; exp_alpha_;</a>
<a name="165"><span class="lineNum">     165 </span>            :   std::vector&lt;double&gt; prev_exp_alpha_;</a>
<a name="166"><span class="lineNum">     166 </span>            :   double work_;</a>
<a name="167"><span class="lineNum">     167 </span>            : </a>
<a name="168"><span class="lineNum">     168 </span>            : //functions</a>
<a name="169"><span class="lineNum">     169 </span>            :   void update_alpha();</a>
<a name="170"><span class="lineNum">     170 </span>            :   void update_tg_and_rct();</a>
<a name="171"><span class="lineNum">     171 </span>            :   inline unsigned get_index(const unsigned, const unsigned) const;</a>
<a name="172"><span class="lineNum">     172 </span>            : </a>
<a name="173"><span class="lineNum">     173 </span>            : public:</a>
<a name="174"><span class="lineNum">     174 </span>            :   explicit VesDeltaF(const ActionOptions&amp;);</a>
<a name="175"><span class="lineNum">     175 </span>            :   void calculate() override;</a>
<a name="176"><span class="lineNum">     176 </span>            :   void update() override;</a>
<a name="177"><span class="lineNum">     177 </span>            :   static void registerKeywords(Keywords&amp; keys);</a>
<a name="178"><span class="lineNum">     178 </span>            : };</a>
<a name="179"><span class="lineNum">     179 </span>            : </a>
<a name="180"><span class="lineNum">     180 </span><span class="lineCov">      12617 : PLUMED_REGISTER_ACTION(VesDeltaF,&quot;VES_DELTA_F&quot;)</span></a>
<a name="181"><span class="lineNum">     181 </span>            : </a>
<a name="182"><span class="lineNum">     182 </span><span class="lineCov">          6 : void VesDeltaF::registerKeywords(Keywords&amp; keys) {</span></a>
<a name="183"><span class="lineNum">     183 </span><span class="lineCov">          6 :   Bias::registerKeywords(keys);</span></a>
<a name="184"><span class="lineNum">     184 </span><span class="lineCov">          6 :   keys.use(&quot;ARG&quot;);</span></a>
<a name="185"><span class="lineNum">     185 </span><span class="lineCov">         12 :   keys.add(&quot;optional&quot;,&quot;TEMP&quot;,&quot;temperature is compulsory, but it can be sometimes fetched from the MD engine&quot;);</span></a>
<a name="186"><span class="lineNum">     186 </span>            : //local free energies</a>
<a name="187"><span class="lineNum">     187 </span><span class="lineCov">         12 :   keys.add(&quot;numbered&quot;,&quot;FILE_F&quot;,&quot;names of files containing local free energies and derivatives. &quot;</span></a>
<a name="188"><span class="lineNum">     188 </span>            :            &quot;The first one, FILE_F0, is used as reference for all the free energy differences.&quot;);</a>
<a name="189"><span class="lineNum">     189 </span><span class="lineCov">         12 :   keys.reset_style(&quot;FILE_F&quot;,&quot;compulsory&quot;);</span></a>
<a name="190"><span class="lineNum">     190 </span><span class="lineCov">         12 :   keys.addFlag(&quot;NORMALIZE&quot;,false,&quot;normalize all local free energies so that alpha will be (approx) Delta F&quot;);</span></a>
<a name="191"><span class="lineNum">     191 </span><span class="lineCov">         12 :   keys.addFlag(&quot;NO_MINTOZERO&quot;,false,&quot;leave local free energies as provided, without shifting them to zero min&quot;);</span></a>
<a name="192"><span class="lineNum">     192 </span>            : //target distribution</a>
<a name="193"><span class="lineNum">     193 </span><span class="lineCov">         12 :   keys.add(&quot;compulsory&quot;,&quot;BIASFACTOR&quot;,&quot;0&quot;,&quot;the gamma bias factor used for well-tempered target p(s).&quot;</span></a>
<a name="194"><span class="lineNum">     194 </span>            :            &quot; Set to 0 for non-tempered flat target&quot;);</a>
<a name="195"><span class="lineNum">     195 </span><span class="lineCov">         12 :   keys.add(&quot;optional&quot;,&quot;TG_STRIDE&quot;,&quot;( default=1 ) number of AV_STRIDE between updates&quot;</span></a>
<a name="196"><span class="lineNum">     196 </span>            :            &quot; of target p(s) and reweighing factor c(t)&quot;);</a>
<a name="197"><span class="lineNum">     197 </span>            : //optimization</a>
<a name="198"><span class="lineNum">     198 </span><span class="lineCov">         12 :   keys.add(&quot;compulsory&quot;,&quot;M_STEP&quot;,&quot;1.0&quot;,&quot;the mu step used for the Omega functional minimization&quot;);</span></a>
<a name="199"><span class="lineNum">     199 </span><span class="lineCov">         12 :   keys.add(&quot;compulsory&quot;,&quot;AV_STRIDE&quot;,&quot;500&quot;,&quot;number of simulation steps between alpha updates&quot;);</span></a>
<a name="200"><span class="lineNum">     200 </span><span class="lineCov">         12 :   keys.add(&quot;optional&quot;,&quot;TAU_MEAN&quot;,&quot;exponentially decaying average for alpha (rescaled using AV_STRIDE).&quot;</span></a>
<a name="201"><span class="lineNum">     201 </span>            :            &quot; Should be used only in very specific cases&quot;);</a>
<a name="202"><span class="lineNum">     202 </span><span class="lineCov">         12 :   keys.add(&quot;optional&quot;,&quot;INITIAL_ALPHA&quot;,&quot;( default=0 ) an initial guess for the bias potential parameter alpha&quot;);</span></a>
<a name="203"><span class="lineNum">     203 </span><span class="lineCov">         12 :   keys.addFlag(&quot;DAMPING_OFF&quot;,false,&quot;do not use an AdaGrad-like term to rescale M_STEP&quot;);</span></a>
<a name="204"><span class="lineNum">     204 </span>            : //output parameters file</a>
<a name="205"><span class="lineNum">     205 </span><span class="lineCov">         12 :   keys.add(&quot;compulsory&quot;,&quot;ALPHA_FILE&quot;,&quot;ALPHA&quot;,&quot;file name for output minimization parameters&quot;);</span></a>
<a name="206"><span class="lineNum">     206 </span><span class="lineCov">         12 :   keys.add(&quot;optional&quot;,&quot;PRINT_STRIDE&quot;,&quot;( default=10 ) stride for printing to ALPHA_FILE&quot;);</span></a>
<a name="207"><span class="lineNum">     207 </span><span class="lineCov">         12 :   keys.add(&quot;optional&quot;,&quot;FMT&quot;,&quot;specify format for ALPHA_FILE&quot;);</span></a>
<a name="208"><span class="lineNum">     208 </span>            : //debug flags</a>
<a name="209"><span class="lineNum">     209 </span><span class="lineCov">         12 :   keys.addFlag(&quot;SERIAL&quot;,false,&quot;perform the calculation in serial even if multiple tasks are available&quot;);</span></a>
<a name="210"><span class="lineNum">     210 </span><span class="lineCov">         12 :   keys.addFlag(&quot;MULTIPLE_WALKERS&quot;,false,&quot;use multiple walkers connected via MPI for the optimization&quot;);</span></a>
<a name="211"><span class="lineNum">     211 </span><span class="lineCov">          6 :   keys.use(&quot;RESTART&quot;);</span></a>
<a name="212"><span class="lineNum">     212 </span>            : </a>
<a name="213"><span class="lineNum">     213 </span>            : //output components</a>
<a name="214"><span class="lineNum">     214 </span><span class="lineCov">          6 :   componentsAreNotOptional(keys);</span></a>
<a name="215"><span class="lineNum">     215 </span><span class="lineCov">         12 :   keys.addOutputComponent(&quot;rct&quot;,&quot;default&quot;,&quot;the reweighting factor c(t)&quot;);</span></a>
<a name="216"><span class="lineNum">     216 </span><span class="lineCov">         12 :   keys.addOutputComponent(&quot;work&quot;,&quot;default&quot;,&quot;the work done by the bias in one AV_STRIDE&quot;);</span></a>
<a name="217"><span class="lineNum">     217 </span><span class="lineCov">          6 : }</span></a>
<a name="218"><span class="lineNum">     218 </span>            : </a>
<a name="219"><span class="lineNum">     219 </span><span class="lineCov">          4 : VesDeltaF::VesDeltaF(const ActionOptions&amp;ao)</span></a>
<a name="220"><span class="lineNum">     220 </span>            :   : PLUMED_BIAS_INIT(ao)</a>
<a name="221"><span class="lineNum">     221 </span><span class="lineCov">          4 :   , isFirstStep_(true)</span></a>
<a name="222"><span class="lineNum">     222 </span><span class="lineCov">          4 :   , afterCalculate_(false)</span></a>
<a name="223"><span class="lineNum">     223 </span><span class="lineCov">          4 :   , mean_counter_(0)</span></a>
<a name="224"><span class="lineNum">     224 </span><span class="lineCov">          4 :   , av_counter_(0)</span></a>
<a name="225"><span class="lineNum">     225 </span><span class="lineCov">          4 :   , work_(0)</span></a>
<a name="226"><span class="lineNum">     226 </span>            : {</a>
<a name="227"><span class="lineNum">     227 </span>            : //set beta</a>
<a name="228"><span class="lineNum">     228 </span><span class="lineCov">          4 :   const double Kb=plumed.getAtoms().getKBoltzmann();</span></a>
<a name="229"><span class="lineNum">     229 </span><span class="lineCov">          4 :   double temp=0;</span></a>
<a name="230"><span class="lineNum">     230 </span><span class="lineCov">          4 :   parse(&quot;TEMP&quot;,temp);</span></a>
<a name="231"><span class="lineNum">     231 </span><span class="lineCov">          4 :   double KbT=Kb*temp;</span></a>
<a name="232"><span class="lineNum">     232 </span><span class="lineCov">          4 :   if(KbT==0)</span></a>
<a name="233"><span class="lineNum">     233 </span>            :   {</a>
<a name="234"><span class="lineNum">     234 </span><span class="lineNoCov">          0 :     KbT=plumed.getAtoms().getKbT();</span></a>
<a name="235"><span class="lineNum">     235 </span><span class="lineNoCov">          0 :     plumed_massert(KbT&gt;0,&quot;your MD engine does not pass the temperature to plumed, you must specify it using TEMP&quot;);</span></a>
<a name="236"><span class="lineNum">     236 </span>            :   }</a>
<a name="237"><span class="lineNum">     237 </span><span class="lineCov">          4 :   beta_=1.0/KbT;</span></a>
<a name="238"><span class="lineNum">     238 </span>            : </a>
<a name="239"><span class="lineNum">     239 </span>            : //initialize probability grids using local free energies</a>
<a name="240"><span class="lineNum">     240 </span>            :   bool spline=true;</a>
<a name="241"><span class="lineNum">     241 </span>            :   bool sparsegrid=false;</a>
<a name="242"><span class="lineNum">     242 </span><span class="lineCov">          4 :   std::string funcl=&quot;file.free&quot;; //typical name given by sum_hills</span></a>
<a name="243"><span class="lineNum">     243 </span>            : </a>
<a name="244"><span class="lineNum">     244 </span>            :   std::vector&lt;std::string&gt; fes_names;</a>
<a name="245"><span class="lineNum">     245 </span><span class="lineCov">          8 :   for(unsigned n=0;; n++)//NB: here we start from FILE_F0 not from FILE_F1</span></a>
<a name="246"><span class="lineNum">     246 </span>            :   {</a>
<a name="247"><span class="lineNum">     247 </span>            :     std::string filename;</a>
<a name="248"><span class="lineNum">     248 </span><span class="lineCov">         24 :     if(!parseNumbered(&quot;FILE_F&quot;,n,filename))</span></a>
<a name="249"><span class="lineNum">     249 </span>            :       break;</a>
<a name="250"><span class="lineNum">     250 </span><span class="lineCov">          8 :     fes_names.push_back(filename);</span></a>
<a name="251"><span class="lineNum">     251 </span><span class="lineCov">          8 :     IFile gridfile;</span></a>
<a name="252"><span class="lineNum">     252 </span><span class="lineCov">          8 :     gridfile.open(filename);</span></a>
<a name="253"><span class="lineNum">     253 </span><span class="lineCov">          8 :     auto g=GridBase::create(funcl,getArguments(),gridfile,sparsegrid,spline,true);</span></a>
<a name="254"><span class="lineNum">     254 </span>            : // we assume this cannot be sparse. in case we want it to be sparse, some of the methods</a>
<a name="255"><span class="lineNum">     255 </span>            : // that are available only in Grid should be ported to GridBase</a>
<a name="256"><span class="lineNum">     256 </span><span class="lineCov">          8 :     auto gg=dynamic_cast&lt;Grid*&gt;(g.get());</span></a>
<a name="257"><span class="lineNum">     257 </span>            : // if this throws, g is deleted</a>
<a name="258"><span class="lineNum">     258 </span><span class="lineCov">          8 :     plumed_assert(gg);</span></a>
<a name="259"><span class="lineNum">     259 </span>            : // release ownership in order to transfer it to emplaced pointer</a>
<a name="260"><span class="lineNum">     260 </span>            :     g.release();</a>
<a name="261"><span class="lineNum">     261 </span><span class="lineCov">          8 :     grid_p_.emplace_back(gg);</span></a>
<a name="262"><span class="lineNum">     262 </span><span class="lineCov">         16 :   }</span></a>
<a name="263"><span class="lineNum">     263 </span><span class="lineCov">          4 :   plumed_massert(grid_p_.size()&gt;1,&quot;at least 2 basins must be defined, starting from FILE_F0&quot;);</span></a>
<a name="264"><span class="lineNum">     264 </span><span class="lineCov">          4 :   alpha_size_=grid_p_.size()-1;</span></a>
<a name="265"><span class="lineNum">     265 </span><span class="lineCov">          4 :   sym_alpha_size_=alpha_size_*(alpha_size_+1)/2; //useful for symmetric matrix [alpha_size_]x[alpha_size_]</span></a>
<a name="266"><span class="lineNum">     266 </span>            :   //check for consistency with first local free energy</a>
<a name="267"><span class="lineNum">     267 </span><span class="lineCov">          8 :   for(unsigned n=1; n&lt;grid_p_.size(); n++)</span></a>
<a name="268"><span class="lineNum">     268 </span>            :   {</a>
<a name="269"><span class="lineNum">     269 </span><span class="lineCov">          8 :     std::string error_tag=&quot;FILE_F&quot;+std::to_string(n)+&quot; '&quot;+fes_names[n]+&quot;' not compatible with reference one, FILE_F0&quot;;</span></a>
<a name="270"><span class="lineNum">     270 </span><span class="lineCov">          4 :     plumed_massert(grid_p_[n]-&gt;getSize()==grid_p_[0]-&gt;getSize(),error_tag);</span></a>
<a name="271"><span class="lineNum">     271 </span><span class="lineCov">          4 :     plumed_massert(grid_p_[n]-&gt;getMin()==grid_p_[0]-&gt;getMin(),error_tag);</span></a>
<a name="272"><span class="lineNum">     272 </span><span class="lineCov">          4 :     plumed_massert(grid_p_[n]-&gt;getMax()==grid_p_[0]-&gt;getMax(),error_tag);</span></a>
<a name="273"><span class="lineNum">     273 </span><span class="lineCov">          4 :     plumed_massert(grid_p_[n]-&gt;getBinVolume()==grid_p_[0]-&gt;getBinVolume(),error_tag);</span></a>
<a name="274"><span class="lineNum">     274 </span>            :   }</a>
<a name="275"><span class="lineNum">     275 </span>            : </a>
<a name="276"><span class="lineNum">     276 </span><span class="lineCov">          4 :   bool no_mintozero=false;</span></a>
<a name="277"><span class="lineNum">     277 </span><span class="lineCov">          4 :   parseFlag(&quot;NO_MINTOZERO&quot;,no_mintozero);</span></a>
<a name="278"><span class="lineNum">     278 </span><span class="lineCov">          4 :   if(!no_mintozero)</span></a>
<a name="279"><span class="lineNum">     279 </span>            :   {</a>
<a name="280"><span class="lineNum">     280 </span><span class="lineCov">          6 :     for(unsigned n=0; n&lt;grid_p_.size(); n++)</span></a>
<a name="281"><span class="lineNum">     281 </span><span class="lineCov">          4 :       grid_p_[n]-&gt;setMinToZero();</span></a>
<a name="282"><span class="lineNum">     282 </span>            :   }</a>
<a name="283"><span class="lineNum">     283 </span><span class="lineCov">          4 :   bool normalize=false;</span></a>
<a name="284"><span class="lineNum">     284 </span><span class="lineCov">          4 :   parseFlag(&quot;NORMALIZE&quot;,normalize);</span></a>
<a name="285"><span class="lineNum">     285 </span><span class="lineCov">          4 :   norm_.resize(grid_p_.size(),0);</span></a>
<a name="286"><span class="lineNum">     286 </span><span class="lineCov">          4 :   std::vector&lt;double&gt; c_norm(grid_p_.size());</span></a>
<a name="287"><span class="lineNum">     287 </span>            :   //convert the FESs to probability distributions</a>
<a name="288"><span class="lineNum">     288 </span>            :   //NB: the spline interpolation will be done on the probability distributions, not on the given FESs</a>
<a name="289"><span class="lineNum">     289 </span>            :   const unsigned ncv=getNumberOfArguments(); //just for ease</a>
<a name="290"><span class="lineNum">     290 </span><span class="lineCov">         12 :   for(unsigned n=0; n&lt;grid_p_.size(); n++)</span></a>
<a name="291"><span class="lineNum">     291 </span>            :   {</a>
<a name="292"><span class="lineNum">     292 </span><span class="lineCov">        808 :     for(Grid::index_t t=0; t&lt;grid_p_[n]-&gt;getSize(); t++)</span></a>
<a name="293"><span class="lineNum">     293 </span>            :     {</a>
<a name="294"><span class="lineNum">     294 </span><span class="lineCov">        800 :       std::vector&lt;double&gt; der(ncv);</span></a>
<a name="295"><span class="lineNum">     295 </span><span class="lineCov">        800 :       const double val=std::exp(-beta_*grid_p_[n]-&gt;getValueAndDerivatives(t,der));</span></a>
<a name="296"><span class="lineNum">     296 </span><span class="lineCov">       1600 :       for(unsigned s=0; s&lt;ncv; s++)</span></a>
<a name="297"><span class="lineNum">     297 </span><span class="lineCov">        800 :         der[s]*=-beta_*val;</span></a>
<a name="298"><span class="lineNum">     298 </span><span class="lineCov">        800 :       grid_p_[n]-&gt;setValueAndDerivatives(t,val,der);</span></a>
<a name="299"><span class="lineNum">     299 </span><span class="lineCov">        800 :       norm_[n]+=val;</span></a>
<a name="300"><span class="lineNum">     300 </span>            :     }</a>
<a name="301"><span class="lineNum">     301 </span><span class="lineCov">          8 :     c_norm[n]=1./beta_*std::log(norm_[n]);</span></a>
<a name="302"><span class="lineNum">     302 </span><span class="lineCov">          8 :     if(normalize)</span></a>
<a name="303"><span class="lineNum">     303 </span>            :     {</a>
<a name="304"><span class="lineNum">     304 </span><span class="lineCov">          4 :       grid_p_[n]-&gt;scaleAllValuesAndDerivatives(1./norm_[n]);</span></a>
<a name="305"><span class="lineNum">     305 </span><span class="lineCov">          4 :       norm_[n]=1;</span></a>
<a name="306"><span class="lineNum">     306 </span>            :     }</a>
<a name="307"><span class="lineNum">     307 </span>            :   }</a>
<a name="308"><span class="lineNum">     308 </span>            : </a>
<a name="309"><span class="lineNum">     309 </span>            : //get target</a>
<a name="310"><span class="lineNum">     310 </span><span class="lineCov">          4 :   double biasfactor=0;</span></a>
<a name="311"><span class="lineNum">     311 </span><span class="lineCov">          4 :   parse(&quot;BIASFACTOR&quot;,biasfactor);</span></a>
<a name="312"><span class="lineNum">     312 </span><span class="lineCov">          4 :   plumed_massert(biasfactor==0 || biasfactor&gt;1,&quot;BIASFACTOR must be zero (for uniform target) or greater than one&quot;);</span></a>
<a name="313"><span class="lineNum">     313 </span><span class="lineCov">          4 :   if(biasfactor==0)</span></a>
<a name="314"><span class="lineNum">     314 </span><span class="lineCov">          2 :     inv_gamma_=0;</span></a>
<a name="315"><span class="lineNum">     315 </span>            :   else</a>
<a name="316"><span class="lineNum">     316 </span><span class="lineCov">          2 :     inv_gamma_=1./biasfactor;</span></a>
<a name="317"><span class="lineNum">     317 </span><span class="lineCov">          4 :   tg_counter_=0;</span></a>
<a name="318"><span class="lineNum">     318 </span><span class="lineCov">          4 :   tg_stride_=1;</span></a>
<a name="319"><span class="lineNum">     319 </span><span class="lineCov">          4 :   parse(&quot;TG_STRIDE&quot;,tg_stride_);</span></a>
<a name="320"><span class="lineNum">     320 </span><span class="lineCov">          4 :   tg_dV_dAlpha_.resize(alpha_size_,0);</span></a>
<a name="321"><span class="lineNum">     321 </span><span class="lineCov">          4 :   tg_d2V_dAlpha2_.resize(sym_alpha_size_,0);</span></a>
<a name="322"><span class="lineNum">     322 </span>            : </a>
<a name="323"><span class="lineNum">     323 </span>            : //setup optimization stuff</a>
<a name="324"><span class="lineNum">     324 </span><span class="lineCov">          4 :   minimization_step_=1;</span></a>
<a name="325"><span class="lineNum">     325 </span><span class="lineCov">          4 :   parse(&quot;M_STEP&quot;,minimization_step_);</span></a>
<a name="326"><span class="lineNum">     326 </span>            : </a>
<a name="327"><span class="lineNum">     327 </span><span class="lineCov">          4 :   av_stride_=500;</span></a>
<a name="328"><span class="lineNum">     328 </span><span class="lineCov">          4 :   parse(&quot;AV_STRIDE&quot;,av_stride_);</span></a>
<a name="329"><span class="lineNum">     329 </span><span class="lineCov">          4 :   av_dV_dAlpha_.resize(alpha_size_,0);</span></a>
<a name="330"><span class="lineNum">     330 </span><span class="lineCov">          4 :   av_dV_dAlpha_prod_.resize(sym_alpha_size_,0);</span></a>
<a name="331"><span class="lineNum">     331 </span><span class="lineCov">          4 :   av_d2V_dAlpha2_.resize(sym_alpha_size_,0);</span></a>
<a name="332"><span class="lineNum">     332 </span>            : </a>
<a name="333"><span class="lineNum">     333 </span><span class="lineCov">          4 :   mean_weight_tau_=0;</span></a>
<a name="334"><span class="lineNum">     334 </span><span class="lineCov">          4 :   parse(&quot;TAU_MEAN&quot;,mean_weight_tau_);</span></a>
<a name="335"><span class="lineNum">     335 </span><span class="lineCov">          4 :   if(mean_weight_tau_!=1) //set it to 1 for basic SGD</span></a>
<a name="336"><span class="lineNum">     336 </span>            :   {</a>
<a name="337"><span class="lineNum">     337 </span><span class="lineCov">          4 :     plumed_massert((mean_weight_tau_==0 || mean_weight_tau_&gt;av_stride_),&quot;TAU_MEAN is rescaled with AV_STRIDE, so it has to be greater&quot;);</span></a>
<a name="338"><span class="lineNum">     338 </span><span class="lineCov">          4 :     mean_weight_tau_/=av_stride_; //this way you can look at the number of simulation steps to choose TAU_MEAN</span></a>
<a name="339"><span class="lineNum">     339 </span>            :   }</a>
<a name="340"><span class="lineNum">     340 </span>            : </a>
<a name="341"><span class="lineNum">     341 </span><span class="lineCov">          8 :   parseVector(&quot;INITIAL_ALPHA&quot;,mean_alpha_);</span></a>
<a name="342"><span class="lineNum">     342 </span><span class="lineCov">          4 :   if(mean_alpha_.size()&gt;0)</span></a>
<a name="343"><span class="lineNum">     343 </span>            :   {</a>
<a name="344"><span class="lineNum">     344 </span><span class="lineCov">          2 :     plumed_massert(mean_alpha_.size()==alpha_size_,&quot;provide one INITIAL_ALPHA for each basin beyond the first one&quot;);</span></a>
<a name="345"><span class="lineNum">     345 </span>            :   }</a>
<a name="346"><span class="lineNum">     346 </span>            :   else</a>
<a name="347"><span class="lineNum">     347 </span><span class="lineCov">          2 :     mean_alpha_.resize(alpha_size_,0);</span></a>
<a name="348"><span class="lineNum">     348 </span><span class="lineCov">          4 :   inst_alpha_=mean_alpha_;</span></a>
<a name="349"><span class="lineNum">     349 </span><span class="lineCov">          4 :   exp_alpha_.resize(alpha_size_);</span></a>
<a name="350"><span class="lineNum">     350 </span><span class="lineCov">          8 :   for(unsigned i=0; i&lt;alpha_size_; i++)</span></a>
<a name="351"><span class="lineNum">     351 </span><span class="lineCov">          4 :     exp_alpha_[i]=std::exp(-beta_*mean_alpha_[i]);</span></a>
<a name="352"><span class="lineNum">     352 </span><span class="lineCov">          4 :   prev_exp_alpha_=exp_alpha_;</span></a>
<a name="353"><span class="lineNum">     353 </span>            : </a>
<a name="354"><span class="lineNum">     354 </span><span class="lineCov">          4 :   damping_off_=false;</span></a>
<a name="355"><span class="lineNum">     355 </span><span class="lineCov">          4 :   parseFlag(&quot;DAMPING_OFF&quot;,damping_off_);</span></a>
<a name="356"><span class="lineNum">     356 </span><span class="lineCov">          4 :   if(damping_off_)</span></a>
<a name="357"><span class="lineNum">     357 </span><span class="lineCov">          2 :     past_increment2_.resize(alpha_size_,1);</span></a>
<a name="358"><span class="lineNum">     358 </span>            :   else</a>
<a name="359"><span class="lineNum">     359 </span><span class="lineCov">          2 :     past_increment2_.resize(alpha_size_,0);</span></a>
<a name="360"><span class="lineNum">     360 </span>            : </a>
<a name="361"><span class="lineNum">     361 </span>            : //file printing options</a>
<a name="362"><span class="lineNum">     362 </span><span class="lineCov">          4 :   std::string alphaFileName(&quot;ALPHA&quot;);</span></a>
<a name="363"><span class="lineNum">     363 </span><span class="lineCov">          4 :   parse(&quot;ALPHA_FILE&quot;,alphaFileName);</span></a>
<a name="364"><span class="lineNum">     364 </span><span class="lineCov">          4 :   print_stride_=10;</span></a>
<a name="365"><span class="lineNum">     365 </span><span class="lineCov">          8 :   parse(&quot;PRINT_STRIDE&quot;,print_stride_);</span></a>
<a name="366"><span class="lineNum">     366 </span>            :   std::string fmt;</a>
<a name="367"><span class="lineNum">     367 </span><span class="lineCov">          4 :   parse(&quot;FMT&quot;,fmt);</span></a>
<a name="368"><span class="lineNum">     368 </span>            : </a>
<a name="369"><span class="lineNum">     369 </span>            : //other flags, mainly for debugging</a>
<a name="370"><span class="lineNum">     370 </span><span class="lineCov">          4 :   NumParallel_=comm.Get_size();</span></a>
<a name="371"><span class="lineNum">     371 </span><span class="lineCov">          4 :   rank_=comm.Get_rank();</span></a>
<a name="372"><span class="lineNum">     372 </span><span class="lineCov">          4 :   bool serial=false;</span></a>
<a name="373"><span class="lineNum">     373 </span><span class="lineCov">          4 :   parseFlag(&quot;SERIAL&quot;,serial);</span></a>
<a name="374"><span class="lineNum">     374 </span><span class="lineCov">          4 :   if(serial)</span></a>
<a name="375"><span class="lineNum">     375 </span>            :   {</a>
<a name="376"><span class="lineNum">     376 </span><span class="lineCov">          2 :     log.printf(&quot; -- SERIAL: running without loop parallelization\n&quot;);</span></a>
<a name="377"><span class="lineNum">     377 </span><span class="lineCov">          2 :     NumParallel_=1;</span></a>
<a name="378"><span class="lineNum">     378 </span><span class="lineCov">          2 :     rank_=0;</span></a>
<a name="379"><span class="lineNum">     379 </span>            :   }</a>
<a name="380"><span class="lineNum">     380 </span>            : </a>
<a name="381"><span class="lineNum">     381 </span><span class="lineCov">          4 :   bool multiple_walkers=false;</span></a>
<a name="382"><span class="lineNum">     382 </span><span class="lineCov">          4 :   parseFlag(&quot;MULTIPLE_WALKERS&quot;,multiple_walkers);</span></a>
<a name="383"><span class="lineNum">     383 </span><span class="lineCov">          4 :   if(!multiple_walkers)</span></a>
<a name="384"><span class="lineNum">     384 </span><span class="lineCov">          2 :     NumWalkers_=1;</span></a>
<a name="385"><span class="lineNum">     385 </span>            :   else</a>
<a name="386"><span class="lineNum">     386 </span>            :   {</a>
<a name="387"><span class="lineNum">     387 </span><span class="lineCov">          2 :     if(comm.Get_rank()==0)//multi_sim_comm works well on first rank only</span></a>
<a name="388"><span class="lineNum">     388 </span><span class="lineCov">          2 :       NumWalkers_=multi_sim_comm.Get_size();</span></a>
<a name="389"><span class="lineNum">     389 </span><span class="lineCov">          2 :     if(comm.Get_size()&gt;1) //if each walker has more than one processor update them all</span></a>
<a name="390"><span class="lineNum">     390 </span><span class="lineNoCov">          0 :       comm.Bcast(NumWalkers_,0);</span></a>
<a name="391"><span class="lineNum">     391 </span>            :   }</a>
<a name="392"><span class="lineNum">     392 </span>            : </a>
<a name="393"><span class="lineNum">     393 </span><span class="lineCov">          4 :   checkRead();</span></a>
<a name="394"><span class="lineNum">     394 </span>            : </a>
<a name="395"><span class="lineNum">     395 </span>            : //restart if needed</a>
<a name="396"><span class="lineNum">     396 </span><span class="lineCov">          4 :   if(getRestart())</span></a>
<a name="397"><span class="lineNum">     397 </span>            :   {</a>
<a name="398"><span class="lineNum">     398 </span><span class="lineCov">          2 :     IFile ifile;</span></a>
<a name="399"><span class="lineNum">     399 </span><span class="lineCov">          2 :     ifile.link(*this);</span></a>
<a name="400"><span class="lineNum">     400 </span><span class="lineCov">          2 :     if(NumWalkers_&gt;1)</span></a>
<a name="401"><span class="lineNum">     401 </span><span class="lineCov">          4 :       ifile.enforceSuffix(&quot;&quot;);</span></a>
<a name="402"><span class="lineNum">     402 </span><span class="lineCov">          2 :     if(ifile.FileExist(alphaFileName))</span></a>
<a name="403"><span class="lineNum">     403 </span>            :     {</a>
<a name="404"><span class="lineNum">     404 </span><span class="lineCov">          2 :       log.printf(&quot;  Restarting from: %s\n&quot;,alphaFileName.c_str());</span></a>
<a name="405"><span class="lineNum">     405 </span><span class="lineCov">          2 :       log.printf(&quot;    all options (also PRINT_STRIDE) must be consistent!\n&quot;);</span></a>
<a name="406"><span class="lineNum">     406 </span><span class="lineCov">          2 :       log.printf(&quot;    any INITIAL_ALPHA will be overwritten\n&quot;);</span></a>
<a name="407"><span class="lineNum">     407 </span><span class="lineCov">          2 :       ifile.open(alphaFileName);</span></a>
<a name="408"><span class="lineNum">     408 </span>            :       double time;</a>
<a name="409"><span class="lineNum">     409 </span><span class="lineCov">          2 :       std::vector&lt;double&gt; damping(alpha_size_);</span></a>
<a name="410"><span class="lineNum">     410 </span><span class="lineCov">         20 :       while(ifile.scanField(&quot;time&quot;,time)) //room for improvements: only last line is important</span></a>
<a name="411"><span class="lineNum">     411 </span>            :       {</a>
<a name="412"><span class="lineNum">     412 </span><span class="lineCov">         16 :         for(unsigned i=0; i&lt;alpha_size_; i++)</span></a>
<a name="413"><span class="lineNum">     413 </span>            :         {</a>
<a name="414"><span class="lineNum">     414 </span><span class="lineCov">          8 :           const std::string index(std::to_string(i+1));</span></a>
<a name="415"><span class="lineNum">     415 </span><span class="lineCov">          8 :           prev_exp_alpha_[i]=std::exp(-beta_*mean_alpha_[i]);</span></a>
<a name="416"><span class="lineNum">     416 </span><span class="lineCov">         16 :           ifile.scanField(&quot;alpha_&quot;+index,mean_alpha_[i]);</span></a>
<a name="417"><span class="lineNum">     417 </span><span class="lineCov">         16 :           ifile.scanField(&quot;auxiliary_&quot;+index,inst_alpha_[i]);</span></a>
<a name="418"><span class="lineNum">     418 </span><span class="lineCov">         16 :           ifile.scanField(&quot;damping_&quot;+index,damping[i]);</span></a>
<a name="419"><span class="lineNum">     419 </span>            :         }</a>
<a name="420"><span class="lineNum">     420 </span><span class="lineCov">          8 :         ifile.scanField();</span></a>
<a name="421"><span class="lineNum">     421 </span><span class="lineCov">          8 :         mean_counter_+=print_stride_;</span></a>
<a name="422"><span class="lineNum">     422 </span>            :       }</a>
<a name="423"><span class="lineNum">     423 </span><span class="lineCov">          4 :       for(unsigned i=0; i&lt;alpha_size_; i++)</span></a>
<a name="424"><span class="lineNum">     424 </span>            :       {</a>
<a name="425"><span class="lineNum">     425 </span><span class="lineCov">          2 :         exp_alpha_[i]=std::exp(-beta_*mean_alpha_[i]);</span></a>
<a name="426"><span class="lineNum">     426 </span><span class="lineCov">          2 :         past_increment2_[i]=damping[i]*damping[i];</span></a>
<a name="427"><span class="lineNum">     427 </span>            :       }</a>
<a name="428"><span class="lineNum">     428 </span>            :       //sync all walkers and treads. Not sure is mandatory but is no harm</a>
<a name="429"><span class="lineNum">     429 </span><span class="lineCov">          2 :       comm.Barrier();</span></a>
<a name="430"><span class="lineNum">     430 </span><span class="lineCov">          2 :       if(comm.Get_rank()==0)</span></a>
<a name="431"><span class="lineNum">     431 </span><span class="lineCov">          2 :         multi_sim_comm.Barrier();</span></a>
<a name="432"><span class="lineNum">     432 </span>            :     }</a>
<a name="433"><span class="lineNum">     433 </span>            :     else</a>
<a name="434"><span class="lineNum">     434 </span><span class="lineNoCov">          0 :       log.printf(&quot;  -- WARNING: restart requested, but no '%s' file found!\n&quot;,alphaFileName.c_str());</span></a>
<a name="435"><span class="lineNum">     435 </span><span class="lineCov">          2 :   }</span></a>
<a name="436"><span class="lineNum">     436 </span>            : </a>
<a name="437"><span class="lineNum">     437 </span>            : //setup output file with Alpha values</a>
<a name="438"><span class="lineNum">     438 </span><span class="lineCov">          4 :   alphaOfile_.link(*this);</span></a>
<a name="439"><span class="lineNum">     439 </span><span class="lineCov">          4 :   if(NumWalkers_&gt;1)</span></a>
<a name="440"><span class="lineNum">     440 </span>            :   {</a>
<a name="441"><span class="lineNum">     441 </span><span class="lineCov">          2 :     if(comm.Get_rank()==0 &amp;&amp; multi_sim_comm.Get_rank()&gt;0)</span></a>
<a name="442"><span class="lineNum">     442 </span>            :       alphaFileName=&quot;/dev/null&quot;; //only first walker writes on file</a>
<a name="443"><span class="lineNum">     443 </span><span class="lineCov">          4 :     alphaOfile_.enforceSuffix(&quot;&quot;);</span></a>
<a name="444"><span class="lineNum">     444 </span>            :   }</a>
<a name="445"><span class="lineNum">     445 </span><span class="lineCov">          4 :   alphaOfile_.open(alphaFileName);</span></a>
<a name="446"><span class="lineNum">     446 </span><span class="lineCov">          4 :   if(fmt.length()&gt;0)</span></a>
<a name="447"><span class="lineNum">     447 </span><span class="lineCov">          8 :     alphaOfile_.fmtField(&quot; &quot;+fmt);</span></a>
<a name="448"><span class="lineNum">     448 </span>            : </a>
<a name="449"><span class="lineNum">     449 </span>            : //add other output components</a>
<a name="450"><span class="lineNum">     450 </span><span class="lineCov">          8 :   addComponent(&quot;rct&quot;); componentIsNotPeriodic(&quot;rct&quot;);</span></a>
<a name="451"><span class="lineNum">     451 </span><span class="lineCov">          8 :   addComponent(&quot;work&quot;); componentIsNotPeriodic(&quot;work&quot;);</span></a>
<a name="452"><span class="lineNum">     452 </span>            : </a>
<a name="453"><span class="lineNum">     453 </span>            : //print some info</a>
<a name="454"><span class="lineNum">     454 </span><span class="lineCov">          4 :   log.printf(&quot;  Temperature T: %g\n&quot;,1./(Kb*beta_));</span></a>
<a name="455"><span class="lineNum">     455 </span><span class="lineCov">          4 :   log.printf(&quot;  Beta (1/Kb*T): %g\n&quot;,beta_);</span></a>
<a name="456"><span class="lineNum">     456 </span><span class="lineCov">          4 :   log.printf(&quot;  Local free energy basins files and normalization constants:\n&quot;);</span></a>
<a name="457"><span class="lineNum">     457 </span><span class="lineCov">         12 :   for(unsigned n=0; n&lt;grid_p_.size(); n++)</span></a>
<a name="458"><span class="lineNum">     458 </span><span class="lineCov">          8 :     log.printf(&quot;    F_%d filename: %s  c_%d=%g\n&quot;,n,fes_names[n].c_str(),n,c_norm[n]);</span></a>
<a name="459"><span class="lineNum">     459 </span><span class="lineCov">          4 :   if(no_mintozero)</span></a>
<a name="460"><span class="lineNum">     460 </span><span class="lineCov">          2 :     log.printf(&quot; -- NO_MINTOZERO: local free energies are not shifted to be zero at minimum\n&quot;);</span></a>
<a name="461"><span class="lineNum">     461 </span><span class="lineCov">          4 :   if(normalize)</span></a>
<a name="462"><span class="lineNum">     462 </span><span class="lineCov">          2 :     log.printf(&quot; -- NORMALIZE: F_n+=c_n, alpha=DeltaF\n&quot;);</span></a>
<a name="463"><span class="lineNum">     463 </span><span class="lineCov">          4 :   log.printf(&quot;  Using target distribution with 1/gamma = %g\n&quot;,inv_gamma_);</span></a>
<a name="464"><span class="lineNum">     464 </span><span class="lineCov">          4 :   log.printf(&quot;    and updated with stride %d\n&quot;,tg_stride_);</span></a>
<a name="465"><span class="lineNum">     465 </span><span class="lineCov">          4 :   log.printf(&quot;  Step for the minimization algorithm: %g\n&quot;,minimization_step_);</span></a>
<a name="466"><span class="lineNum">     466 </span><span class="lineCov">          4 :   log.printf(&quot;  Stride for the ensemble average: %d\n&quot;,av_stride_);</span></a>
<a name="467"><span class="lineNum">     467 </span><span class="lineCov">          4 :   if(mean_weight_tau_&gt;1)</span></a>
<a name="468"><span class="lineNum">     468 </span><span class="lineCov">          2 :     log.printf(&quot;  Exponentially decaying average with weight=tau/av_stride=%d\n&quot;,mean_weight_tau_);</span></a>
<a name="469"><span class="lineNum">     469 </span><span class="lineCov">          4 :   if(mean_weight_tau_==1)</span></a>
<a name="470"><span class="lineNum">     470 </span><span class="lineNoCov">          0 :     log.printf(&quot; +++ WARNING +++ setting TAU_MEAN=1 is equivalent to use simple SGD, without mean alpha nor hessian contribution\n&quot;);</span></a>
<a name="471"><span class="lineNum">     471 </span><span class="lineCov">          4 :   log.printf(&quot;  Initial guess for alpha:\n&quot;);</span></a>
<a name="472"><span class="lineNum">     472 </span><span class="lineCov">          8 :   for(unsigned i=0; i&lt;alpha_size_; i++)</span></a>
<a name="473"><span class="lineNum">     473 </span><span class="lineCov">          4 :     log.printf(&quot;    alpha_%d = %g\n&quot;,i+1,mean_alpha_[i]);</span></a>
<a name="474"><span class="lineNum">     474 </span><span class="lineCov">          4 :   if(damping_off_)</span></a>
<a name="475"><span class="lineNum">     475 </span><span class="lineCov">          2 :     log.printf(&quot; -- DAMPING_OFF: the minimization step will NOT become smaller as the simulation goes on\n&quot;);</span></a>
<a name="476"><span class="lineNum">     476 </span><span class="lineCov">          4 :   log.printf(&quot;  Printing on file %s with stride %d\n&quot;,alphaFileName.c_str(),print_stride_);</span></a>
<a name="477"><span class="lineNum">     477 </span><span class="lineCov">          4 :   if(serial)</span></a>
<a name="478"><span class="lineNum">     478 </span><span class="lineCov">          2 :     log.printf(&quot; -- SERIAL: running without loop parallelization\n&quot;);</span></a>
<a name="479"><span class="lineNum">     479 </span><span class="lineCov">          4 :   if(NumParallel_&gt;1)</span></a>
<a name="480"><span class="lineNum">     480 </span><span class="lineCov">          2 :     log.printf(&quot;  Using multiple threads per simulation: %d\n&quot;,NumParallel_);</span></a>
<a name="481"><span class="lineNum">     481 </span><span class="lineCov">          4 :   if(multiple_walkers)</span></a>
<a name="482"><span class="lineNum">     482 </span>            :   {</a>
<a name="483"><span class="lineNum">     483 </span><span class="lineCov">          2 :     log.printf(&quot; -- MULTIPLE_WALKERS: multiple simulations will combine statistics for the optimization\n&quot;);</span></a>
<a name="484"><span class="lineNum">     484 </span><span class="lineCov">          2 :     if(NumWalkers_&gt;1)</span></a>
<a name="485"><span class="lineNum">     485 </span>            :     {</a>
<a name="486"><span class="lineNum">     486 </span><span class="lineCov">          2 :       log.printf(&quot;    number of walkers: %d\n&quot;,NumWalkers_);</span></a>
<a name="487"><span class="lineNum">     487 </span><span class="lineCov">          2 :       log.printf(&quot;    walker rank: %d\n&quot;,multi_sim_comm.Get_rank()); //only comm.Get_rank()=0 prints, so this is fine</span></a>
<a name="488"><span class="lineNum">     488 </span>            :     }</a>
<a name="489"><span class="lineNum">     489 </span>            :     else</a>
<a name="490"><span class="lineNum">     490 </span><span class="lineNoCov">          0 :       log.printf(&quot; +++ WARNING +++ only one replica found: are you sure you are running MPI-connected simulations?\n&quot;);</span></a>
<a name="491"><span class="lineNum">     491 </span>            :   }</a>
<a name="492"><span class="lineNum">     492 </span><span class="lineCov">          4 :   log.printf(&quot; Bibliography &quot;);</span></a>
<a name="493"><span class="lineNum">     493 </span><span class="lineCov">          8 :   log&lt;&lt;plumed.cite(&quot;Invernizzi and Parrinello, J. Chem. Theory Comput. 15, 2187-2194 (2019)&quot;);</span></a>
<a name="494"><span class="lineNum">     494 </span><span class="lineCov">          8 :   log&lt;&lt;plumed.cite(&quot;Valsson and Parrinello, Phys. Rev. Lett. 113, 090601 (2014)&quot;);</span></a>
<a name="495"><span class="lineNum">     495 </span><span class="lineCov">          4 :   if(inv_gamma_&gt;0)</span></a>
<a name="496"><span class="lineNum">     496 </span><span class="lineCov">          4 :     log&lt;&lt;plumed.cite(&quot;Valsson and Parrinello, J. Chem. Theory Comput. 11, 1996-2002 (2015)&quot;);</span></a>
<a name="497"><span class="lineNum">     497 </span>            : </a>
<a name="498"><span class="lineNum">     498 </span>            : //last initializations</a>
<a name="499"><span class="lineNum">     499 </span><span class="lineCov">          4 :   prob_.resize(grid_p_.size());</span></a>
<a name="500"><span class="lineNum">     500 </span><span class="lineCov">          4 :   der_prob_.resize(grid_p_.size(),std::vector&lt;double&gt;(getNumberOfArguments()));</span></a>
<a name="501"><span class="lineNum">     501 </span><span class="lineCov">          4 :   update_tg_and_rct();</span></a>
<a name="502"><span class="lineNum">     502 </span><span class="lineCov">          8 : }</span></a>
<a name="503"><span class="lineNum">     503 </span>            : </a>
<a name="504"><span class="lineNum">     504 </span><span class="lineCov">        804 : void VesDeltaF::calculate()</span></a>
<a name="505"><span class="lineNum">     505 </span>            : {</a>
<a name="506"><span class="lineNum">     506 </span>            : //get CVs</a>
<a name="507"><span class="lineNum">     507 </span><span class="lineCov">        804 :   const unsigned ncv=getNumberOfArguments(); //just for ease</span></a>
<a name="508"><span class="lineNum">     508 </span><span class="lineCov">        804 :   std::vector&lt;double&gt; cv(ncv);</span></a>
<a name="509"><span class="lineNum">     509 </span><span class="lineCov">       1608 :   for(unsigned s=0; s&lt;ncv; s++)</span></a>
<a name="510"><span class="lineNum">     510 </span><span class="lineCov">        804 :     cv[s]=getArgument(s);</span></a>
<a name="511"><span class="lineNum">     511 </span>            : //get probabilities for each basin, and total one</a>
<a name="512"><span class="lineNum">     512 </span><span class="lineCov">       2412 :   for(unsigned n=0; n&lt;grid_p_.size(); n++)</span></a>
<a name="513"><span class="lineNum">     513 </span><span class="lineCov">       1608 :     prob_[n]=grid_p_[n]-&gt;getValueAndDerivatives(cv,der_prob_[n]);</span></a>
<a name="514"><span class="lineNum">     514 </span><span class="lineCov">        804 :   tot_prob_=prob_[0];</span></a>
<a name="515"><span class="lineNum">     515 </span><span class="lineCov">       1608 :   for(unsigned i=0; i&lt;alpha_size_; i++)</span></a>
<a name="516"><span class="lineNum">     516 </span><span class="lineCov">        804 :     tot_prob_+=prob_[i+1]*exp_alpha_[i];</span></a>
<a name="517"><span class="lineNum">     517 </span>            : </a>
<a name="518"><span class="lineNum">     518 </span>            : //update bias and forces: V=-(1-inv_gamma_)*fes</a>
<a name="519"><span class="lineNum">     519 </span><span class="lineCov">        804 :   setBias((1-inv_gamma_)/beta_*std::log(tot_prob_));</span></a>
<a name="520"><span class="lineNum">     520 </span><span class="lineCov">       1608 :   for(unsigned s=0; s&lt;ncv; s++)</span></a>
<a name="521"><span class="lineNum">     521 </span>            :   {</a>
<a name="522"><span class="lineNum">     522 </span><span class="lineCov">        804 :     double dProb_dCV_s=der_prob_[0][s];</span></a>
<a name="523"><span class="lineNum">     523 </span><span class="lineCov">       1608 :     for(unsigned i=0; i&lt;alpha_size_; i++)</span></a>
<a name="524"><span class="lineNum">     524 </span><span class="lineCov">        804 :       dProb_dCV_s+=der_prob_[i+1][s]*exp_alpha_[i];</span></a>
<a name="525"><span class="lineNum">     525 </span><span class="lineCov">        804 :     setOutputForce(s,-(1-inv_gamma_)/beta_/tot_prob_*dProb_dCV_s);</span></a>
<a name="526"><span class="lineNum">     526 </span>            :   }</a>
<a name="527"><span class="lineNum">     527 </span><span class="lineCov">        804 :   afterCalculate_=true;</span></a>
<a name="528"><span class="lineNum">     528 </span><span class="lineCov">        804 : }</span></a>
<a name="529"><span class="lineNum">     529 </span>            : </a>
<a name="530"><span class="lineNum">     530 </span><span class="lineCov">        804 : void VesDeltaF::update()</span></a>
<a name="531"><span class="lineNum">     531 </span>            : {</a>
<a name="532"><span class="lineNum">     532 </span>            : //skip first step to sync getTime() and av_counter_, as in METAD</a>
<a name="533"><span class="lineNum">     533 </span><span class="lineCov">        804 :   if(isFirstStep_)</span></a>
<a name="534"><span class="lineNum">     534 </span>            :   {</a>
<a name="535"><span class="lineNum">     535 </span><span class="lineCov">          4 :     isFirstStep_=false;</span></a>
<a name="536"><span class="lineNum">     536 </span><span class="lineCov">          4 :     return;</span></a>
<a name="537"><span class="lineNum">     537 </span>            :   }</a>
<a name="538"><span class="lineNum">     538 </span><span class="lineCov">        800 :   plumed_massert(afterCalculate_,&quot;VesDeltaF::update() must be called after VesDeltaF::calculate() to work properly&quot;);</span></a>
<a name="539"><span class="lineNum">     539 </span><span class="lineCov">        800 :   afterCalculate_=false;</span></a>
<a name="540"><span class="lineNum">     540 </span>            : </a>
<a name="541"><span class="lineNum">     541 </span>            : //calculate derivatives for ensemble averages</a>
<a name="542"><span class="lineNum">     542 </span><span class="lineCov">        800 :   std::vector&lt;double&gt; dV_dAlpha(alpha_size_);</span></a>
<a name="543"><span class="lineNum">     543 </span><span class="lineCov">        800 :   std::vector&lt;double&gt; d2V_dAlpha2(sym_alpha_size_);</span></a>
<a name="544"><span class="lineNum">     544 </span><span class="lineCov">       1600 :   for(unsigned i=0; i&lt;alpha_size_; i++)</span></a>
<a name="545"><span class="lineNum">     545 </span><span class="lineCov">        800 :     dV_dAlpha[i]=-(1-inv_gamma_)/tot_prob_*prob_[i+1]*exp_alpha_[i];</span></a>
<a name="546"><span class="lineNum">     546 </span><span class="lineCov">       1600 :   for(unsigned i=0; i&lt;alpha_size_; i++)</span></a>
<a name="547"><span class="lineNum">     547 </span>            :   {</a>
<a name="548"><span class="lineNum">     548 </span><span class="lineCov">        800 :     d2V_dAlpha2[get_index(i,i)]=-beta_*dV_dAlpha[i];</span></a>
<a name="549"><span class="lineNum">     549 </span><span class="lineCov">       1600 :     for(unsigned j=i; j&lt;alpha_size_; j++)</span></a>
<a name="550"><span class="lineNum">     550 </span><span class="lineCov">        800 :       d2V_dAlpha2[get_index(i,j)]-=beta_/(1-inv_gamma_)*dV_dAlpha[i]*dV_dAlpha[j];</span></a>
<a name="551"><span class="lineNum">     551 </span>            :   }</a>
<a name="552"><span class="lineNum">     552 </span>            : //update ensemble averages</a>
<a name="553"><span class="lineNum">     553 </span><span class="lineCov">        800 :   av_counter_++;</span></a>
<a name="554"><span class="lineNum">     554 </span><span class="lineCov">       1600 :   for(unsigned i=0; i&lt;alpha_size_; i++)</span></a>
<a name="555"><span class="lineNum">     555 </span>            :   {</a>
<a name="556"><span class="lineNum">     556 </span><span class="lineCov">        800 :     av_dV_dAlpha_[i]+=(dV_dAlpha[i]-av_dV_dAlpha_[i])/av_counter_;</span></a>
<a name="557"><span class="lineNum">     557 </span><span class="lineCov">       1600 :     for(unsigned j=i; j&lt;alpha_size_; j++)</span></a>
<a name="558"><span class="lineNum">     558 </span>            :     {</a>
<a name="559"><span class="lineNum">     559 </span><span class="lineCov">        800 :       const unsigned ij=get_index(i,j);</span></a>
<a name="560"><span class="lineNum">     560 </span><span class="lineCov">        800 :       av_dV_dAlpha_prod_[ij]+=(dV_dAlpha[i]*dV_dAlpha[j]-av_dV_dAlpha_prod_[ij])/av_counter_;</span></a>
<a name="561"><span class="lineNum">     561 </span><span class="lineCov">        800 :       av_d2V_dAlpha2_[ij]+=(d2V_dAlpha2[ij]-av_d2V_dAlpha2_[ij])/av_counter_;</span></a>
<a name="562"><span class="lineNum">     562 </span>            :     }</a>
<a name="563"><span class="lineNum">     563 </span>            :   }</a>
<a name="564"><span class="lineNum">     564 </span>            : //update work</a>
<a name="565"><span class="lineNum">     565 </span><span class="lineCov">        800 :   double prev_tot_prob=prob_[0];</span></a>
<a name="566"><span class="lineNum">     566 </span><span class="lineCov">       1600 :   for(unsigned i=0; i&lt;alpha_size_; i++)</span></a>
<a name="567"><span class="lineNum">     567 </span><span class="lineCov">        800 :     prev_tot_prob+=prob_[i+1]*prev_exp_alpha_[i];</span></a>
<a name="568"><span class="lineNum">     568 </span><span class="lineCov">        800 :   work_+=(1-inv_gamma_)/beta_*std::log(tot_prob_/prev_tot_prob);</span></a>
<a name="569"><span class="lineNum">     569 </span>            : </a>
<a name="570"><span class="lineNum">     570 </span>            : //update coefficients</a>
<a name="571"><span class="lineNum">     571 </span><span class="lineCov">        800 :   if(av_counter_==av_stride_)</span></a>
<a name="572"><span class="lineNum">     572 </span>            :   {</a>
<a name="573"><span class="lineNum">     573 </span><span class="lineCov">         16 :     update_alpha();</span></a>
<a name="574"><span class="lineNum">     574 </span><span class="lineCov">         16 :     tg_counter_++;</span></a>
<a name="575"><span class="lineNum">     575 </span><span class="lineCov">         16 :     if(tg_counter_==tg_stride_)</span></a>
<a name="576"><span class="lineNum">     576 </span>            :     {</a>
<a name="577"><span class="lineNum">     577 </span><span class="lineCov">         12 :       update_tg_and_rct();</span></a>
<a name="578"><span class="lineNum">     578 </span><span class="lineCov">         12 :       tg_counter_=0;</span></a>
<a name="579"><span class="lineNum">     579 </span>            :     }</a>
<a name="580"><span class="lineNum">     580 </span>            :     //reset the ensemble averages</a>
<a name="581"><span class="lineNum">     581 </span><span class="lineCov">         16 :     av_counter_=0;</span></a>
<a name="582"><span class="lineNum">     582 </span>            :     std::fill(av_dV_dAlpha_.begin(),av_dV_dAlpha_.end(),0);</a>
<a name="583"><span class="lineNum">     583 </span>            :     std::fill(av_dV_dAlpha_prod_.begin(),av_dV_dAlpha_prod_.end(),0);</a>
<a name="584"><span class="lineNum">     584 </span>            :     std::fill(av_d2V_dAlpha2_.begin(),av_d2V_dAlpha2_.end(),0);</a>
<a name="585"><span class="lineNum">     585 </span>            :   }</a>
<a name="586"><span class="lineNum">     586 </span>            : }</a>
<a name="587"><span class="lineNum">     587 </span>            : </a>
<a name="588"><span class="lineNum">     588 </span><span class="lineCov">         16 : void VesDeltaF::update_tg_and_rct()</span></a>
<a name="589"><span class="lineNum">     589 </span>            : {</a>
<a name="590"><span class="lineNum">     590 </span>            : //calculate target averages</a>
<a name="591"><span class="lineNum">     591 </span><span class="lineCov">         16 :   double Z_0=norm_[0];</span></a>
<a name="592"><span class="lineNum">     592 </span><span class="lineCov">         32 :   for(unsigned i=0; i&lt;alpha_size_; i++)</span></a>
<a name="593"><span class="lineNum">     593 </span><span class="lineCov">         16 :     Z_0+=norm_[i+1]*exp_alpha_[i];</span></a>
<a name="594"><span class="lineNum">     594 </span><span class="lineCov">         16 :   double Z_tg=0;</span></a>
<a name="595"><span class="lineNum">     595 </span>            :   std::fill(tg_dV_dAlpha_.begin(),tg_dV_dAlpha_.end(),0);</a>
<a name="596"><span class="lineNum">     596 </span>            :   std::fill(tg_d2V_dAlpha2_.begin(),tg_d2V_dAlpha2_.end(),0);</a>
<a name="597"><span class="lineNum">     597 </span><span class="lineCov">       1116 :   for(Grid::index_t t=rank_; t&lt;grid_p_[0]-&gt;getSize(); t+=NumParallel_)</span></a>
<a name="598"><span class="lineNum">     598 </span>            :   { //TODO can we recycle some code?</a>
<a name="599"><span class="lineNum">     599 </span><span class="lineCov">       1100 :     std::vector&lt;double&gt; prob(grid_p_.size());</span></a>
<a name="600"><span class="lineNum">     600 </span><span class="lineCov">       3300 :     for(unsigned n=0; n&lt;grid_p_.size(); n++)</span></a>
<a name="601"><span class="lineNum">     601 </span><span class="lineCov">       2200 :       prob[n]=grid_p_[n]-&gt;getValue(t);</span></a>
<a name="602"><span class="lineNum">     602 </span><span class="lineCov">       1100 :     double tot_prob=prob[0];</span></a>
<a name="603"><span class="lineNum">     603 </span><span class="lineCov">       2200 :     for(unsigned i=0; i&lt;alpha_size_; i++)</span></a>
<a name="604"><span class="lineNum">     604 </span><span class="lineCov">       1100 :       tot_prob+=prob[i+1]*exp_alpha_[i];</span></a>
<a name="605"><span class="lineNum">     605 </span><span class="lineCov">       1100 :     std::vector&lt;double&gt; dV_dAlpha(alpha_size_);</span></a>
<a name="606"><span class="lineNum">     606 </span><span class="lineCov">       1100 :     std::vector&lt;double&gt; d2V_dAlpha2(sym_alpha_size_);</span></a>
<a name="607"><span class="lineNum">     607 </span><span class="lineCov">       2200 :     for(unsigned i=0; i&lt;alpha_size_; i++)</span></a>
<a name="608"><span class="lineNum">     608 </span><span class="lineCov">       1100 :       dV_dAlpha[i]=-(1-inv_gamma_)/tot_prob*prob[i+1]*exp_alpha_[i];</span></a>
<a name="609"><span class="lineNum">     609 </span><span class="lineCov">       2200 :     for(unsigned i=0; i&lt;alpha_size_; i++)</span></a>
<a name="610"><span class="lineNum">     610 </span>            :     {</a>
<a name="611"><span class="lineNum">     611 </span><span class="lineCov">       1100 :       d2V_dAlpha2[get_index(i,i)]=-beta_*dV_dAlpha[i];</span></a>
<a name="612"><span class="lineNum">     612 </span><span class="lineCov">       2200 :       for(unsigned j=i; j&lt;alpha_size_; j++)</span></a>
<a name="613"><span class="lineNum">     613 </span><span class="lineCov">       1100 :         d2V_dAlpha2[get_index(i,j)]-=beta_/(1-inv_gamma_)*dV_dAlpha[i]*dV_dAlpha[j];</span></a>
<a name="614"><span class="lineNum">     614 </span>            :     }</a>
<a name="615"><span class="lineNum">     615 </span><span class="lineCov">       1100 :     const double unnorm_tg_p=std::pow(tot_prob,inv_gamma_);</span></a>
<a name="616"><span class="lineNum">     616 </span><span class="lineCov">       1100 :     Z_tg+=unnorm_tg_p;</span></a>
<a name="617"><span class="lineNum">     617 </span><span class="lineCov">       2200 :     for(unsigned i=0; i&lt;alpha_size_; i++)</span></a>
<a name="618"><span class="lineNum">     618 </span><span class="lineCov">       1100 :       tg_dV_dAlpha_[i]+=unnorm_tg_p*dV_dAlpha[i];</span></a>
<a name="619"><span class="lineNum">     619 </span><span class="lineCov">       2200 :     for(unsigned ij=0; ij&lt;sym_alpha_size_; ij++)</span></a>
<a name="620"><span class="lineNum">     620 </span><span class="lineCov">       1100 :       tg_d2V_dAlpha2_[ij]+=unnorm_tg_p*d2V_dAlpha2[ij];</span></a>
<a name="621"><span class="lineNum">     621 </span>            :   }</a>
<a name="622"><span class="lineNum">     622 </span><span class="lineCov">         16 :   if(NumParallel_&gt;1)</span></a>
<a name="623"><span class="lineNum">     623 </span>            :   {</a>
<a name="624"><span class="lineNum">     624 </span><span class="lineCov">         10 :     comm.Sum(Z_tg);</span></a>
<a name="625"><span class="lineNum">     625 </span><span class="lineCov">         10 :     comm.Sum(tg_dV_dAlpha_);</span></a>
<a name="626"><span class="lineNum">     626 </span><span class="lineCov">         10 :     comm.Sum(tg_d2V_dAlpha2_);</span></a>
<a name="627"><span class="lineNum">     627 </span>            :   }</a>
<a name="628"><span class="lineNum">     628 </span><span class="lineCov">         32 :   for(unsigned i=0; i&lt;alpha_size_; i++)</span></a>
<a name="629"><span class="lineNum">     629 </span><span class="lineCov">         16 :     tg_dV_dAlpha_[i]/=Z_tg;</span></a>
<a name="630"><span class="lineNum">     630 </span><span class="lineCov">         32 :   for(unsigned ij=0; ij&lt;sym_alpha_size_; ij++)</span></a>
<a name="631"><span class="lineNum">     631 </span><span class="lineCov">         16 :     tg_d2V_dAlpha2_[ij]/=Z_tg;</span></a>
<a name="632"><span class="lineNum">     632 </span><span class="lineCov">         16 :   getPntrToComponent(&quot;rct&quot;)-&gt;set(-1./beta_*std::log(Z_tg/Z_0)); //Z_tg is the best available estimate of Z_V</span></a>
<a name="633"><span class="lineNum">     633 </span><span class="lineCov">         16 : }</span></a>
<a name="634"><span class="lineNum">     634 </span>            : </a>
<a name="635"><span class="lineNum">     635 </span><span class="lineCov">         16 : void VesDeltaF::update_alpha()</span></a>
<a name="636"><span class="lineNum">     636 </span>            : {</a>
<a name="637"><span class="lineNum">     637 </span>            : //combining the averages of multiple walkers</a>
<a name="638"><span class="lineNum">     638 </span><span class="lineCov">         16 :   if(NumWalkers_&gt;1)</span></a>
<a name="639"><span class="lineNum">     639 </span>            :   {</a>
<a name="640"><span class="lineNum">     640 </span><span class="lineCov">          8 :     if(comm.Get_rank()==0) //sum only once: in the first rank of each walker</span></a>
<a name="641"><span class="lineNum">     641 </span>            :     {</a>
<a name="642"><span class="lineNum">     642 </span><span class="lineCov">          8 :       multi_sim_comm.Sum(av_dV_dAlpha_);</span></a>
<a name="643"><span class="lineNum">     643 </span><span class="lineCov">          8 :       multi_sim_comm.Sum(av_dV_dAlpha_prod_);</span></a>
<a name="644"><span class="lineNum">     644 </span><span class="lineCov">          8 :       multi_sim_comm.Sum(av_d2V_dAlpha2_);</span></a>
<a name="645"><span class="lineNum">     645 </span><span class="lineCov">         16 :       for(unsigned i=0; i&lt;alpha_size_; i++)</span></a>
<a name="646"><span class="lineNum">     646 </span><span class="lineCov">          8 :         av_dV_dAlpha_[i]/=NumWalkers_;</span></a>
<a name="647"><span class="lineNum">     647 </span><span class="lineCov">         16 :       for(unsigned ij=0; ij&lt;sym_alpha_size_; ij++)</span></a>
<a name="648"><span class="lineNum">     648 </span>            :       {</a>
<a name="649"><span class="lineNum">     649 </span><span class="lineCov">          8 :         av_dV_dAlpha_prod_[ij]/=NumWalkers_;</span></a>
<a name="650"><span class="lineNum">     650 </span><span class="lineCov">          8 :         av_d2V_dAlpha2_[ij]/=NumWalkers_;</span></a>
<a name="651"><span class="lineNum">     651 </span>            :       }</a>
<a name="652"><span class="lineNum">     652 </span>            :     }</a>
<a name="653"><span class="lineNum">     653 </span><span class="lineCov">          8 :     if(comm.Get_size()&gt;1)//if there are more ranks for each walker, everybody has to know</span></a>
<a name="654"><span class="lineNum">     654 </span>            :     {</a>
<a name="655"><span class="lineNum">     655 </span><span class="lineNoCov">          0 :       comm.Bcast(av_dV_dAlpha_,0);</span></a>
<a name="656"><span class="lineNum">     656 </span><span class="lineNoCov">          0 :       comm.Bcast(av_dV_dAlpha_prod_,0);</span></a>
<a name="657"><span class="lineNum">     657 </span><span class="lineNoCov">          0 :       comm.Bcast(av_d2V_dAlpha2_,0);</span></a>
<a name="658"><span class="lineNum">     658 </span>            :     }</a>
<a name="659"><span class="lineNum">     659 </span>            :   }</a>
<a name="660"><span class="lineNum">     660 </span>            :   //set work and reset it</a>
<a name="661"><span class="lineNum">     661 </span><span class="lineCov">         16 :   getPntrToComponent(&quot;work&quot;)-&gt;set(work_);</span></a>
<a name="662"><span class="lineNum">     662 </span><span class="lineCov">         16 :   work_=0;</span></a>
<a name="663"><span class="lineNum">     663 </span>            : </a>
<a name="664"><span class="lineNum">     664 </span>            : //build the gradient and the Hessian of the functional</a>
<a name="665"><span class="lineNum">     665 </span><span class="lineCov">         16 :   std::vector&lt;double&gt; grad_omega(alpha_size_);</span></a>
<a name="666"><span class="lineNum">     666 </span><span class="lineCov">         16 :   std::vector&lt;double&gt; hess_omega(sym_alpha_size_);</span></a>
<a name="667"><span class="lineNum">     667 </span><span class="lineCov">         32 :   for(unsigned i=0; i&lt;alpha_size_; i++)</span></a>
<a name="668"><span class="lineNum">     668 </span>            :   {</a>
<a name="669"><span class="lineNum">     669 </span><span class="lineCov">         16 :     grad_omega[i]=tg_dV_dAlpha_[i]-av_dV_dAlpha_[i];</span></a>
<a name="670"><span class="lineNum">     670 </span><span class="lineCov">         32 :     for(unsigned j=i; j&lt;alpha_size_; j++)</span></a>
<a name="671"><span class="lineNum">     671 </span>            :     {</a>
<a name="672"><span class="lineNum">     672 </span><span class="lineCov">         16 :       const unsigned ij=get_index(i,j);</span></a>
<a name="673"><span class="lineNum">     673 </span><span class="lineCov">         16 :       hess_omega[ij]=beta_*(av_dV_dAlpha_prod_[ij]-av_dV_dAlpha_[i]*av_dV_dAlpha_[j])+tg_d2V_dAlpha2_[ij]-av_d2V_dAlpha2_[ij];</span></a>
<a name="674"><span class="lineNum">     674 </span>            :     }</a>
<a name="675"><span class="lineNum">     675 </span>            :   }</a>
<a name="676"><span class="lineNum">     676 </span>            : //calculate the increment and update alpha</a>
<a name="677"><span class="lineNum">     677 </span><span class="lineCov">         16 :   mean_counter_++;</span></a>
<a name="678"><span class="lineNum">     678 </span>            :   long long unsigned mean_weight=mean_counter_;</a>
<a name="679"><span class="lineNum">     679 </span><span class="lineCov">         16 :   if(mean_weight_tau_&gt;0 &amp;&amp; mean_weight_tau_&lt;mean_counter_)</span></a>
<a name="680"><span class="lineNum">     680 </span>            :     mean_weight=mean_weight_tau_;</a>
<a name="681"><span class="lineNum">     681 </span><span class="lineCov">         16 :   std::vector&lt;double&gt; damping(alpha_size_);</span></a>
<a name="682"><span class="lineNum">     682 </span><span class="lineCov">         32 :   for(unsigned i=0; i&lt;alpha_size_; i++)</span></a>
<a name="683"><span class="lineNum">     683 </span>            :   {</a>
<a name="684"><span class="lineNum">     684 </span><span class="lineCov">         16 :     double increment_i=grad_omega[i];</span></a>
<a name="685"><span class="lineNum">     685 </span><span class="lineCov">         32 :     for(unsigned j=0; j&lt;alpha_size_; j++)</span></a>
<a name="686"><span class="lineNum">     686 </span><span class="lineCov">         16 :       increment_i+=hess_omega[get_index(i,j)]*(inst_alpha_[j]-mean_alpha_[j]);</span></a>
<a name="687"><span class="lineNum">     687 </span><span class="lineCov">         16 :     if(!damping_off_)</span></a>
<a name="688"><span class="lineNum">     688 </span><span class="lineCov">          8 :       past_increment2_[i]+=increment_i*increment_i;</span></a>
<a name="689"><span class="lineNum">     689 </span><span class="lineCov">         16 :     damping[i]=std::sqrt(past_increment2_[i]);</span></a>
<a name="690"><span class="lineNum">     690 </span><span class="lineCov">         16 :     prev_exp_alpha_[i]=std::exp(-beta_*mean_alpha_[i]);</span></a>
<a name="691"><span class="lineNum">     691 </span><span class="lineCov">         16 :     inst_alpha_[i]-=minimization_step_/damping[i]*increment_i;</span></a>
<a name="692"><span class="lineNum">     692 </span><span class="lineCov">         16 :     mean_alpha_[i]+=(inst_alpha_[i]-mean_alpha_[i])/mean_weight;</span></a>
<a name="693"><span class="lineNum">     693 </span><span class="lineCov">         16 :     exp_alpha_[i]=std::exp(-beta_*mean_alpha_[i]);</span></a>
<a name="694"><span class="lineNum">     694 </span>            :   }</a>
<a name="695"><span class="lineNum">     695 </span>            : </a>
<a name="696"><span class="lineNum">     696 </span>            : //update the Alpha file</a>
<a name="697"><span class="lineNum">     697 </span><span class="lineCov">         16 :   if(mean_counter_%print_stride_==0)</span></a>
<a name="698"><span class="lineNum">     698 </span>            :   {</a>
<a name="699"><span class="lineNum">     699 </span><span class="lineCov">         16 :     alphaOfile_.printField(&quot;time&quot;,getTime());</span></a>
<a name="700"><span class="lineNum">     700 </span><span class="lineCov">         32 :     for(unsigned i=0; i&lt;alpha_size_; i++)</span></a>
<a name="701"><span class="lineNum">     701 </span>            :     {</a>
<a name="702"><span class="lineNum">     702 </span><span class="lineCov">         16 :       const std::string index(std::to_string(i+1));</span></a>
<a name="703"><span class="lineNum">     703 </span><span class="lineCov">         32 :       alphaOfile_.printField(&quot;alpha_&quot;+index,mean_alpha_[i]);</span></a>
<a name="704"><span class="lineNum">     704 </span><span class="lineCov">         32 :       alphaOfile_.printField(&quot;auxiliary_&quot;+index,inst_alpha_[i]);</span></a>
<a name="705"><span class="lineNum">     705 </span><span class="lineCov">         32 :       alphaOfile_.printField(&quot;damping_&quot;+index,damping[i]);</span></a>
<a name="706"><span class="lineNum">     706 </span>            :     }</a>
<a name="707"><span class="lineNum">     707 </span><span class="lineCov">         16 :     alphaOfile_.printField();</span></a>
<a name="708"><span class="lineNum">     708 </span>            :   }</a>
<a name="709"><span class="lineNum">     709 </span><span class="lineCov">         16 : }</span></a>
<a name="710"><span class="lineNum">     710 </span>            : </a>
<a name="711"><span class="lineNum">     711 </span>            : //mapping of a [alpha_size_]x[alpha_size_] symmetric matrix into a vector of size sym_alpha_size_, useful for the communicator</a>
<a name="712"><span class="lineNum">     712 </span><span class="lineCov">       4632 : inline unsigned VesDeltaF::get_index(const unsigned i, const unsigned j) const</span></a>
<a name="713"><span class="lineNum">     713 </span>            : {</a>
<a name="714"><span class="lineNum">     714 </span><span class="lineCov">       4632 :   if(i&lt;=j)</span></a>
<a name="715"><span class="lineNum">     715 </span><span class="lineCov">       4632 :     return j+i*(alpha_size_-1)-i*(i-1)/2;</span></a>
<a name="716"><span class="lineNum">     716 </span>            :   else</a>
<a name="717"><span class="lineNum">     717 </span><span class="lineNoCov">          0 :     return get_index(j,i);</span></a>
<a name="718"><span class="lineNum">     718 </span>            : }</a>
<a name="719"><span class="lineNum">     719 </span>            : </a>
<a name="720"><span class="lineNum">     720 </span>            : }</a>
<a name="721"><span class="lineNum">     721 </span>            : }</a>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="https://github.com/linux-test-project/lcov" target="_parent">LCOV version 1.16</a></td></tr>
  </table>
  <br>

</body>
</html>
